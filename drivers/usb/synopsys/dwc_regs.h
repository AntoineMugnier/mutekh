/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -o cdefs -O drivers/usb/synopsys/dwc_regs.h cdefs_use_reg_mask=1      \
     cdefs_use_field_setval=1 -I usb_synopsis_dwc.bf                           \
     cdefs_use_field_shift=1 cdefs_use_field_shifted_mask=1                    \
     cdefs_sfx_field_shifter=_SHIFT_VAL
*/

#ifndef _SYNOPSYS_USB_BFGEN_DEFS_
#define _SYNOPSYS_USB_BFGEN_DEFS_

#define SYNOPSYS_USB_GOTGCTL_ADDR                    0x00000000
#define SYNOPSYS_USB_GOTGCTL_MASK                    0x001f0fff
/** The core sets this bit when a session request initiation is successful.
   @multiple */
  #define SYNOPSYS_USB_GOTGCTL_SESREQSCS           0x00000001
  #define SYNOPSYS_USB_GOTGCTL_SESREQSCS_SHIFT     0
/** The application sets this bit to initiate a session request on the USB. The
   application can clear this bit by writing a 0 when the Host Negotiation
   Success Status Change bit in the OTG Interrupt register
   (USB_GOTGINT.HSTNEGSUCSTSCHNG) is set. The core clears this bit when the
   HSTNEGSUCSTSCHNG bit is cleared. The application must wait until the VBUS
   discharges to 0.2 V, after the B-Session Valid bit in this register
   (USB_GOTGCTL.BSESVLD) is cleared. This discharge time can be obtained from the
   datasheet. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_SESREQ              0x00000002
  #define SYNOPSYS_USB_GOTGCTL_SESREQ_SHIFT        1
/** This bit is used to enable/disable the software to override the vbusvalid
   signal using the USB_GOTGCTL.VBVALIDOVVAL. When set, vbusvalid received from
   the PHY is overridden with USB_GOTGCTL.VBVALIDOVVAL. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_VBVALIDOVEN         0x00000004
  #define SYNOPSYS_USB_GOTGCTL_VBVALIDOVEN_SHIFT   2
/** This bit is used to set Override value for vbusvalid signal when
   USB_GOTGCTL.VBVALIDOVEN is set. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_VBVALIDOVAL         0x00000008
  #define SYNOPSYS_USB_GOTGCTL_VBVALIDOVAL_SHIFT   3
/** This bit is used to enable/disable the software to override the Bvalid signal
   using the USB_GOTGCTL.BVALIDOVVAL. When set Bvalid received from the PHY is
   overridden with USB_GOTGCTL.BVALIDOVVAL. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_BVALIDOVEN          0x00000010
  #define SYNOPSYS_USB_GOTGCTL_BVALIDOVEN_SHIFT    4
/** This bit is used to set Override value for Bvalid signal when
   USB_GOTGCTL.BVALIDOVEN is set. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_BVALIDOVAL          0x00000020
  #define SYNOPSYS_USB_GOTGCTL_BVALIDOVAL_SHIFT    5
/** This bit is used to enable/disable the software to override the Avalid signal
   using the USB_GOTGCTL.AVALIDOVVAL. When set Avalid received from the PHY is
   overridden with USB_GOTGCTL.AVALIDOVVAL. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_AVALIDOVEN          0x00000040
  #define SYNOPSYS_USB_GOTGCTL_AVALIDOVEN_SHIFT    6
/** This bit is used to set Override value for Avalid signal when
   USB_GOTGCTL.AVALIDOVEN is set. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_AVALIDOVAL          0x00000080
  #define SYNOPSYS_USB_GOTGCTL_AVALIDOVAL_SHIFT    7
/** The core sets this bit when host negotiation is successful. The core clears
   this bit when the HNP Request (HNPREQ) bit in this register is set. @multiple
   */
  #define SYNOPSYS_USB_GOTGCTL_HSTNEGSCS           0x00000100
  #define SYNOPSYS_USB_GOTGCTL_HSTNEGSCS_SHIFT     8
/** The application sets this bit to initiate an HNP request to the connected USB
   host. The application can clear this bit by writing a 0 when the Host
   Negotiation Success Status Change bit in the OTG Interrupt register
   (USB_GOTGINT.HSTNEGSUCSTSCHNG) is set. The core clears this bit when the
   HSTNEGSUCSTSCHNG bit is cleared. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_HNPREQ              0x00000200
  #define SYNOPSYS_USB_GOTGCTL_HNPREQ_SHIFT        9
/** The application sets this bit when it has successfully enabled HNP (using the
   SetFeature.SetHNPEnable command) on the connected device. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_HSTSETHNPEN         0x00000400
  #define SYNOPSYS_USB_GOTGCTL_HSTSETHNPEN_SHIFT   10
/** The application sets this bit when it successfully receives a
   SetFeature.SetHNPEnable command from the connected USB host. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_DEVHNPEN            0x00000800
  #define SYNOPSYS_USB_GOTGCTL_DEVHNPEN_SHIFT      11
/** Indicates the connector ID status on a connect event. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_CONIDSTS            0x00010000
  #define SYNOPSYS_USB_GOTGCTL_CONIDSTS_SHIFT      16
  #define SYNOPSYS_USB_GOTGCTL_CONIDSTS_SHIFT_VAL(v) ((SYNOPSYS_USB_GOTGCTL_CONIDSTS_##v) << 16)
  #define SYNOPSYS_USB_GOTGCTL_CONIDSTS_SET(x, v)  do { (x) = (((x) & ~0x10000) | ((SYNOPSYS_USB_GOTGCTL_CONIDSTS_##v) << 16)); } while(0)
  #define SYNOPSYS_USB_GOTGCTL_CONIDSTS_SETVAL(x, v) do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define SYNOPSYS_USB_GOTGCTL_CONIDSTS_GET(x)     (((x) >> 16) & 0x1)
    #define SYNOPSYS_USB_GOTGCTL_CONIDSTS_A_MODE     0x00000000
    #define SYNOPSYS_USB_GOTGCTL_CONIDSTS_B_MODE     0x00000001
/** Indicates the debounce time of a detected connection. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_DBNCTIME            0x00020000
  #define SYNOPSYS_USB_GOTGCTL_DBNCTIME_SHIFT      17
  #define SYNOPSYS_USB_GOTGCTL_DBNCTIME_SHIFT_VAL(v) ((SYNOPSYS_USB_GOTGCTL_DBNCTIME_##v) << 17)
  #define SYNOPSYS_USB_GOTGCTL_DBNCTIME_SET(x, v)  do { (x) = (((x) & ~0x20000) | ((SYNOPSYS_USB_GOTGCTL_DBNCTIME_##v) << 17)); } while(0)
  #define SYNOPSYS_USB_GOTGCTL_DBNCTIME_SETVAL(x, v) do { (x) = (((x) & ~0x20000) | ((v) << 17)); } while(0)
  #define SYNOPSYS_USB_GOTGCTL_DBNCTIME_GET(x)     (((x) >> 17) & 0x1)
    #define SYNOPSYS_USB_GOTGCTL_DBNCTIME_LONG       0x00000000
    #define SYNOPSYS_USB_GOTGCTL_DBNCTIME_SHORT      0x00000001
/** Indicates the Host mode transceiver status for A-session valid. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_ASESVLD             0x00040000
  #define SYNOPSYS_USB_GOTGCTL_ASESVLD_SHIFT       18
/** Indicates the Device mode transceiver status for B-session valid. In OTG
   mode, you can use this bit to determine if the device is connected or
   disconnected. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_BSESVLD             0x00080000
  #define SYNOPSYS_USB_GOTGCTL_BSESVLD_SHIFT       19
/** Indicates the OTG revision. @multiple */
  #define SYNOPSYS_USB_GOTGCTL_OTGVER              0x00100000
  #define SYNOPSYS_USB_GOTGCTL_OTGVER_SHIFT        20
  #define SYNOPSYS_USB_GOTGCTL_OTGVER_SHIFT_VAL(v) ((SYNOPSYS_USB_GOTGCTL_OTGVER_##v) << 20)
  #define SYNOPSYS_USB_GOTGCTL_OTGVER_SET(x, v)    do { (x) = (((x) & ~0x100000) | ((SYNOPSYS_USB_GOTGCTL_OTGVER_##v) << 20)); } while(0)
  #define SYNOPSYS_USB_GOTGCTL_OTGVER_SETVAL(x, v) do { (x) = (((x) & ~0x100000) | ((v) << 20)); } while(0)
  #define SYNOPSYS_USB_GOTGCTL_OTGVER_GET(x)       (((x) >> 20) & 0x1)
    #define SYNOPSYS_USB_GOTGCTL_OTGVER_OTG13        0x00000000
    #define SYNOPSYS_USB_GOTGCTL_OTGVER_OTG20        0x00000001

#define SYNOPSYS_USB_GOTGINT_ADDR                    0x00000004
#define SYNOPSYS_USB_GOTGINT_MASK                    0x000e0304
/** The core sets this bit when VBUS is in the range 0.8V - 2.0V. This bit can be
   set only by the core and the application should write 1 to clear it. @multiple
   */
  #define SYNOPSYS_USB_GOTGINT_SESENDDET           0x00000004
  #define SYNOPSYS_USB_GOTGINT_SESENDDET_SHIFT     2
/** The core sets this bit on the success or failure of a session request. The
   application must read the Session Request Success bit in the OTG Control and
   Status register (USB_GOTGCTL.SESREQSCS) to check for success or failure. This
   bit can be set only by the core and the application should write 1 to clear
   it. @multiple */
  #define SYNOPSYS_USB_GOTGINT_SESREQSUCSTSCHNG    0x00000100
  #define SYNOPSYS_USB_GOTGINT_SESREQSUCSTSCHNG_SHIFT 8
/** The core sets this bit on the success or failure of a USB host negotiation
   request. The application must read the Host Negotiation Success bit of the OTG
   Control and Status register (USB_GOTGCTL.HSTNEGSCS) to check for success or
   failure. This bit can be set only by the core and the application should write
   1 to clear it. @multiple */
  #define SYNOPSYS_USB_GOTGINT_HSTNEGSUCSTSCHNG    0x00000200
  #define SYNOPSYS_USB_GOTGINT_HSTNEGSUCSTSCHNG_SHIFT 9
/** The core sets this bit when it detects a host negotiation request on the USB.
   This bit can be set only by the core and the application should write 1 to
   clear it. @multiple */
  #define SYNOPSYS_USB_GOTGINT_HSTNEGDET           0x00020000
  #define SYNOPSYS_USB_GOTGINT_HSTNEGDET_SHIFT     17
/** the core sets this bit to indicate that the a-device has timed out while
   waiting for the b-device to connect. this bit can be set only by the core and
   the application should write 1 to clear it. @multiple */
  #define SYNOPSYS_USB_GOTGINT_ADEVTOUTCHG         0x00040000
  #define SYNOPSYS_USB_GOTGINT_ADEVTOUTCHG_SHIFT   18
/** The core sets this bit when the debounce is completed after the device
   connect. The application can start driving USB reset after seeing this
   interrupt. This bit is only valid when the HNP Capable or SRP Capable bit is
   set in the Core USB Configuration register (USB_GUSBCFG.HNPCAP or
   USB_GUSBCFG.SRPCAP, respectively). This bit can be set only by the core and
   the application should write 1 to clear it. @multiple */
  #define SYNOPSYS_USB_GOTGINT_DBNCEDONE           0x00080000
  #define SYNOPSYS_USB_GOTGINT_DBNCEDONE_SHIFT     19

#define SYNOPSYS_USB_GAHBCFG_ADDR                    0x00000008
#define SYNOPSYS_USB_GAHBCFG_MASK                    0x006001bf
/** The application uses this bit to mask or unmask the interrupt line assertion
   to itself. Irrespective of this bit's setting, the interrupt status registers
   are updated by the core. Set to unmask. @multiple */
  #define SYNOPSYS_USB_GAHBCFG_GLBLINTRMSK         0x00000001
  #define SYNOPSYS_USB_GAHBCFG_GLBLINTRMSK_SHIFT   0
/** This field is used in DMA mode. @multiple */
  #define SYNOPSYS_USB_GAHBCFG_HBSTLEN             0x0000001e
  #define SYNOPSYS_USB_GAHBCFG_HBSTLEN_SHIFT       1
  #define SYNOPSYS_USB_GAHBCFG_HBSTLEN_SHIFT_VAL(v) ((SYNOPSYS_USB_GAHBCFG_HBSTLEN_##v) << 1)
  #define SYNOPSYS_USB_GAHBCFG_HBSTLEN_SET(x, v)   do { (x) = (((x) & ~0x1e) | ((SYNOPSYS_USB_GAHBCFG_HBSTLEN_##v) << 1)); } while(0)
  #define SYNOPSYS_USB_GAHBCFG_HBSTLEN_SETVAL(x, v) do { (x) = (((x) & ~0x1e) | ((v) << 1)); } while(0)
  #define SYNOPSYS_USB_GAHBCFG_HBSTLEN_GET(x)      (((x) >> 1) & 0xf)
    #define SYNOPSYS_USB_GAHBCFG_HBSTLEN_SINGLE      0x00000000
    #define SYNOPSYS_USB_GAHBCFG_HBSTLEN_INCR        0x00000001
    #define SYNOPSYS_USB_GAHBCFG_HBSTLEN_INCR4       0x00000003
    #define SYNOPSYS_USB_GAHBCFG_HBSTLEN_INCR8       0x00000005
    #define SYNOPSYS_USB_GAHBCFG_HBSTLEN_INCR16      0x00000007
/** When set to 0 the core operates in Slave mode. When set to 1 the core
   operates in a DMA mode. @multiple */
  #define SYNOPSYS_USB_GAHBCFG_DMAEN               0x00000020
  #define SYNOPSYS_USB_GAHBCFG_DMAEN_SHIFT         5
/** This bit is used only in Slave mode. In host mode this bit indicates when the
   Non-Periodic TxFIFO Empty Interrupt bit in the Core Interrupt register
   (USB_GINTSTS.NPTXFEMP) is triggered. In device mode, this bit indicates when
   IN endpoint Transmit FIFO empty interrupt (USB_DIEP0INT/USB_DIEPx_INT.TXFEMP)
   is triggered. @multiple */
  #define SYNOPSYS_USB_GAHBCFG_NPTXFEMPLVL         0x00000080
  #define SYNOPSYS_USB_GAHBCFG_NPTXFEMPLVL_SHIFT   7
  #define SYNOPSYS_USB_GAHBCFG_NPTXFEMPLVL_SHIFT_VAL(v) ((SYNOPSYS_USB_GAHBCFG_NPTXFEMPLVL_##v) << 7)
  #define SYNOPSYS_USB_GAHBCFG_NPTXFEMPLVL_SET(x, v) do { (x) = (((x) & ~0x80) | ((SYNOPSYS_USB_GAHBCFG_NPTXFEMPLVL_##v) << 7)); } while(0)
  #define SYNOPSYS_USB_GAHBCFG_NPTXFEMPLVL_SETVAL(x, v) do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
  #define SYNOPSYS_USB_GAHBCFG_NPTXFEMPLVL_GET(x)  (((x) >> 7) & 0x1)
    #define SYNOPSYS_USB_GAHBCFG_NPTXFEMPLVL_HALFEMPTY 0x00000000
    #define SYNOPSYS_USB_GAHBCFG_NPTXFEMPLVL_EMPTY   0x00000001
/** Indicates when the Periodic TxFIFO Empty Interrupt bit in the Core Interrupt
   register (USB_GINTSTS.PTXFEMP) is triggered. This bit is used only in Slave
   mode. @multiple */
  #define SYNOPSYS_USB_GAHBCFG_PTXFEMPLVL          0x00000100
  #define SYNOPSYS_USB_GAHBCFG_PTXFEMPLVL_SHIFT    8
  #define SYNOPSYS_USB_GAHBCFG_PTXFEMPLVL_SHIFT_VAL(v) ((SYNOPSYS_USB_GAHBCFG_PTXFEMPLVL_##v) << 8)
  #define SYNOPSYS_USB_GAHBCFG_PTXFEMPLVL_SET(x, v) do { (x) = (((x) & ~0x100) | ((SYNOPSYS_USB_GAHBCFG_PTXFEMPLVL_##v) << 8)); } while(0)
  #define SYNOPSYS_USB_GAHBCFG_PTXFEMPLVL_SETVAL(x, v) do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define SYNOPSYS_USB_GAHBCFG_PTXFEMPLVL_GET(x)   (((x) >> 8) & 0x1)
    #define SYNOPSYS_USB_GAHBCFG_PTXFEMPLVL_HALFEMPTY 0x00000000
    #define SYNOPSYS_USB_GAHBCFG_PTXFEMPLVL_EMPTY    0x00000001
/** This bit is programmed to enable the functionality to wait for the system DMA
   Done Signal for the DMA Write Transfers. When set, the int_dma_req output
   signal is asserted when HSOTG DMA starts write transfer to the external
   memory. When the core is done with the Transfers it asserts int_dma_done
   signal to flag the completion of DMA writes from HSOTG. The core then waits
   for sys_dma_done signal from the system to proceed further and complete the
   Data Transfer corresponding to a particular Channel/Endpoint. When cleared,
   the int_dma_req and int_dma_done signals are not asserted and the core
   proceeds with the assertion of the XferComp interrupt as soon as the DMA write
   transfer is done at the HSOTG Core Boundary and it doesn't wait for the
   sys_dma_done signal to complete the DATA. @multiple */
  #define SYNOPSYS_USB_GAHBCFG_REMMEMSUPP          0x00200000
  #define SYNOPSYS_USB_GAHBCFG_REMMEMSUPP_SHIFT    21
/** This bit is programmed to enable the System DMA Done functionality for all
   the DMA write Transactions corresponding to the Channel/ Endpoint. This bit is
   valid only when USB_GAHBCFG.REMMEMSUPP is set to 1. When set, the core asserts
   int_dma_req for all the DMA write transactions on the AHB interface along with
   int_dma_done, chep_last_transact and chep_number signal informations. The core
   waits for sys_dma_done signal for all the DMA write transactions in order to
   complete the transfer of a particular Channel/ Endpoint. When cleared, the
   core asserts int_dma_req signal only for the last transaction of DMA write
   transfer corresponding to a particular Channel/Endpoint. Similarly, the core
   waits for sys_dma_done signal only for that transaction of DMA write to
   complete the transfer of a particular Channel/Endpoint. @multiple */
  #define SYNOPSYS_USB_GAHBCFG_NOTIALLDMAWRIT      0x00400000
  #define SYNOPSYS_USB_GAHBCFG_NOTIALLDMAWRIT_SHIFT 22

#define SYNOPSYS_USB_GUSBCFG_ADDR                    0x0000000c
#define SYNOPSYS_USB_GUSBCFG_MASK                    0xf0403f27
/** Always write this field to 0. @multiple */
  #define SYNOPSYS_USB_GUSBCFG_TOUTCAL             0x00000007
  #define SYNOPSYS_USB_GUSBCFG_TOUTCAL_SHIFT       0
  #define SYNOPSYS_USB_GUSBCFG_TOUTCAL_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_GUSBCFG_TOUTCAL_SET(x, v)   do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_GUSBCFG_TOUTCAL_GET(x)      (((x) >> 0) & 0x7)
/** Always write this field to 0. @multiple */
  #define SYNOPSYS_USB_GUSBCFG_FSINTF              0x00000020
  #define SYNOPSYS_USB_GUSBCFG_FSINTF_SHIFT        5
/** The application uses this bit to control the core's SRP capabilities. If the
   core operates as a non-SRP-capable B-device, it cannot request the connected
   A-device (host) to activate VBUS and start a session. Set to enable SRP
   capability. @multiple */
  #define SYNOPSYS_USB_GUSBCFG_SRPCAP              0x00000100
  #define SYNOPSYS_USB_GUSBCFG_SRPCAP_SHIFT        8
/** The application uses this bit to control the core's HNP capabilities. Set to
   enable HNP capability. @multiple */
  #define SYNOPSYS_USB_GUSBCFG_HNPCAP              0x00000200
  #define SYNOPSYS_USB_GUSBCFG_HNPCAP_SHIFT        9
/** Sets the turnaround time in PHY clocks. Specifies the response time For a MAC
   request to the Packet FIFO Controller (PFC) to fetch data from the DFIFO
   (SPRAM). Always write this field to 5. @multiple */
  #define SYNOPSYS_USB_GUSBCFG_USBTRDTIM           0x00003c00
  #define SYNOPSYS_USB_GUSBCFG_USBTRDTIM_SHIFT     10
  #define SYNOPSYS_USB_GUSBCFG_USBTRDTIM_SHIFT_VAL(v) ((v) << 10)
  #define SYNOPSYS_USB_GUSBCFG_USBTRDTIM_SET(x, v) do { (x) = (((x) & ~0x3c00) | ((v) << 10)); } while(0)
  #define SYNOPSYS_USB_GUSBCFG_USBTRDTIM_GET(x)    (((x) >> 10) & 0xf)
/** This bit selects utmi_termselect to drive data line pulse during SRP.
   @multiple */
  #define SYNOPSYS_USB_GUSBCFG_TERMSELDLPULSE      0x00400000
  #define SYNOPSYS_USB_GUSBCFG_TERMSELDLPULSE_SHIFT 22
  #define SYNOPSYS_USB_GUSBCFG_TERMSELDLPULSE_SHIFT_VAL(v) ((SYNOPSYS_USB_GUSBCFG_TERMSELDLPULSE_##v) << 22)
  #define SYNOPSYS_USB_GUSBCFG_TERMSELDLPULSE_SET(x, v) do { (x) = (((x) & ~0x400000) | ((SYNOPSYS_USB_GUSBCFG_TERMSELDLPULSE_##v) << 22)); } while(0)
  #define SYNOPSYS_USB_GUSBCFG_TERMSELDLPULSE_SETVAL(x, v) do { (x) = (((x) & ~0x400000) | ((v) << 22)); } while(0)
  #define SYNOPSYS_USB_GUSBCFG_TERMSELDLPULSE_GET(x) (((x) >> 22) & 0x1)
    #define SYNOPSYS_USB_GUSBCFG_TERMSELDLPULSE_TXVALID 0x00000000
    #define SYNOPSYS_USB_GUSBCFG_TERMSELDLPULSE_TERMSEL 0x00000001
/** Writing 1 to this bit enables the core to follow the TxEndDelay timings as
   per UTMI+ specification 1.05 section 4.1.5 for opmode signal during remote
   wakeup. @multiple */
  #define SYNOPSYS_USB_GUSBCFG_TXENDELAY           0x10000000
  #define SYNOPSYS_USB_GUSBCFG_TXENDELAY_SHIFT     28
/** Writing a 1 to this bit forces the core to host mode irrespective of the
   state of the ID pin. After setting the force bit, the application must wait at
   least 65 ms before the change to take effect. @multiple */
  #define SYNOPSYS_USB_GUSBCFG_FORCEHSTMODE        0x20000000
  #define SYNOPSYS_USB_GUSBCFG_FORCEHSTMODE_SHIFT  29
/** Writing a 1 to this bit forces the core to device mode irrespective of the
   state of the ID pin. After setting the force bit, the application must wait at
   least 25 ms before the change to take effect. @multiple */
  #define SYNOPSYS_USB_GUSBCFG_FORCEDEVMODE        0x40000000
  #define SYNOPSYS_USB_GUSBCFG_FORCEDEVMODE_SHIFT  30
/** This bit is for debug purposes only. Never Set this bit to 1. The application
   should always write 0 to this bit. @multiple */
  #define SYNOPSYS_USB_GUSBCFG_CORRUPTTXPKT        0x80000000
  #define SYNOPSYS_USB_GUSBCFG_CORRUPTTXPKT_SHIFT  31

#define SYNOPSYS_USB_GRSTCTL_ADDR                    0x00000010
#define SYNOPSYS_USB_GRSTCTL_MASK                    0xc00007f5
/** Resets the core by clearing the interrupts and all the CSR registers except
   the following register bits: USB_PCGCCTL.RSTPDWNMODULE, USB_PCGCCTL.GATEHCLK,
   USB_PCGCCTL.PWRCLMP, USB_GUSBCFG.FSINTF, USB_HCFG.FSLSPCLKSEL,
   USB_DCFG.DEVSPD. All module state machines (except the AHB Slave Unit) are
   reset to the IDLE state, and all the transmit FIFOs and the receive FIFO are
   flushed. Any transactions on the AHB Master are terminated as soon as
   possible, after gracefully completing the last data phase of an AHB transfer.
   Any transactions on the USB are terminated immediately. The application can
   write to this bit any time it wants to reset the core. This is a self-clearing
   bit and the core clears this bit after all the necessary logic is reset in the
   core, which can take several clocks, depending on the current state of the
   core. Once this bit is cleared software must wait at least 3 clock cycles
   before doing any access to the core. Software must also must check that bit 31
   of this register is 1 (AHB Master is IDLE) before starting any operation.
   @multiple */
  #define SYNOPSYS_USB_GRSTCTL_CSFTRST             0x00000001
  #define SYNOPSYS_USB_GRSTCTL_CSFTRST_SHIFT       0
/** The application writes this bit to reset the frame number counter inside the
   core. When the frame counter is reset, the subsequent SOF sent out by the core
   has a frame number of 0. When application writes 1 to the bit, it might not be
   able to read back the value as it will get cleared by the core in a few clock
   cycles. @multiple */
  #define SYNOPSYS_USB_GRSTCTL_FRMCNTRRST          0x00000004
  #define SYNOPSYS_USB_GRSTCTL_FRMCNTRRST_SHIFT    2
/** The application can flush the entire RxFIFO using this bit, but must first
   ensure that the core is not in the middle of a transaction. The application
   must only write to this bit after checking that the core is neither reading
   from the RxFIFO nor writing to the RxFIFO. The application must wait until the
   bit is cleared before performing any other operations. This bit requires 8
   clocks to clear. @multiple */
  #define SYNOPSYS_USB_GRSTCTL_RXFFLSH             0x00000010
  #define SYNOPSYS_USB_GRSTCTL_RXFFLSH_SHIFT       4
/** This bit selectively flushes a single or all transmit FIFOs, but cannot do so
   if the core is in the midle of a transaction. The application must write this
   bit only after checking that the core is neither writing to the TxFIFO nor
   reading from the TxFIFO. NAK Effective Interrupt ensures the core is not
   reading from the FIFO. USB_GRSTCTL.AHBIDLE ensures the core is not writing
   anything to the FIFO. Flushing is normally recommended when FIFOs are
   reconfigured. FIFO flushing is also recommended during device endpoint
   disable. The application must wait until the core clears this bit before
   performing any operations. This bit takes eight clocks to clear @multiple */
  #define SYNOPSYS_USB_GRSTCTL_TXFFLSH             0x00000020
  #define SYNOPSYS_USB_GRSTCTL_TXFFLSH_SHIFT       5
/** This is the FIFO number that must be flushed using the TxFIFO Flush bit. This
   field must not be changed until the core clears the TxFIFO Flush bit.
   @multiple */
  #define SYNOPSYS_USB_GRSTCTL_TXFNUM              0x000007c0
  #define SYNOPSYS_USB_GRSTCTL_TXFNUM_SHIFT        6
  #define SYNOPSYS_USB_GRSTCTL_TXFNUM_SHIFT_VAL(v) ((SYNOPSYS_USB_GRSTCTL_TXFNUM_##v) << 6)
  #define SYNOPSYS_USB_GRSTCTL_TXFNUM_SET(x, v)    do { (x) = (((x) & ~0x7c0) | ((SYNOPSYS_USB_GRSTCTL_TXFNUM_##v) << 6)); } while(0)
  #define SYNOPSYS_USB_GRSTCTL_TXFNUM_SETVAL(x, v) do { (x) = (((x) & ~0x7c0) | ((v) << 6)); } while(0)
  #define SYNOPSYS_USB_GRSTCTL_TXFNUM_GET(x)       (((x) >> 6) & 0x1f)
    #define SYNOPSYS_USB_GRSTCTL_TXFNUM_FIFO0        0x00000000
    #define SYNOPSYS_USB_GRSTCTL_TXFNUM_FIFO1        0x00000001
    #define SYNOPSYS_USB_GRSTCTL_TXFNUM_FIFO2        0x00000002
    #define SYNOPSYS_USB_GRSTCTL_TXFNUM_FIFO3        0x00000003
    #define SYNOPSYS_USB_GRSTCTL_TXFNUM_FIFO4        0x00000004
    #define SYNOPSYS_USB_GRSTCTL_TXFNUM_FIFO5        0x00000005
    #define SYNOPSYS_USB_GRSTCTL_TXFNUM_FIFO6        0x00000006
    #define SYNOPSYS_USB_GRSTCTL_TXFNUM_ALLFIFO      0x00000010
/** Indicates that the DMA request is in progress. Used for debug @multiple */
  #define SYNOPSYS_USB_GRSTCTL_DMAREQ              0x40000000
  #define SYNOPSYS_USB_GRSTCTL_DMAREQ_SHIFT        30
/** Indicates that the AHB Master State Machine is in the IDLE condition.
   @multiple */
  #define SYNOPSYS_USB_GRSTCTL_AHBIDLE             0x80000000
  #define SYNOPSYS_USB_GRSTCTL_AHBIDLE_SHIFT       31

#define SYNOPSYS_USB_GINTSTS_ADDR                    0x00000014
#define SYNOPSYS_USB_GINTSTS_MASK                    0xf7fc7cff
/** Indicates the current mode. @multiple */
  #define SYNOPSYS_USB_GINTSTS_CURMODE             0x00000001
  #define SYNOPSYS_USB_GINTSTS_CURMODE_SHIFT       0
/** The core sets this bit when the application is trying to access a Host mode
   register, when the core is operating in Device mode or when the application
   accesses a Device mode register, when the core is operating in Host mode. The
   register access is ignored by the core internally and does not affect the
   operation of the core. This bit can be set only by the core and the
   application should write 1 to clear it. @multiple */
  #define SYNOPSYS_USB_GINTSTS_MODEMIS             0x00000002
  #define SYNOPSYS_USB_GINTSTS_MODEMIS_SHIFT       1
/** The core sets this bit to indicate an OTG protocol event. The application
   must read the OTG Interrupt Status (USB_GOTGINT) register to determine the
   exact event that caused this interrupt. The application must clear the
   appropriate status bit in the USB_GOTGINT register to clear this bit.
   @multiple */
  #define SYNOPSYS_USB_GINTSTS_OTGINT              0x00000004
  #define SYNOPSYS_USB_GINTSTS_OTGINT_SHIFT        2
/** In Host mode, the core sets this bit to indicate that an SOF (FS) or
   Keep-Alive (LS) is transmitted on the USB. The application must write a 1 to
   this bit to clear the interrupt. In Device mode, in the core sets this bit to
   indicate that an SOF token has been received on the USB. The application can
   read the Device Status register to get the current frame number. This
   interrupt is seen only when the core is operating at full-speed (FS). This bit
   can be set only by the core and the application should write 1 to clear it.
   @multiple */
  #define SYNOPSYS_USB_GINTSTS_SOF                 0x00000008
  #define SYNOPSYS_USB_GINTSTS_SOF_SHIFT           3
/** Indicates that there is at least one packet pending to be read from the
   RxFIFO. @multiple */
  #define SYNOPSYS_USB_GINTSTS_RXFLVL              0x00000010
  #define SYNOPSYS_USB_GINTSTS_RXFLVL_SHIFT        4
/** This interrupt is asserted when the Non-periodic TxFIFO is either half or
   completely empty, and there is space for at least one entry to be written to
   the Non-periodic Transmit Request Queue. The half or completely empty status
   is determined by the Non-periodic TxFIFO Empty Level bit in the Core AHB
   Configuration register (USB_GAHBCFG.NPTXFEMPLVL). @multiple */
  #define SYNOPSYS_USB_GINTSTS_NPTXFEMP            0x00000020
  #define SYNOPSYS_USB_GINTSTS_NPTXFEMP_SHIFT      5
/** Indicates that the Set Global Non-periodic IN NAK bit in the Device Control
   register (USB_DCTL.SGNPINNAK), set by the application, has taken effect in the
   core. That is, the core has sampled the Global IN NAK bit set by the
   application. This bit can be cleared by clearing the Clear Global Non-periodic
   IN NAK bit in the Device Control register (USB_DCTL.CGNPINNAK). This interrupt
   does not necessarily mean that a NAK handshake is sent out on the USB. The
   STALL bit takes precedence over the NAK bit. @multiple */
  #define SYNOPSYS_USB_GINTSTS_GINNAKEFF           0x00000040
  #define SYNOPSYS_USB_GINTSTS_GINNAKEFF_SHIFT     6
/** Indicates that the Set Global OUT NAK bit in the Device Control register
   (USB_DCTL.SGOUTNAK), set by the application, has taken effect in the core.
   This bit can be cleared by writing the Clear Global OUT NAK bit in the Device
   Control register (USB_DCTL.CGOUTNAK). @multiple */
  #define SYNOPSYS_USB_GINTSTS_GOUTNAKEFF          0x00000080
  #define SYNOPSYS_USB_GINTSTS_GOUTNAKEFF_SHIFT    7
/** The core sets this bit to indicate that an Idle state has been detected on
   the USB for 3 ms. @multiple */
  #define SYNOPSYS_USB_GINTSTS_ERLYSUSP            0x00000400
  #define SYNOPSYS_USB_GINTSTS_ERLYSUSP_SHIFT      10
/** The core sets this bit to indicate that a suspend was detected on the USB.
   The core enters the Suspended state when there is no activity on the bus for
   an extended period of time. @multiple */
  #define SYNOPSYS_USB_GINTSTS_USBSUSP             0x00000800
  #define SYNOPSYS_USB_GINTSTS_USBSUSP_SHIFT       11
/** The core sets this bit to indicate that a reset is detected on the USB.
   @multiple */
  #define SYNOPSYS_USB_GINTSTS_USBRST              0x00001000
  #define SYNOPSYS_USB_GINTSTS_USBRST_SHIFT        12
/** The core sets this bit to indicate that speed enumeration is complete. The
   application must read the Device Status (USB_DSTS) register to obtain the
   enumerated speed. @multiple */
  #define SYNOPSYS_USB_GINTSTS_ENUMDONE            0x00002000
  #define SYNOPSYS_USB_GINTSTS_ENUMDONE_SHIFT      13
/** The core sets this bit when it fails to write an isochronous OUT packet into
   the RxFIFO because the RxFIFO does not have enough space to accommodate a
   maximum packet size packet for the isochronous OUT endpoint. @multiple */
  #define SYNOPSYS_USB_GINTSTS_ISOOUTDROP          0x00004000
  #define SYNOPSYS_USB_GINTSTS_ISOOUTDROP_SHIFT    14
/** The core sets this bit to indicate that an interrupt is pending on one of the
   IN endpoints of the core (in Device mode). The application must read the
   Device All Endpoints Interrupt (USB_DAINT) register to determine the exact
   number of the IN endpoint on Device IN Endpoint-x Interrupt
   (USB_DIEP0INT/USB_DIEPx_INT) register to determine the exact cause of the
   interrupt. The application must clear the appropriate status bit in the
   corresponding USB_DIEP0INT/USB_DIEPx_INT register to clear this bit. @multiple
   */
  #define SYNOPSYS_USB_GINTSTS_IEPINT              0x00040000
  #define SYNOPSYS_USB_GINTSTS_IEPINT_SHIFT        18
/** The core sets this bit to indicate that an interrupt is pending on one of the
   OUT endpoints of the core (in Device mode). The application must read the
   Device All Endpoints Interrupt (USB_DAINT) register to determine the exact
   number of the OUT endpoint on which the interrupt occurred, and then read the
   corresponding Device OUT Endpoint-x Interrupt (USB_DOEP0INT/USB_DOEPx_INT)
   register to determine the exact cause of the interrupt. The application must
   clear the appropriate status bit in the corresponding
   USB_DOEP0INT/USB_DOEPx_INT register to clear this bit. @multiple */
  #define SYNOPSYS_USB_GINTSTS_OEPINT              0x00080000
  #define SYNOPSYS_USB_GINTSTS_OEPINT_SHIFT        19
/** The core sets this interrupt to indicate that there is at least one
   isochronous IN endpoint on which the transfer is not completed in the current
   frame. @multiple */
  #define SYNOPSYS_USB_GINTSTS_INCOMPISOIN         0x00100000
  #define SYNOPSYS_USB_GINTSTS_INCOMPISOIN_SHIFT   20
/** In Host mode, the core sets this interrupt bit when there are incomplete
   periodic transactions still pending which are scheduled for the current frame.
   In Device mode, the core sets this interrupt to indicate that there is at
   least one isochronous OUT endpoint on which the transfer is not completed in
   the current frame. This bit can be set only by the core and the application
   should write 1 to clear it. @multiple */
  #define SYNOPSYS_USB_GINTSTS_INCOMPLP            0x00200000
  #define SYNOPSYS_USB_GINTSTS_INCOMPLP_SHIFT      21
/** This interrupt is valid only in DMA mode. This interrupt indicates that the
   core has stopped fetching data for IN endpoints due to the unavailability of
   TxFIFO space or Request Queue space. This interrupt is used by the application
   for an endpoint mismatch algorithm. For example, after detecting an endpoint
   mismatch, the application: Sets a Global non-periodic IN NAK handshake,
   Disables In endpoints, Flushes the FIFO, Determines the token sequence from
   the IN Token Sequence, Re-enables the endpoints, Clears the Global
   non-periodic IN NAK handshake. If the Global non-periodic IN NAK is cleared,
   the core has not yet fetched data for the IN endpoint, and the IN token is
   received: the core generates an IN Token Received when FIFO Empty interrupt.
   The OTG then sends the host a NAK response. To avoid this scenario, the
   application can check the USB_GINTSTS.FETSUSP interrupt, which ensures that
   the FIFO is full before clearing a Global NAK handshake. Alternatively, the
   application can mask the IN Token Received when FIFO Empty interrupt when
   clearing a Global IN NAK handshake. @multiple */
  #define SYNOPSYS_USB_GINTSTS_FETSUSP             0x00400000
  #define SYNOPSYS_USB_GINTSTS_FETSUSP_SHIFT       22
/** This interrupt is valid only in DMA mode. This interrupt indicates that the
   core has stopped fetching data for IN endpoints due to the unavailability of
   TxFIFO space or Request Queue space. This interrupt is used by the application
   for an endpoint mismatch algorithm. @multiple */
  #define SYNOPSYS_USB_GINTSTS_RESETDET            0x00800000
  #define SYNOPSYS_USB_GINTSTS_RESETDET_SHIFT      23
/** The core sets this bit to indicate a change in port status in Host mode. The
   application must read the Host Port Control and Status (USB_HPRT) register to
   determine the exact event that caused this interrupt. The application must
   clear the appropriate status bit in the Host Port Control and Status register
   to clear this bit. @multiple */
  #define SYNOPSYS_USB_GINTSTS_PRTINT              0x01000000
  #define SYNOPSYS_USB_GINTSTS_PRTINT_SHIFT        24
/** The core sets this bit to indicate that an interrupt is pending on one of the
   channels of the core (in Host mode). The application must read the Host All
   Channels Interrupt (USB_HAINT) register to determine the exact number of the
   channel on which the interrupt occurred, and then read the corresponding Host
   Channel-x Interrupt (USB_HCx_INT) register to determine th @multiple */
  #define SYNOPSYS_USB_GINTSTS_HCHINT              0x02000000
  #define SYNOPSYS_USB_GINTSTS_HCHINT_SHIFT        25
/** This interrupt is asserted when the Periodic Transmit FIFO is either half or
   completely empty and there is space for at least one entry to be written in
   the Periodic Request Queue. The half or completely empty status is determined
   by the Periodic TxFIFO Empty Level bit in the Core AHB Configuration register
   (USB_GAHBCFG.PTXFEMPLVL). @multiple */
  #define SYNOPSYS_USB_GINTSTS_PTXFEMP             0x04000000
  #define SYNOPSYS_USB_GINTSTS_PTXFEMP_SHIFT       26
/** The core sets this bit when there is a change in connector ID status. This
   bit can be set only by the core and the application should write 1 to clear
   it. @multiple */
  #define SYNOPSYS_USB_GINTSTS_CONIDSTSCHNG        0x10000000
  #define SYNOPSYS_USB_GINTSTS_CONIDSTSCHNG_SHIFT  28
/** Asserted when a device disconnect is detected. This bit can be set only by
   the core and the application should write 1 to clear it. @multiple */
  #define SYNOPSYS_USB_GINTSTS_DISCONNINT          0x20000000
  #define SYNOPSYS_USB_GINTSTS_DISCONNINT_SHIFT    29
/** In Host mode, this interrupt is asserted when a session request is detected
   from the device. In Device mode, this interrupt is asserted when the VBUS
   voltage reaches the session-valid level. This bit can be set only by the core
   and the application should write 1 to clear. @multiple */
  #define SYNOPSYS_USB_GINTSTS_SESSREQINT          0x40000000
  #define SYNOPSYS_USB_GINTSTS_SESSREQINT_SHIFT    30
/** Wakeup Interrupt during Suspend state. In Device mode this interrupt is
   asserted only when Host Initiated Resume is detected on USB. In Host mode this
   interrupt is asserted only when Device Initiated Remote Wakeup is detected on
   USB. This bit can be set only by the core and the application should write 1
   to clear. @multiple */
  #define SYNOPSYS_USB_GINTSTS_WKUPINT             0x80000000
  #define SYNOPSYS_USB_GINTSTS_WKUPINT_SHIFT       31

#define SYNOPSYS_USB_GINTMSK_ADDR                    0x00000018
#define SYNOPSYS_USB_GINTMSK_MASK                    0xf7fc7cfe
/** Set to 1 to unmask MODEMISINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_MODEMISMSK          0x00000002
  #define SYNOPSYS_USB_GINTMSK_MODEMISMSK_SHIFT    1
/** Set to 1 to unmask OTGINTINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_OTGINTMSK           0x00000004
  #define SYNOPSYS_USB_GINTMSK_OTGINTMSK_SHIFT     2
/** Set to 1 to unmask SOFINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_SOFMSK              0x00000008
  #define SYNOPSYS_USB_GINTMSK_SOFMSK_SHIFT        3
/** Set to 1 to unmask RXFLVLINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_RXFLVLMSK           0x00000010
  #define SYNOPSYS_USB_GINTMSK_RXFLVLMSK_SHIFT     4
/** Set to 1 to unmask NPTXFEMPINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_NPTXFEMPMSK         0x00000020
  #define SYNOPSYS_USB_GINTMSK_NPTXFEMPMSK_SHIFT   5
/** Set to 1 to unmask GINNAKEFFINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_GINNAKEFFMSK        0x00000040
  #define SYNOPSYS_USB_GINTMSK_GINNAKEFFMSK_SHIFT  6
/** Set to 1 to unmask GOUTNAKEFFMS interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_GOUTNAKEFFMSK       0x00000080
  #define SYNOPSYS_USB_GINTMSK_GOUTNAKEFFMSK_SHIFT 7
/** Set to 1 to unmask ERLYSUSPINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_ERLYSUSPMSK         0x00000400
  #define SYNOPSYS_USB_GINTMSK_ERLYSUSPMSK_SHIFT   10
/** Set to 1 to unmask USBSUSPINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_USBSUSPMSK          0x00000800
  #define SYNOPSYS_USB_GINTMSK_USBSUSPMSK_SHIFT    11
/** Set to 1 to unmask USBRSTINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_USBRSTMSK           0x00001000
  #define SYNOPSYS_USB_GINTMSK_USBRSTMSK_SHIFT     12
/** Set to 1 to unmask ENUMDONEINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_ENUMDONEMSK         0x00002000
  #define SYNOPSYS_USB_GINTMSK_ENUMDONEMSK_SHIFT   13
/** Set to 1 to unmask ISOOUTDROPINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_ISOOUTDROPMSK       0x00004000
  #define SYNOPSYS_USB_GINTMSK_ISOOUTDROPMSK_SHIFT 14
/** Set to 1 to unmask IEPINTINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_IEPINTMSK           0x00040000
  #define SYNOPSYS_USB_GINTMSK_IEPINTMSK_SHIFT     18
/** Set to 1 to unmask OEPINTINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_OEPINTMSK           0x00080000
  #define SYNOPSYS_USB_GINTMSK_OEPINTMSK_SHIFT     19
/** Set to 1 to unmask INCOMPISOININT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_INCOMPISOINMSK      0x00100000
  #define SYNOPSYS_USB_GINTMSK_INCOMPISOINMSK_SHIFT 20
/** Set to 1 to unmask INCOMPLPINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_INCOMPLPMSK         0x00200000
  #define SYNOPSYS_USB_GINTMSK_INCOMPLPMSK_SHIFT   21
/** Set to 1 to unmask FETSUSPINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_FETSUSPMSK          0x00400000
  #define SYNOPSYS_USB_GINTMSK_FETSUSPMSK_SHIFT    22
/** Set to 1 to unmask RESETDETINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_RESETDETMSK         0x00800000
  #define SYNOPSYS_USB_GINTMSK_RESETDETMSK_SHIFT   23
/** Set to 1 to unmask PRTINTINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_PRTINTMSK           0x01000000
  #define SYNOPSYS_USB_GINTMSK_PRTINTMSK_SHIFT     24
/** Set to 1 to unmask HCHINTINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_HCHINTMSK           0x02000000
  #define SYNOPSYS_USB_GINTMSK_HCHINTMSK_SHIFT     25
/** Set to 1 to unmask PTXFEMPINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_PTXFEMPMSK          0x04000000
  #define SYNOPSYS_USB_GINTMSK_PTXFEMPMSK_SHIFT    26
/** Set to 1 to unmask CONIDSTSCHNGINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_CONIDSTSCHNGMSK     0x10000000
  #define SYNOPSYS_USB_GINTMSK_CONIDSTSCHNGMSK_SHIFT 28
/** Set to 1 to unmask DISCONNINTINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_DISCONNINTMSK       0x20000000
  #define SYNOPSYS_USB_GINTMSK_DISCONNINTMSK_SHIFT 29
/** Set to 1 to unmask SESSREQINTINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_SESSREQINTMSK       0x40000000
  #define SYNOPSYS_USB_GINTMSK_SESSREQINTMSK_SHIFT 30
/** Set to 1 to unmask WKUPINTINT interrupt. @multiple */
  #define SYNOPSYS_USB_GINTMSK_WKUPINTMSK          0x80000000
  #define SYNOPSYS_USB_GINTMSK_WKUPINTMSK_SHIFT    31

#define SYNOPSYS_USB_GRXSTSR_ADDR                    0x0000001c
#define SYNOPSYS_USB_GRXSTSR_MASK                    0x0f1fffff
/** Host mode: Indicates the channel number to which the current received packet
   belongs. Device mode: Indicates the endpoint number to which the current
   received packet belongs. @multiple */
  #define SYNOPSYS_USB_GRXSTSR_CHEPNUM             0x0000000f
  #define SYNOPSYS_USB_GRXSTSR_CHEPNUM_SHIFT       0
  #define SYNOPSYS_USB_GRXSTSR_CHEPNUM_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_GRXSTSR_CHEPNUM_SET(x, v)   do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_GRXSTSR_CHEPNUM_GET(x)      (((x) >> 0) & 0xf)
/** Host mode: Indicates the byte count of the received IN data packet. Device
   mode: Indicates the byte count of the received data packet. @multiple */
  #define SYNOPSYS_USB_GRXSTSR_BCNT                0x00007ff0
  #define SYNOPSYS_USB_GRXSTSR_BCNT_SHIFT          4
  #define SYNOPSYS_USB_GRXSTSR_BCNT_SHIFT_VAL(v)   ((v) << 4)
  #define SYNOPSYS_USB_GRXSTSR_BCNT_SET(x, v)      do { (x) = (((x) & ~0x7ff0) | ((v) << 4)); } while(0)
  #define SYNOPSYS_USB_GRXSTSR_BCNT_GET(x)         (((x) >> 4) & 0x7ff)
/** Host mode: Indicates the Data PID of the received packet. Device mode:
   Indicates the Data PID of the received OUT data packet. @multiple */
  #define SYNOPSYS_USB_GRXSTSR_DPID                0x00018000
  #define SYNOPSYS_USB_GRXSTSR_DPID_SHIFT          15
  #define SYNOPSYS_USB_GRXSTSR_DPID_SHIFT_VAL(v)   ((SYNOPSYS_USB_GRXSTSR_DPID_##v) << 15)
  #define SYNOPSYS_USB_GRXSTSR_DPID_SET(x, v)      do { (x) = (((x) & ~0x18000) | ((SYNOPSYS_USB_GRXSTSR_DPID_##v) << 15)); } while(0)
  #define SYNOPSYS_USB_GRXSTSR_DPID_SETVAL(x, v)   do { (x) = (((x) & ~0x18000) | ((v) << 15)); } while(0)
  #define SYNOPSYS_USB_GRXSTSR_DPID_GET(x)         (((x) >> 15) & 0x3)
    #define SYNOPSYS_USB_GRXSTSR_DPID_DATA0          0x00000000
    #define SYNOPSYS_USB_GRXSTSR_DPID_DATA1          0x00000001
    #define SYNOPSYS_USB_GRXSTSR_DPID_DATA2          0x00000002
    #define SYNOPSYS_USB_GRXSTSR_DPID_MDATA          0x00000003
/** Indicates the status of the received packet. @multiple */
  #define SYNOPSYS_USB_GRXSTSR_PKTSTS              0x001e0000
  #define SYNOPSYS_USB_GRXSTSR_PKTSTS_SHIFT        17
  #define SYNOPSYS_USB_GRXSTSR_PKTSTS_SHIFT_VAL(v) ((SYNOPSYS_USB_GRXSTSR_PKTSTS_##v) << 17)
  #define SYNOPSYS_USB_GRXSTSR_PKTSTS_SET(x, v)    do { (x) = (((x) & ~0x1e0000) | ((SYNOPSYS_USB_GRXSTSR_PKTSTS_##v) << 17)); } while(0)
  #define SYNOPSYS_USB_GRXSTSR_PKTSTS_SETVAL(x, v) do { (x) = (((x) & ~0x1e0000) | ((v) << 17)); } while(0)
  #define SYNOPSYS_USB_GRXSTSR_PKTSTS_GET(x)       (((x) >> 17) & 0xf)
    #define SYNOPSYS_USB_GRXSTSR_PKTSTS_GOUTNAK      0x00000001
    #define SYNOPSYS_USB_GRXSTSR_PKTSTS_PKTRCV       0x00000002
    #define SYNOPSYS_USB_GRXSTSR_PKTSTS_XFERCOMPL    0x00000003
    #define SYNOPSYS_USB_GRXSTSR_PKTSTS_SETUPCOMPL   0x00000004
    #define SYNOPSYS_USB_GRXSTSR_PKTSTS_TGLERR       0x00000005
    #define SYNOPSYS_USB_GRXSTSR_PKTSTS_SETUPRCV     0x00000006
    #define SYNOPSYS_USB_GRXSTSR_PKTSTS_CHLT         0x00000007
/** This is the least significant 4 bits of the Frame number in which the packet
   is received on the USB. @multiple */
  #define SYNOPSYS_USB_GRXSTSR_FN                  0x0f000000
  #define SYNOPSYS_USB_GRXSTSR_FN_SHIFT            24
  #define SYNOPSYS_USB_GRXSTSR_FN_SHIFT_VAL(v)     ((v) << 24)
  #define SYNOPSYS_USB_GRXSTSR_FN_SET(x, v)        do { (x) = (((x) & ~0xf000000) | ((v) << 24)); } while(0)
  #define SYNOPSYS_USB_GRXSTSR_FN_GET(x)           (((x) >> 24) & 0xf)

#define SYNOPSYS_USB_GRXSTSP_ADDR                    0x00000020
#define SYNOPSYS_USB_GRXSTSP_MASK                    0x01ffffff
/** Host mode: Indicates the channel number to which the current received packet
   belongs. Device mode: Indicates the endpoint number to which the current
   received packet belongs. @multiple */
  #define SYNOPSYS_USB_GRXSTSP_CHEPNUM             0x0000000f
  #define SYNOPSYS_USB_GRXSTSP_CHEPNUM_SHIFT       0
  #define SYNOPSYS_USB_GRXSTSP_CHEPNUM_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_GRXSTSP_CHEPNUM_SET(x, v)   do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_GRXSTSP_CHEPNUM_GET(x)      (((x) >> 0) & 0xf)
/** Host mode: Indicates the byte count of the received IN data packet. Device
   mode: Indicates the byte count of the received data packet. @multiple */
  #define SYNOPSYS_USB_GRXSTSP_BCNT                0x00007ff0
  #define SYNOPSYS_USB_GRXSTSP_BCNT_SHIFT          4
  #define SYNOPSYS_USB_GRXSTSP_BCNT_SHIFT_VAL(v)   ((v) << 4)
  #define SYNOPSYS_USB_GRXSTSP_BCNT_SET(x, v)      do { (x) = (((x) & ~0x7ff0) | ((v) << 4)); } while(0)
  #define SYNOPSYS_USB_GRXSTSP_BCNT_GET(x)         (((x) >> 4) & 0x7ff)
/** Host mode: Indicates the Data PID of the received packet. Device mode:
   Indicates the Data PID of the received OUT data packet. @multiple */
  #define SYNOPSYS_USB_GRXSTSP_DPID                0x00018000
  #define SYNOPSYS_USB_GRXSTSP_DPID_SHIFT          15
  #define SYNOPSYS_USB_GRXSTSP_DPID_SHIFT_VAL(v)   ((SYNOPSYS_USB_GRXSTSP_DPID_##v) << 15)
  #define SYNOPSYS_USB_GRXSTSP_DPID_SET(x, v)      do { (x) = (((x) & ~0x18000) | ((SYNOPSYS_USB_GRXSTSP_DPID_##v) << 15)); } while(0)
  #define SYNOPSYS_USB_GRXSTSP_DPID_SETVAL(x, v)   do { (x) = (((x) & ~0x18000) | ((v) << 15)); } while(0)
  #define SYNOPSYS_USB_GRXSTSP_DPID_GET(x)         (((x) >> 15) & 0x3)
    #define SYNOPSYS_USB_GRXSTSP_DPID_DATA0          0x00000000
    #define SYNOPSYS_USB_GRXSTSP_DPID_DATA1          0x00000001
    #define SYNOPSYS_USB_GRXSTSP_DPID_DATA2          0x00000002
    #define SYNOPSYS_USB_GRXSTSP_DPID_MDATA          0x00000003
/** Indicates the status of the received packet. @multiple */
  #define SYNOPSYS_USB_GRXSTSP_PKTSTS              0x001e0000
  #define SYNOPSYS_USB_GRXSTSP_PKTSTS_SHIFT        17
  #define SYNOPSYS_USB_GRXSTSP_PKTSTS_SHIFT_VAL(v) ((SYNOPSYS_USB_GRXSTSP_PKTSTS_##v) << 17)
  #define SYNOPSYS_USB_GRXSTSP_PKTSTS_SET(x, v)    do { (x) = (((x) & ~0x1e0000) | ((SYNOPSYS_USB_GRXSTSP_PKTSTS_##v) << 17)); } while(0)
  #define SYNOPSYS_USB_GRXSTSP_PKTSTS_SETVAL(x, v) do { (x) = (((x) & ~0x1e0000) | ((v) << 17)); } while(0)
  #define SYNOPSYS_USB_GRXSTSP_PKTSTS_GET(x)       (((x) >> 17) & 0xf)
    #define SYNOPSYS_USB_GRXSTSP_PKTSTS_GOUTNAK      0x00000001
    #define SYNOPSYS_USB_GRXSTSP_PKTSTS_PKTRCV       0x00000002
    #define SYNOPSYS_USB_GRXSTSP_PKTSTS_XFERCOMPL    0x00000003
    #define SYNOPSYS_USB_GRXSTSP_PKTSTS_SETUPCOMPL   0x00000004
    #define SYNOPSYS_USB_GRXSTSP_PKTSTS_TGLERR       0x00000005
    #define SYNOPSYS_USB_GRXSTSP_PKTSTS_SETUPRCV     0x00000006
    #define SYNOPSYS_USB_GRXSTSP_PKTSTS_CHLT         0x00000007
/** This is the least significant 4 bits of the Frame number in which the packet
   is received on the USB. @multiple */
  #define SYNOPSYS_USB_GRXSTSP_FN                  0x01e00000
  #define SYNOPSYS_USB_GRXSTSP_FN_SHIFT            21
  #define SYNOPSYS_USB_GRXSTSP_FN_SHIFT_VAL(v)     ((v) << 21)
  #define SYNOPSYS_USB_GRXSTSP_FN_SET(x, v)        do { (x) = (((x) & ~0x1e00000) | ((v) << 21)); } while(0)
  #define SYNOPSYS_USB_GRXSTSP_FN_GET(x)           (((x) >> 21) & 0xf)

#define SYNOPSYS_USB_GRXFSIZE_ADDR                   0x00000024
#define SYNOPSYS_USB_GRXFSIZE_MASK                   0x000003ff
/** This value is in terms of 32-bit words. Minimum value is 16. Maximum value is
   512. @multiple */
  #define SYNOPSYS_USB_GRXFSIZE_CHEPNUM            0x000003ff
  #define SYNOPSYS_USB_GRXFSIZE_CHEPNUM_SHIFT      0
  #define SYNOPSYS_USB_GRXFSIZE_CHEPNUM_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_GRXFSIZE_CHEPNUM_SET(x, v)  do { (x) = (((x) & ~0x3ff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_GRXFSIZE_CHEPNUM_GET(x)     (((x) >> 0) & 0x3ff)

#define SYNOPSYS_USB_GNPTXFSIZE_ADDR                 0x00000028
#define SYNOPSYS_USB_GNPTXFSIZE_MASK                 0xffff03ff
/** This field contains the memory start address for Non-periodic Transmit FIFO
   RAM. Programmed values must not exceed the reset value. @multiple */
  #define SYNOPSYS_USB_GNPTXFSIZE_NPTXFSTADDR      0x000003ff
  #define SYNOPSYS_USB_GNPTXFSIZE_NPTXFSTADDR_SHIFT 0
  #define SYNOPSYS_USB_GNPTXFSIZE_NPTXFSTADDR_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_GNPTXFSIZE_NPTXFSTADDR_SET(x, v) do { (x) = (((x) & ~0x3ff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_GNPTXFSIZE_NPTXFSTADDR_GET(x) (((x) >> 0) & 0x3ff)
/** This value is in terms of 32-bit words. Minimum value is 16. Maximum value is
   512. @multiple */
  #define SYNOPSYS_USB_GNPTXFSIZE_NPTXFINEPTXF0DEP 0xffff0000
  #define SYNOPSYS_USB_GNPTXFSIZE_NPTXFINEPTXF0DEP_SHIFT 16
  #define SYNOPSYS_USB_GNPTXFSIZE_NPTXFINEPTXF0DEP_SHIFT_VAL(v) ((v) << 16)
  #define SYNOPSYS_USB_GNPTXFSIZE_NPTXFINEPTXF0DEP_SET(x, v) do { (x) = (((x) & ~0xffff0000) | ((v) << 16)); } while(0)
  #define SYNOPSYS_USB_GNPTXFSIZE_NPTXFINEPTXF0DEP_GET(x) (((x) >> 16) & 0xffff)

#define SYNOPSYS_USB_GNPTXSTS_ADDR                   0x0000002c
#define SYNOPSYS_USB_GNPTXSTS_MASK                   0x7fffffff
/** Indicates the amount of free space available in the Non-periodic TxFIFO.
   Values are in terms of 32-bit words. @multiple */
  #define SYNOPSYS_USB_GNPTXSTS_NPTXFSPCAVAIL      0x0000ffff
  #define SYNOPSYS_USB_GNPTXSTS_NPTXFSPCAVAIL_SHIFT 0
  #define SYNOPSYS_USB_GNPTXSTS_NPTXFSPCAVAIL_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_GNPTXSTS_NPTXFSPCAVAIL_SET(x, v) do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_GNPTXSTS_NPTXFSPCAVAIL_GET(x) (((x) >> 0) & 0xffff)
/** ndicates the amount of free space (locations) available in the Non-periodic
   Transmit Request Queue. This queue holds both IN and OUT requests in Host
   mode. Device mode has only IN requests. @multiple */
  #define SYNOPSYS_USB_GNPTXSTS_NPTXQSPCAVAIL      0x00ff0000
  #define SYNOPSYS_USB_GNPTXSTS_NPTXQSPCAVAIL_SHIFT 16
  #define SYNOPSYS_USB_GNPTXSTS_NPTXQSPCAVAIL_SHIFT_VAL(v) ((v) << 16)
  #define SYNOPSYS_USB_GNPTXSTS_NPTXQSPCAVAIL_SET(x, v) do { (x) = (((x) & ~0xff0000) | ((v) << 16)); } while(0)
  #define SYNOPSYS_USB_GNPTXSTS_NPTXQSPCAVAIL_GET(x) (((x) >> 16) & 0xff)
/** Entry in the Non-periodic Tx Request Queue that is currently being processed
   by the MAC. Bits [6:3]: Channel/endpoint number. Bits [2:1]: 00: IN/OUT token,
   01: Zero-length transmit packet (device IN/host OUT), 10: Unused, 11: Channel
   halt command. Bit [0]: Terminate (last Entry for selected channel/endpoint).
   @multiple */
  #define SYNOPSYS_USB_GNPTXSTS_NPTXQTOP           0x7f000000
  #define SYNOPSYS_USB_GNPTXSTS_NPTXQTOP_SHIFT     24
  #define SYNOPSYS_USB_GNPTXSTS_NPTXQTOP_SHIFT_VAL(v) ((v) << 24)
  #define SYNOPSYS_USB_GNPTXSTS_NPTXQTOP_SET(x, v) do { (x) = (((x) & ~0x7f000000) | ((v) << 24)); } while(0)
  #define SYNOPSYS_USB_GNPTXSTS_NPTXQTOP_GET(x)    (((x) >> 24) & 0x7f)

#define SYNOPSYS_USB_GDFIFOCFG_ADDR                  0x0000005c
#define SYNOPSYS_USB_GDFIFOCFG_MASK                  0xffffffff
/** This field is for dynamic programming of the DFIFO Size. This value takes
   effect only when the application programs a non zero value to this register.
   The core does not have any corrective logic if the FIFO sizes are programmed
   incorrectly. @multiple */
  #define SYNOPSYS_USB_GDFIFOCFG_GDFIFOCFG         0x0000ffff
  #define SYNOPSYS_USB_GDFIFOCFG_GDFIFOCFG_SHIFT   0
  #define SYNOPSYS_USB_GDFIFOCFG_GDFIFOCFG_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_GDFIFOCFG_GDFIFOCFG_SET(x, v) do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_GDFIFOCFG_GDFIFOCFG_GET(x)  (((x) >> 0) & 0xffff)
/** This field provides the start address of the EP info controller. @multiple */
  #define SYNOPSYS_USB_GDFIFOCFG_EPINFOBASEADDR    0xffff0000
  #define SYNOPSYS_USB_GDFIFOCFG_EPINFOBASEADDR_SHIFT 16
  #define SYNOPSYS_USB_GDFIFOCFG_EPINFOBASEADDR_SHIFT_VAL(v) ((v) << 16)
  #define SYNOPSYS_USB_GDFIFOCFG_EPINFOBASEADDR_SET(x, v) do { (x) = (((x) & ~0xffff0000) | ((v) << 16)); } while(0)
  #define SYNOPSYS_USB_GDFIFOCFG_EPINFOBASEADDR_GET(x) (((x) >> 16) & 0xffff)

#define SYNOPSYS_USB_HPTXFSIZE_ADDR                  0x00000100
#define SYNOPSYS_USB_HPTXFSIZE_MASK                  0x03ff07ff
/** This field contains the memory start address for Host Periodic TxFIFO.
   @multiple */
  #define SYNOPSYS_USB_HPTXFSIZE_GDFIFOCFG         0x000007ff
  #define SYNOPSYS_USB_HPTXFSIZE_GDFIFOCFG_SHIFT   0
  #define SYNOPSYS_USB_HPTXFSIZE_GDFIFOCFG_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_HPTXFSIZE_GDFIFOCFG_SET(x, v) do { (x) = (((x) & ~0x7ff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_HPTXFSIZE_GDFIFOCFG_GET(x)  (((x) >> 0) & 0x7ff)
/** This value is in terms of 32-bit words. Minimum value is 16. Maximum value is
   512. @multiple */
  #define SYNOPSYS_USB_HPTXFSIZE_PTXFSIZE          0x03ff0000
  #define SYNOPSYS_USB_HPTXFSIZE_PTXFSIZE_SHIFT    16
  #define SYNOPSYS_USB_HPTXFSIZE_PTXFSIZE_SHIFT_VAL(v) ((v) << 16)
  #define SYNOPSYS_USB_HPTXFSIZE_PTXFSIZE_SET(x, v) do { (x) = (((x) & ~0x3ff0000) | ((v) << 16)); } while(0)
  #define SYNOPSYS_USB_HPTXFSIZE_PTXFSIZE_GET(x)   (((x) >> 16) & 0x3ff)

#define SYNOPSYS_USB_DIEPTXF_ADDR(ridx)              (0x00000104 + (ridx) * 4)
#define SYNOPSYS_USB_DIEPTXF_COUNT                   6
#define SYNOPSYS_USB_DIEPTXF_MASK                    0x03ff07ff
/** This field contains the memory start address for IN endpoint Transmit FIFO.
   @multiple */
  #define SYNOPSYS_USB_DIEPTXF_INEPNTXFSTADDR      0x000007ff
  #define SYNOPSYS_USB_DIEPTXF_INEPNTXFSTADDR_SHIFT 0
  #define SYNOPSYS_USB_DIEPTXF_INEPNTXFSTADDR_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_DIEPTXF_INEPNTXFSTADDR_SET(x, v) do { (x) = (((x) & ~0x7ff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_DIEPTXF_INEPNTXFSTADDR_GET(x) (((x) >> 0) & 0x7ff)
/** This value is in terms of 32-bit words. Minimum value is 16. Maximum value is
   512. @multiple */
  #define SYNOPSYS_USB_DIEPTXF_INEPNTXFDEP         0x03ff0000
  #define SYNOPSYS_USB_DIEPTXF_INEPNTXFDEP_SHIFT   16
  #define SYNOPSYS_USB_DIEPTXF_INEPNTXFDEP_SHIFT_VAL(v) ((v) << 16)
  #define SYNOPSYS_USB_DIEPTXF_INEPNTXFDEP_SET(x, v) do { (x) = (((x) & ~0x3ff0000) | ((v) << 16)); } while(0)
  #define SYNOPSYS_USB_DIEPTXF_INEPNTXFDEP_GET(x)  (((x) >> 16) & 0x3ff)

#define SYNOPSYS_USB_HCFG_ADDR                       0x00000400
#define SYNOPSYS_USB_HCFG_MASK                       0x8000ff87
/** Use this field to set the internal PHY clock frequency. Set to 48 MHz in FS
   Host mode and 6 MHz in LS Host mode. When you select a 6 MHz clock during LS
   mode, you must do a soft reset. @multiple */
  #define SYNOPSYS_USB_HCFG_FSLSPCLKSEL            0x00000003
  #define SYNOPSYS_USB_HCFG_FSLSPCLKSEL_SHIFT      0
  #define SYNOPSYS_USB_HCFG_FSLSPCLKSEL_SHIFT_VAL(v) ((SYNOPSYS_USB_HCFG_FSLSPCLKSEL_##v) << 0)
  #define SYNOPSYS_USB_HCFG_FSLSPCLKSEL_SET(x, v)  do { (x) = (((x) & ~0x3) | ((SYNOPSYS_USB_HCFG_FSLSPCLKSEL_##v) << 0)); } while(0)
  #define SYNOPSYS_USB_HCFG_FSLSPCLKSEL_SETVAL(x, v) do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_HCFG_FSLSPCLKSEL_GET(x)     (((x) >> 0) & 0x3)
    #define SYNOPSYS_USB_HCFG_FSLSPCLKSEL_DIV1       0x00000001
    #define SYNOPSYS_USB_HCFG_FSLSPCLKSEL_DIV8       0x00000002
/** The application uses this bit to control the core's enumeration speed. Using
   this bit, the application can make the core enumerate as a FS host, even If
   the connected device supports HS traffic. Do not make changes to this field
   after initial programming. @multiple */
  #define SYNOPSYS_USB_HCFG_FSLSSUPP               0x00000004
  #define SYNOPSYS_USB_HCFG_FSLSSUPP_SHIFT         2
/** When this bit is set the core expects that the clock to the core during
   Suspend is switched from 48 MHz to 32 KHz. @multiple */
  #define SYNOPSYS_USB_HCFG_ENA32KHZS              0x00000080
  #define SYNOPSYS_USB_HCFG_ENA32KHZS_SHIFT        7
/** This field is effective only when USB_HCFG.ENA32KHZS is set. It will control
   the resume period when the core resumes from suspend. The core counts for
   RESVALID number of clock cycles to detect a valid resume when
   USB_HCFG.ENA32KHZS is set. @multiple */
  #define SYNOPSYS_USB_HCFG_RESVALID               0x0000ff00
  #define SYNOPSYS_USB_HCFG_RESVALID_SHIFT         8
  #define SYNOPSYS_USB_HCFG_RESVALID_SHIFT_VAL(v)  ((v) << 8)
  #define SYNOPSYS_USB_HCFG_RESVALID_SET(x, v)     do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define SYNOPSYS_USB_HCFG_RESVALID_GET(x)        (((x) >> 8) & 0xff)
/** This bit is used to enable/disable the Host core to wait 200 clock cycles at
   the end of Resume before changing the PHY opmode to normal operation. When set
   to 0 the Host core waits for either 200 PHY clock cycles or a linestate of SE0
   at the end of resume to the change the PHY opmode to noxmal operation. When
   set to 1 the Host core waits only for a linstate of SE0 at the end of resume
   to change the PHY opmode to normal operation. @multiple */
  #define SYNOPSYS_USB_HCFG_MODECHTIMEN            0x80000000
  #define SYNOPSYS_USB_HCFG_MODECHTIMEN_SHIFT      31

#define SYNOPSYS_USB_HFIR_ADDR                       0x00000404
#define SYNOPSYS_USB_HFIR_MASK                       0x0001ffff
/** The value that the application programs to this field specifies the interval
   between two consecutive SOFs (FS) or Keep-Alive tokens (LS). This field
   contains the number of PHY clocks that constitute the required frame interval.
   The application can write a value to this register only after the Port Enable
   bit of the Host Port Control and Status register (USB_HPRT.PRTENA) has been
   set. If no value is programmed, the core calculates the value based on the PHY
   clock specified in the FS/LS PHY Clock Select field of the Host Configuration
   register (USB_HCFG.FSLSPCLKSEL). Do not change the value of this field after
   the initial configuration. Set to 48000 (1 ms at 48 MHz) for FS and 6000 (1 ms
   at 6 MHz) for LS. @multiple */
  #define SYNOPSYS_USB_HFIR_FRINT                  0x0000ffff
  #define SYNOPSYS_USB_HFIR_FRINT_SHIFT            0
  #define SYNOPSYS_USB_HFIR_FRINT_SHIFT_VAL(v)     ((v) << 0)
  #define SYNOPSYS_USB_HFIR_FRINT_SET(x, v)        do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_HFIR_FRINT_GET(x)           (((x) >> 0) & 0xffff)
/** This bit allows dynamic reloading of the HFIR register during run time. This
   bit needs to be programmed during initial configuration and its value should
   not be changed during runtime. @multiple */
  #define SYNOPSYS_USB_HFIR_HFIRRLDCTRL            0x00010000
  #define SYNOPSYS_USB_HFIR_HFIRRLDCTRL_SHIFT      16

#define SYNOPSYS_USB_HFNUM_ADDR                      0x00000408
#define SYNOPSYS_USB_HFNUM_MASK                      0xffffffff
/** This field increments when a new SOF is transmitted on the USB, and is reset
   to 0 when it reaches 0x3FFF. @multiple */
  #define SYNOPSYS_USB_HFNUM_FRNUM                 0x0000ffff
  #define SYNOPSYS_USB_HFNUM_FRNUM_SHIFT           0
  #define SYNOPSYS_USB_HFNUM_FRNUM_SHIFT_VAL(v)    ((v) << 0)
  #define SYNOPSYS_USB_HFNUM_FRNUM_SET(x, v)       do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_HFNUM_FRNUM_GET(x)          (((x) >> 0) & 0xffff)
/** indicates the amount of time remaining in the current Frame, in terms of PHY
   clocks. This field decrements on each PHY clock. When it reaches zero, this
   field is reloaded with the value in the Frame Interval register and a new SOF
   is transmitted on the USB. @multiple */
  #define SYNOPSYS_USB_HFNUM_FRREM                 0xffff0000
  #define SYNOPSYS_USB_HFNUM_FRREM_SHIFT           16
  #define SYNOPSYS_USB_HFNUM_FRREM_SHIFT_VAL(v)    ((v) << 16)
  #define SYNOPSYS_USB_HFNUM_FRREM_SET(x, v)       do { (x) = (((x) & ~0xffff0000) | ((v) << 16)); } while(0)
  #define SYNOPSYS_USB_HFNUM_FRREM_GET(x)          (((x) >> 16) & 0xffff)

#define SYNOPSYS_USB_HFPTXSTS_ADDR                   0x00000410
#define SYNOPSYS_USB_HFPTXSTS_MASK                   0xffffffff
/** Indicates the number of free locations available to be written to in the
   Periodic TxFIFO. Values are in terms of 32-bit words. @multiple */
  #define SYNOPSYS_USB_HFPTXSTS_PTXFSPCAVAIL       0x0000ffff
  #define SYNOPSYS_USB_HFPTXSTS_PTXFSPCAVAIL_SHIFT 0
  #define SYNOPSYS_USB_HFPTXSTS_PTXFSPCAVAIL_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_HFPTXSTS_PTXFSPCAVAIL_SET(x, v) do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_HFPTXSTS_PTXFSPCAVAIL_GET(x) (((x) >> 0) & 0xffff)
/** Indicates the number of free locations available to be written in the
   Periodic Transmit Request Queue. This queue holds both IN and OUT requests.
   @multiple */
  #define SYNOPSYS_USB_HFPTXSTS_PTXQSPCAVAIL       0x00ff0000
  #define SYNOPSYS_USB_HFPTXSTS_PTXQSPCAVAIL_SHIFT 16
  #define SYNOPSYS_USB_HFPTXSTS_PTXQSPCAVAIL_SHIFT_VAL(v) ((v) << 16)
  #define SYNOPSYS_USB_HFPTXSTS_PTXQSPCAVAIL_SET(x, v) do { (x) = (((x) & ~0xff0000) | ((v) << 16)); } while(0)
  #define SYNOPSYS_USB_HFPTXSTS_PTXQSPCAVAIL_GET(x) (((x) >> 16) & 0xff)
/** This indicates the Entry in the Periodic Tx Request Queue that is currently
   being processes by the MAC. This register is used for debugging. Bit [7]:
   Odd/Even Frame. 0: send in even Frame, 1: send in odd Frame. Bits [6:3]:
   Channel/endpoint number. Bits [2:1]: Type. 00: IN/OUT, 01: Zero-length packet,
   10: Unused, 11: Disable channel command. Bit [0]: Terminate (last Entry for
   the selected channel/endpoint). @multiple */
  #define SYNOPSYS_USB_HFPTXSTS_PTXQTOP            0xff000000
  #define SYNOPSYS_USB_HFPTXSTS_PTXQTOP_SHIFT      24
  #define SYNOPSYS_USB_HFPTXSTS_PTXQTOP_SHIFT_VAL(v) ((v) << 24)
  #define SYNOPSYS_USB_HFPTXSTS_PTXQTOP_SET(x, v)  do { (x) = (((x) & ~0xff000000) | ((v) << 24)); } while(0)
  #define SYNOPSYS_USB_HFPTXSTS_PTXQTOP_GET(x)     (((x) >> 24) & 0xff)

#define SYNOPSYS_USB_HAINT_ADDR                      0x00000414
#define SYNOPSYS_USB_HAINT_MASK                      0x00003fff
/** When the interrupt bit for a channel x set, one or more of the interrupt
   flags in the USB_HCx_INT are set. @multiple */
  #define SYNOPSYS_USB_HAINT_HAINT                 0x00003fff
  #define SYNOPSYS_USB_HAINT_HAINT_SHIFT           0
  #define SYNOPSYS_USB_HAINT_HAINT_SHIFT_VAL(v)    ((v) << 0)
  #define SYNOPSYS_USB_HAINT_HAINT_SET(x, v)       do { (x) = (((x) & ~0x3fff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_HAINT_HAINT_GET(x)          (((x) >> 0) & 0x3fff)

#define SYNOPSYS_USB_HAINTMSK_ADDR                   0x00000418
#define SYNOPSYS_USB_HAINTMSK_MASK                   0x00003fff
/** Set bit n to unmask channel n interrupts. @multiple */
  #define SYNOPSYS_USB_HAINTMSK_HAINTMSK           0x00003fff
  #define SYNOPSYS_USB_HAINTMSK_HAINTMSK_SHIFT     0
  #define SYNOPSYS_USB_HAINTMSK_HAINTMSK_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_HAINTMSK_HAINTMSK_SET(x, v) do { (x) = (((x) & ~0x3fff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_HAINTMSK_HAINTMSK_GET(x)    (((x) >> 0) & 0x3fff)

#define SYNOPSYS_USB_HPRT_ADDR                       0x00000440
#define SYNOPSYS_USB_HPRT_MASK                       0x0007fdff
/** When this bit is 1 a device is attached to the port. @multiple */
  #define SYNOPSYS_USB_HPRT_PRTCONNSTS             0x00000001
  #define SYNOPSYS_USB_HPRT_PRTCONNSTS_SHIFT       0
/** The core sets this bit when a device connection is detected to trigger an
   interrupt to the application using the Host Port Interrupt bit of the Core
   Interrupt register (USB_GINTSTS.PRTINT). This bit can be set only by the core
   and the application should write 1 to clear it.The application must write a 1
   to this bit to clear the interrupt. @multiple */
  #define SYNOPSYS_USB_HPRT_PRTCONNDET             0x00000002
  #define SYNOPSYS_USB_HPRT_PRTCONNDET_SHIFT       1
/** A port is enabled only by the core after a reset sequence, and is disabled by
   an overcurrent condition, a disconnect condition, or by the application
   clearing this bit. The application cannot set this bit by a register write. It
   can only clear it to disable the port by writing 1. This bit does not trigger
   any interrupt to the application. @multiple */
  #define SYNOPSYS_USB_HPRT_PRTENA                 0x00000004
  #define SYNOPSYS_USB_HPRT_PRTENA_SHIFT           2
/** The core sets this bit when the status of the Port Enable bit[2] of this
   register changes. This bit can be set only by the core and the application
   should write 1 to clear it. @multiple */
  #define SYNOPSYS_USB_HPRT_PRTENCHNG              0x00000008
  #define SYNOPSYS_USB_HPRT_PRTENCHNG_SHIFT        3
/** Indicates the overcurrent condition of the port. When there is an overcurrent
   condition this bit is 1. @multiple */
  #define SYNOPSYS_USB_HPRT_PRTOVRCURRACT          0x00000010
  #define SYNOPSYS_USB_HPRT_PRTOVRCURRACT_SHIFT    4
/** The core sets this bit when the status of the Port Overcurrent Active bit
   (bit 4) in this register changes. This bit can be set only by the core and the
   application should write 1 to clear it. @multiple */
  #define SYNOPSYS_USB_HPRT_PRTOVRCURRCHNG         0x00000020
  #define SYNOPSYS_USB_HPRT_PRTOVRCURRCHNG_SHIFT   5
/** The application sets this bit to drive resume signaling on the port. The core
   continues to drive the resume signal until the application clears this bit. If
   the core detects a USB remote wakeup sequence, as indicated by the Port
   Resume/Remote Wakeup Detected Interrupt bit of the Core Interrupt register
   (USB_GINTSTS.WKUPINT), the core starts driving resume signaling without
   application intervention and clears this bit when it detects a disconnect
   condition. The read value of this bit indicates whether the core is currently
   driving resume signaling. @multiple */
  #define SYNOPSYS_USB_HPRT_PRTRES                 0x00000040
  #define SYNOPSYS_USB_HPRT_PRTRES_SHIFT           6
/** The application sets this bit to put this port in Suspend mode. The core only
   stops sending SOFs when this is set. To stop the PHY clock, the application
   must set USB_PCGCCTL.STOPPCLK, which puts the PHY into suspend mode. The read
   value of this bit reflects the current suspend status of the port. This bit is
   cleared by the core after a remote wakeup signal is detected or the
   application sets the Port Reset bit or Port Resume bit in this register or the
   Resume/Remote Wakeup Detected Interrupt bit or Disconnect Detected Interrupt
   bit in the Core Interrupt register (USB_GINTSTS.WKUPINT or
   USB_GINTSTS.DISCONNINT respectively). This bit is cleared by the core even if
   there is no device connected to the Host. @multiple */
  #define SYNOPSYS_USB_HPRT_PRTSUSP                0x00000080
  #define SYNOPSYS_USB_HPRT_PRTSUSP_SHIFT          7
/** When the application sets this bit, a reset sequence is started on this port.
   The application must time the reset period and clear this bit after the reset
   sequence is complete. The application must leave this bit set for at least 10
   ms to start a reset on the port. The application can leave it set for another
   10 ms in addition to the required minimum duration, before clearing the bit,
   even though there is no maximum limit set by the USB standard. @multiple */
  #define SYNOPSYS_USB_HPRT_PRTRST                 0x00000100
  #define SYNOPSYS_USB_HPRT_PRTRST_SHIFT           8
/** Indicates the current logic level USB data lines. Bit [0]: Logic level of D+.
   Bit [1]: Logic level of D-. @multiple */
  #define SYNOPSYS_USB_HPRT_PRTLNSTS               0x00000c00
  #define SYNOPSYS_USB_HPRT_PRTLNSTS_SHIFT         10
  #define SYNOPSYS_USB_HPRT_PRTLNSTS_SHIFT_VAL(v)  ((v) << 10)
  #define SYNOPSYS_USB_HPRT_PRTLNSTS_SET(x, v)     do { (x) = (((x) & ~0xc00) | ((v) << 10)); } while(0)
  #define SYNOPSYS_USB_HPRT_PRTLNSTS_GET(x)        (((x) >> 10) & 0x3)
/** The application uses this field to control power to this port. The core can
   clear this bit on an over current condition. @multiple */
  #define SYNOPSYS_USB_HPRT_PRTPWR                 0x00001000
  #define SYNOPSYS_USB_HPRT_PRTPWR_SHIFT           12
  #define SYNOPSYS_USB_HPRT_PRTPWR_SHIFT_VAL(v)    ((SYNOPSYS_USB_HPRT_PRTPWR_##v) << 12)
  #define SYNOPSYS_USB_HPRT_PRTPWR_SET(x, v)       do { (x) = (((x) & ~0x1000) | ((SYNOPSYS_USB_HPRT_PRTPWR_##v) << 12)); } while(0)
  #define SYNOPSYS_USB_HPRT_PRTPWR_SETVAL(x, v)    do { (x) = (((x) & ~0x1000) | ((v) << 12)); } while(0)
  #define SYNOPSYS_USB_HPRT_PRTPWR_GET(x)          (((x) >> 12) & 0x1)
    #define SYNOPSYS_USB_HPRT_PRTPWR_OFF             0x00000000
    #define SYNOPSYS_USB_HPRT_PRTPWR_ON              0x00000001
/** The application writes a nonzero value to this field to put the port into a
   Test mode, and the corresponding pattern is signaled on the port. @multiple */
  #define SYNOPSYS_USB_HPRT_PRTTSTCTL              0x0001e000
  #define SYNOPSYS_USB_HPRT_PRTTSTCTL_SHIFT        13
  #define SYNOPSYS_USB_HPRT_PRTTSTCTL_SHIFT_VAL(v) ((SYNOPSYS_USB_HPRT_PRTTSTCTL_##v) << 13)
  #define SYNOPSYS_USB_HPRT_PRTTSTCTL_SET(x, v)    do { (x) = (((x) & ~0x1e000) | ((SYNOPSYS_USB_HPRT_PRTTSTCTL_##v) << 13)); } while(0)
  #define SYNOPSYS_USB_HPRT_PRTTSTCTL_SETVAL(x, v) do { (x) = (((x) & ~0x1e000) | ((v) << 13)); } while(0)
  #define SYNOPSYS_USB_HPRT_PRTTSTCTL_GET(x)       (((x) >> 13) & 0xf)
    #define SYNOPSYS_USB_HPRT_PRTTSTCTL_DISABLE      0x00000000
    #define SYNOPSYS_USB_HPRT_PRTTSTCTL_J            0x00000001
    #define SYNOPSYS_USB_HPRT_PRTTSTCTL_K            0x00000002
    #define SYNOPSYS_USB_HPRT_PRTTSTCTL_SE0NAK       0x00000003
    #define SYNOPSYS_USB_HPRT_PRTTSTCTL_PACKET       0x00000004
    #define SYNOPSYS_USB_HPRT_PRTTSTCTL_FORCE        0x00000005
/** Indicates the speed of the device attached to this port. @multiple */
  #define SYNOPSYS_USB_HPRT_PRTSPD                 0x00060000
  #define SYNOPSYS_USB_HPRT_PRTSPD_SHIFT           17
  #define SYNOPSYS_USB_HPRT_PRTSPD_SHIFT_VAL(v)    ((SYNOPSYS_USB_HPRT_PRTSPD_##v) << 17)
  #define SYNOPSYS_USB_HPRT_PRTSPD_SET(x, v)       do { (x) = (((x) & ~0x60000) | ((SYNOPSYS_USB_HPRT_PRTSPD_##v) << 17)); } while(0)
  #define SYNOPSYS_USB_HPRT_PRTSPD_SETVAL(x, v)    do { (x) = (((x) & ~0x60000) | ((v) << 17)); } while(0)
  #define SYNOPSYS_USB_HPRT_PRTSPD_GET(x)          (((x) >> 17) & 0x3)
    #define SYNOPSYS_USB_HPRT_PRTSPD_HS              0x00000000
    #define SYNOPSYS_USB_HPRT_PRTSPD_FS              0x00000001
    #define SYNOPSYS_USB_HPRT_PRTSPD_LS              0x00000002

#define SYNOPSYS_USB_HC_CHAR_ADDR(ridx)              (0x00000500 + (ridx) * 32)
#define SYNOPSYS_USB_HC_CHAR_COUNT                   14
#define SYNOPSYS_USB_HC_CHAR_MASK                    0xfffeffff
/** Indicates the maximum packet size of the associated endpoint. @multiple */
  #define SYNOPSYS_USB_HC_CHAR_MPS                 0x000007ff
  #define SYNOPSYS_USB_HC_CHAR_MPS_SHIFT           0
  #define SYNOPSYS_USB_HC_CHAR_MPS_SHIFT_VAL(v)    ((v) << 0)
  #define SYNOPSYS_USB_HC_CHAR_MPS_SET(x, v)       do { (x) = (((x) & ~0x7ff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_HC_CHAR_MPS_GET(x)          (((x) >> 0) & 0x7ff)
/** Indicates the maximum packet size of the associated endpoint. @multiple */
  #define SYNOPSYS_USB_HC_CHAR_EPNUM               0x00007800
  #define SYNOPSYS_USB_HC_CHAR_EPNUM_SHIFT         11
  #define SYNOPSYS_USB_HC_CHAR_EPNUM_SHIFT_VAL(v)  ((v) << 11)
  #define SYNOPSYS_USB_HC_CHAR_EPNUM_SET(x, v)     do { (x) = (((x) & ~0x7800) | ((v) << 11)); } while(0)
  #define SYNOPSYS_USB_HC_CHAR_EPNUM_GET(x)        (((x) >> 11) & 0xf)
/** Indicates whether the transaction is IN or OUT. @multiple */
  #define SYNOPSYS_USB_HC_CHAR_EPDIR               0x00008000
  #define SYNOPSYS_USB_HC_CHAR_EPDIR_SHIFT         15
  #define SYNOPSYS_USB_HC_CHAR_EPDIR_SHIFT_VAL(v)  ((SYNOPSYS_USB_HC_CHAR_EPDIR_##v) << 15)
  #define SYNOPSYS_USB_HC_CHAR_EPDIR_SET(x, v)     do { (x) = (((x) & ~0x8000) | ((SYNOPSYS_USB_HC_CHAR_EPDIR_##v) << 15)); } while(0)
  #define SYNOPSYS_USB_HC_CHAR_EPDIR_SETVAL(x, v)  do { (x) = (((x) & ~0x8000) | ((v) << 15)); } while(0)
  #define SYNOPSYS_USB_HC_CHAR_EPDIR_GET(x)        (((x) >> 15) & 0x1)
    #define SYNOPSYS_USB_HC_CHAR_EPDIR_OUT           0x00000000
    #define SYNOPSYS_USB_HC_CHAR_EPDIR_IN            0x00000001
/** This field is set by the application to indicate that this channel is
   communicating to a low-speed device. @multiple */
  #define SYNOPSYS_USB_HC_CHAR_LSPDDEV             0x00020000
  #define SYNOPSYS_USB_HC_CHAR_LSPDDEV_SHIFT       17
/** Indicates the transfer type selected. @multiple */
  #define SYNOPSYS_USB_HC_CHAR_EPTYPE              0x000c0000
  #define SYNOPSYS_USB_HC_CHAR_EPTYPE_SHIFT        18
  #define SYNOPSYS_USB_HC_CHAR_EPTYPE_SHIFT_VAL(v) ((SYNOPSYS_USB_HC_CHAR_EPTYPE_##v) << 18)
  #define SYNOPSYS_USB_HC_CHAR_EPTYPE_SET(x, v)    do { (x) = (((x) & ~0xc0000) | ((SYNOPSYS_USB_HC_CHAR_EPTYPE_##v) << 18)); } while(0)
  #define SYNOPSYS_USB_HC_CHAR_EPTYPE_SETVAL(x, v) do { (x) = (((x) & ~0xc0000) | ((v) << 18)); } while(0)
  #define SYNOPSYS_USB_HC_CHAR_EPTYPE_GET(x)       (((x) >> 18) & 0x3)
    #define SYNOPSYS_USB_HC_CHAR_EPTYPE_CONTROL      0x00000000
    #define SYNOPSYS_USB_HC_CHAR_EPTYPE_ISO          0x00000001
    #define SYNOPSYS_USB_HC_CHAR_EPTYPE_BULK         0x00000002
    #define SYNOPSYS_USB_HC_CHAR_EPTYPE_INT          0x00000003
/** For periodic transfers this field indicates to the host the number of
   transactions that must be executed per frame for this periodic endpoint. For
   non-periodic transfers, this field is used only in DMA mode, and specifies the
   number packets to be fetched for this channel before the internal DMA engine
   changes arbitration. @multiple */
  #define SYNOPSYS_USB_HC_CHAR_MC                  0x00300000
  #define SYNOPSYS_USB_HC_CHAR_MC_SHIFT            20
  #define SYNOPSYS_USB_HC_CHAR_MC_SHIFT_VAL(v)     ((v) << 20)
  #define SYNOPSYS_USB_HC_CHAR_MC_SET(x, v)        do { (x) = (((x) & ~0x300000) | ((v) << 20)); } while(0)
  #define SYNOPSYS_USB_HC_CHAR_MC_GET(x)           (((x) >> 20) & 0x3)
/** This field selects the specific device serving as the data source or sink.
   @multiple */
  #define SYNOPSYS_USB_HC_CHAR_DEVADDR             0x1fc00000
  #define SYNOPSYS_USB_HC_CHAR_DEVADDR_SHIFT       22
  #define SYNOPSYS_USB_HC_CHAR_DEVADDR_SHIFT_VAL(v) ((v) << 22)
  #define SYNOPSYS_USB_HC_CHAR_DEVADDR_SET(x, v)   do { (x) = (((x) & ~0x1fc00000) | ((v) << 22)); } while(0)
  #define SYNOPSYS_USB_HC_CHAR_DEVADDR_GET(x)      (((x) >> 22) & 0x7f)
/** This field selects the specific device serving as the data source or sink.
   @multiple */
  #define SYNOPSYS_USB_HC_CHAR_ODDFRM              0x20000000
  #define SYNOPSYS_USB_HC_CHAR_ODDFRM_SHIFT        29
/** The application sets this bit to stop transmitting/receiving data on a
   channel, even before the transfer for that channel is complete. The
   application must wait for the Channel Disabled interrupt before treating the
   channel as disabled. @multiple */
  #define SYNOPSYS_USB_HC_CHAR_CHDIS               0x40000000
  #define SYNOPSYS_USB_HC_CHAR_CHDIS_SHIFT         30
/** This field is set by the application and cleared by the core. The state of
   this bit reflects the channel enable status. el is complete. @multiple */
  #define SYNOPSYS_USB_HC_CHAR_CHENA               0x80000000
  #define SYNOPSYS_USB_HC_CHAR_CHENA_SHIFT         31

#define SYNOPSYS_USB_HC_INT_ADDR(ridx)               (0x00000508 + (ridx) * 32)
#define SYNOPSYS_USB_HC_INT_COUNT                    14
#define SYNOPSYS_USB_HC_INT_MASK                     0x000007bf
/** Transfer completed normally without any errors. This bit can be set only by
   the core and the application should write 1 to clear it. @multiple */
  #define SYNOPSYS_USB_HC_INT_XFERCOMPL            0x00000001
  #define SYNOPSYS_USB_HC_INT_XFERCOMPL_SHIFT      0
/** In DMA mode this bit indicates the transfer completed abnormally either
   because of any USB transaction error or in response to disable request by the
   application or because of a completed transfer. @multiple */
  #define SYNOPSYS_USB_HC_INT_CHHLTD               0x00000002
  #define SYNOPSYS_USB_HC_INT_CHHLTD_SHIFT         1
/** This is generated only in DMA mode when there is an AHB error during AHB
   read/write. The application can read the corresponding channel's DMA address
   register to get the error address. @multiple */
  #define SYNOPSYS_USB_HC_INT_AHBERR               0x00000004
  #define SYNOPSYS_USB_HC_INT_AHBERR_SHIFT         2
/** This bit can be set only by the core and the application should write 1 to
   clear it. @multiple */
  #define SYNOPSYS_USB_HC_INT_STALL                0x00000008
  #define SYNOPSYS_USB_HC_INT_STALL_SHIFT          3
/** This bit can be set only by the core and the application should write 1 to
   clear it. @multiple */
  #define SYNOPSYS_USB_HC_INT_NAK                  0x00000010
  #define SYNOPSYS_USB_HC_INT_NAK_SHIFT            4
/** This bit can be set only by the core and the application should write 1 to
   clear it. @multiple */
  #define SYNOPSYS_USB_HC_INT_ACK                  0x00000020
  #define SYNOPSYS_USB_HC_INT_ACK_SHIFT            5
/** Indicates one of the following errors occurred on the USB: CRC check failure,
   Timeout, Bit stuff error or False EOP. This bit can be set only by the core
   and the application should write 1 to clear it. @multiple */
  #define SYNOPSYS_USB_HC_INT_XACTERR              0x00000080
  #define SYNOPSYS_USB_HC_INT_XACTERR_SHIFT        7
/** This bit can be set only by the core and the application should write 1 to
   clear it. @multiple */
  #define SYNOPSYS_USB_HC_INT_BBLERR               0x00000100
  #define SYNOPSYS_USB_HC_INT_BBLERR_SHIFT         8
/** This bit can be set only by the core and the application should write 1 to
   clear it. @multiple */
  #define SYNOPSYS_USB_HC_INT_FRMOVRUN             0x00000200
  #define SYNOPSYS_USB_HC_INT_FRMOVRUN_SHIFT       9
/** This bit can be set only by the core and the application should write 1 to
   clear it. @multiple */
  #define SYNOPSYS_USB_HC_INT_DATATGLERR           0x00000400
  #define SYNOPSYS_USB_HC_INT_DATATGLERR_SHIFT     10

#define SYNOPSYS_USB_HC_INTMSK_ADDR(ridx)            (0x0000050c + (ridx) * 32)
#define SYNOPSYS_USB_HC_INTMSK_COUNT                 14
#define SYNOPSYS_USB_HC_INTMSK_MASK                  0x000007bf
/** Set to unmask XFERCOMPL interrupt. @multiple */
  #define SYNOPSYS_USB_HC_INTMSK_XFERCOMPLMSK      0x00000001
  #define SYNOPSYS_USB_HC_INTMSK_XFERCOMPLMSK_SHIFT 0
/** Set to unmask CHHLTD interrupt. @multiple */
  #define SYNOPSYS_USB_HC_INTMSK_CHHLTDMSK         0x00000002
  #define SYNOPSYS_USB_HC_INTMSK_CHHLTDMSK_SHIFT   1
/** Set to unmask AHBERR interrupt. @multiple */
  #define SYNOPSYS_USB_HC_INTMSK_AHBERRMSK         0x00000004
  #define SYNOPSYS_USB_HC_INTMSK_AHBERRMSK_SHIFT   2
/** Set to unmask STALL interrupt. @multiple */
  #define SYNOPSYS_USB_HC_INTMSK_STALLMSK          0x00000008
  #define SYNOPSYS_USB_HC_INTMSK_STALLMSK_SHIFT    3
/** Set to unmask NAK interrupt. @multiple */
  #define SYNOPSYS_USB_HC_INTMSK_NAKMSK            0x00000010
  #define SYNOPSYS_USB_HC_INTMSK_NAKMSK_SHIFT      4
/** Set to unmask ACK interrupt. @multiple */
  #define SYNOPSYS_USB_HC_INTMSK_ACKMSK            0x00000020
  #define SYNOPSYS_USB_HC_INTMSK_ACKMSK_SHIFT      5
/** Set to unmask XACTERR interrupt. @multiple */
  #define SYNOPSYS_USB_HC_INTMSK_XACTERRMSK        0x00000080
  #define SYNOPSYS_USB_HC_INTMSK_XACTERRMSK_SHIFT  7
/** Set to unmask BBLERR interrupt. @multiple */
  #define SYNOPSYS_USB_HC_INTMSK_BBLERRMSK         0x00000100
  #define SYNOPSYS_USB_HC_INTMSK_BBLERRMSK_SHIFT   8
/** Set to unmask FRMOVRUN interrupt. @multiple */
  #define SYNOPSYS_USB_HC_INTMSK_FRMOVRUNMSK       0x00000200
  #define SYNOPSYS_USB_HC_INTMSK_FRMOVRUNMSK_SHIFT 9
/** Set to unmask DATATGLERR interrupt. @multiple */
  #define SYNOPSYS_USB_HC_INTMSK_DATATGLERRMSK     0x00000400
  #define SYNOPSYS_USB_HC_INTMSK_DATATGLERRMSK_SHIFT 10

#define SYNOPSYS_USB_HC_TSIZE_ADDR(ridx)             (0x00000510 + (ridx) * 32)
#define SYNOPSYS_USB_HC_TSIZE_COUNT                  14
#define SYNOPSYS_USB_HC_TSIZE_MASK                   0x7fffffff
/** For an OUT, this field is the number of data bytes the host sends during the
   transfer. For an IN, this field is the buffer size that the application has
   reserved for the transfer. The application is expected to program this field
   as an integer multiple of the maximum packet size for IN transactions
   (periodic and non-periodic). @multiple */
  #define SYNOPSYS_USB_HC_TSIZE_XFERSIZE           0x0007ffff
  #define SYNOPSYS_USB_HC_TSIZE_XFERSIZE_SHIFT     0
  #define SYNOPSYS_USB_HC_TSIZE_XFERSIZE_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_HC_TSIZE_XFERSIZE_SET(x, v) do { (x) = (((x) & ~0x7ffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_HC_TSIZE_XFERSIZE_GET(x)    (((x) >> 0) & 0x7ffff)
/** This field is programmed by the application with the expected number of
   packets to be transmitted (OUT) or received (IN). The host decrements this
   count on every successful transmission or reception of an OUT/IN packet. Once
   this count reaches zero, the application is interrupted to indicate normal
   completion. @multiple */
  #define SYNOPSYS_USB_HC_TSIZE_PKTCNT             0x1ff80000
  #define SYNOPSYS_USB_HC_TSIZE_PKTCNT_SHIFT       19
  #define SYNOPSYS_USB_HC_TSIZE_PKTCNT_SHIFT_VAL(v) ((v) << 19)
  #define SYNOPSYS_USB_HC_TSIZE_PKTCNT_SET(x, v)   do { (x) = (((x) & ~0x1ff80000) | ((v) << 19)); } while(0)
  #define SYNOPSYS_USB_HC_TSIZE_PKTCNT_GET(x)      (((x) >> 19) & 0x3ff)
/** The application programs this field with the packet ID type to use for the
   initial transaction. The host maintains this field for the rest of the
   transfer. @multiple */
  #define SYNOPSYS_USB_HC_TSIZE_PID                0x60000000
  #define SYNOPSYS_USB_HC_TSIZE_PID_SHIFT          29
  #define SYNOPSYS_USB_HC_TSIZE_PID_SHIFT_VAL(v)   ((SYNOPSYS_USB_HC_TSIZE_PID_##v) << 29)
  #define SYNOPSYS_USB_HC_TSIZE_PID_SET(x, v)      do { (x) = (((x) & ~0x60000000) | ((SYNOPSYS_USB_HC_TSIZE_PID_##v) << 29)); } while(0)
  #define SYNOPSYS_USB_HC_TSIZE_PID_SETVAL(x, v)   do { (x) = (((x) & ~0x60000000) | ((v) << 29)); } while(0)
  #define SYNOPSYS_USB_HC_TSIZE_PID_GET(x)         (((x) >> 29) & 0x3)
    #define SYNOPSYS_USB_HC_TSIZE_PID_DATA0          0x00000000
    #define SYNOPSYS_USB_HC_TSIZE_PID_DATA2          0x00000001
    #define SYNOPSYS_USB_HC_TSIZE_PID_DATA1          0x00000002
    #define SYNOPSYS_USB_HC_TSIZE_PID_MDATA          0x00000003

#define SYNOPSYS_USB_HC_DMAADDR_ADDR(ridx)           (0x00000514 + (ridx) * 32)
#define SYNOPSYS_USB_HC_DMAADDR_COUNT                14
#define SYNOPSYS_USB_HC_DMAADDR_MASK                 0xffffffff
/** This field holds the start address in the external memory from which the data
   for the endpoint must be fetched or to which it must be stored. This register
   is incremented on every AHB transaction. The data for this register field is
   stored in RAM. Thus, the reset value is undefined (X). @multiple */
  #define SYNOPSYS_USB_HC_DMAADDR_VAL              0xffffffff
  #define SYNOPSYS_USB_HC_DMAADDR_VAL_SHIFT        0
  #define SYNOPSYS_USB_HC_DMAADDR_VAL_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_HC_DMAADDR_VAL_SET(x, v)    do { (x) = (((x) & ~0xffffffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_HC_DMAADDR_VAL_GET(x)       (((x) >> 0) & 0xffffffff)

#define SYNOPSYS_USB_DCFG_ADDR                       0x00000800
#define SYNOPSYS_USB_DCFG_MASK                       0xfc001fff
/** Indicates the speed at which the application requires the core to enumerate,
   or the maximum speed the application can support. However, the actual bus
   speed is determined only after the chirp sequence is completed, and is based
   on the speed of the USB host to which the core is connected. @multiple */
  #define SYNOPSYS_USB_DCFG_DEVSPD                 0x00000003
  #define SYNOPSYS_USB_DCFG_DEVSPD_SHIFT           0
  #define SYNOPSYS_USB_DCFG_DEVSPD_SHIFT_VAL(v)    ((SYNOPSYS_USB_DCFG_DEVSPD_##v) << 0)
  #define SYNOPSYS_USB_DCFG_DEVSPD_SET(x, v)       do { (x) = (((x) & ~0x3) | ((SYNOPSYS_USB_DCFG_DEVSPD_##v) << 0)); } while(0)
  #define SYNOPSYS_USB_DCFG_DEVSPD_SETVAL(x, v)    do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_DCFG_DEVSPD_GET(x)          (((x) >> 0) & 0x3)
    #define SYNOPSYS_USB_DCFG_DEVSPD_6MHZ            0x00000002
    #define SYNOPSYS_USB_DCFG_DEVSPD_48MHZ           0x00000003
/** The application can use this field to select the handshake the core sends on
   receiving a nonzero-length data packet during the OUT transaction of a control
   transfer's Status stage. When set to 1 send a STALL handshake on a
   nonzero-length status OUT transaction and do not send the received OUT packet
   to the application. When set to 0 send the received OUT packet to the
   application (zerolength or nonzero-length) and send a handshake based on the
   NAK and STALL bits for the endpoint in the Device Endpoint Control register.
   @multiple */
  #define SYNOPSYS_USB_DCFG_NZSTSOUTHSHK           0x00000004
  #define SYNOPSYS_USB_DCFG_NZSTSOUTHSHK_SHIFT     2
/** When this bit is set, the core expects that the PHY clock during Suspend is
   switched from 48 MHz to 32 KHz. @multiple */
  #define SYNOPSYS_USB_DCFG_ENA32KHZSUSP           0x00000008
  #define SYNOPSYS_USB_DCFG_ENA32KHZSUSP_SHIFT     3
/** The application must program this field after every SetAddress control
   command. @multiple */
  #define SYNOPSYS_USB_DCFG_DEVADDR                0x000007f0
  #define SYNOPSYS_USB_DCFG_DEVADDR_SHIFT          4
  #define SYNOPSYS_USB_DCFG_DEVADDR_SHIFT_VAL(v)   ((v) << 4)
  #define SYNOPSYS_USB_DCFG_DEVADDR_SET(x, v)      do { (x) = (((x) & ~0x7f0) | ((v) << 4)); } while(0)
  #define SYNOPSYS_USB_DCFG_DEVADDR_GET(x)         (((x) >> 4) & 0x7f)
/** Indicates the time within a frame at which the application must be notified
   using the End Of Periodic Frame Interrupt. This can be used to determine if
   all the isochronous traffic for that frame is complete. @multiple */
  #define SYNOPSYS_USB_DCFG_PERFRINT               0x00001800
  #define SYNOPSYS_USB_DCFG_PERFRINT_SHIFT         11
  #define SYNOPSYS_USB_DCFG_PERFRINT_SHIFT_VAL(v)  ((SYNOPSYS_USB_DCFG_PERFRINT_##v) << 11)
  #define SYNOPSYS_USB_DCFG_PERFRINT_SET(x, v)     do { (x) = (((x) & ~0x1800) | ((SYNOPSYS_USB_DCFG_PERFRINT_##v) << 11)); } while(0)
  #define SYNOPSYS_USB_DCFG_PERFRINT_SETVAL(x, v)  do { (x) = (((x) & ~0x1800) | ((v) << 11)); } while(0)
  #define SYNOPSYS_USB_DCFG_PERFRINT_GET(x)        (((x) >> 11) & 0x3)
    #define SYNOPSYS_USB_DCFG_PERFRINT_80PCNT        0x00000000
    #define SYNOPSYS_USB_DCFG_PERFRINT_85PCNT        0x00000001
    #define SYNOPSYS_USB_DCFG_PERFRINT_90PCNT        0x00000002
    #define SYNOPSYS_USB_DCFG_PERFRINT_95PCNT        0x00000003
/** This field is effective only when USB_DCFG.ENA32KHZSUSP is set. It will
   control the resume period when the core resumes from suspend. The core counts
   for RESVALID number of clock cycles to detect a valid resume when
   USB_DCFG.ENA32KHZSUSP is set. @multiple */
  #define SYNOPSYS_USB_DCFG_RESVALID               0xfc000000
  #define SYNOPSYS_USB_DCFG_RESVALID_SHIFT         26
  #define SYNOPSYS_USB_DCFG_RESVALID_SHIFT_VAL(v)  ((v) << 26)
  #define SYNOPSYS_USB_DCFG_RESVALID_SET(x, v)     do { (x) = (((x) & ~0xfc000000) | ((v) << 26)); } while(0)
  #define SYNOPSYS_USB_DCFG_RESVALID_GET(x)        (((x) >> 26) & 0x3f)

#define SYNOPSYS_USB_DCTL_ADDR                       0x00000804
#define SYNOPSYS_USB_DCTL_MASK                       0x00018fff
/** When the application sets this bit, the core initiates remote signaling to
   wake up the USB host. The application must set this bit to instruct the core
   to exit the Suspend state. As specified in the USB 2.0 specification, the
   application must clear this bit 1-15 ms after setting it. @multiple */
  #define SYNOPSYS_USB_DCTL_RMTWKUPSIG             0x00000001
  #define SYNOPSYS_USB_DCTL_RMTWKUPSIG_SHIFT       0
/** The application uses this bit to signal the core to do a soft disconnect. As
   long as this bit is set, the host does not see that the device is connected,
   and the device does not receive signals on the USB. The core stays in the
   disconnected state until the application clears this bit. When suspended, the
   minimum duration for which the core must keep this bit set is 1 ms + 2.5 us.
   When IDLE or performing transactions, the minimum duration for which the core
   must keep this bit set is 2.5 us. @multiple */
  #define SYNOPSYS_USB_DCTL_SFTDISCON              0x00000002
  #define SYNOPSYS_USB_DCTL_SFTDISCON_SHIFT        1
/** When this bit is 0 a handshake is sent out based on the data availability in
   the transmit FIFO. When this bit is 1 a NAK handshake is sent out on all
   non-periodic IN endpoints, irrespective of the data availability in the
   transmit FIFO. @multiple */
  #define SYNOPSYS_USB_DCTL_GNPINNAKSTS            0x00000004
  #define SYNOPSYS_USB_DCTL_GNPINNAKSTS_SHIFT      2
/** When this bit is 0 a handshake is sent based on the FIFO Status and the NAK
   and STALL bit settings. When this bit is 1 no data is written to the RxFIFO,
   irrespective of space availability. Sends a NAK handshake on all packets,
   except on SETUP transactions. All isochronous OUT packets are dropped.
   @multiple */
  #define SYNOPSYS_USB_DCTL_GOUTNAKSTS             0x00000008
  #define SYNOPSYS_USB_DCTL_GOUTNAKSTS_SHIFT       3
/** Set to a non-zero value to enable test control. @multiple */
  #define SYNOPSYS_USB_DCTL_TSTCTL                 0x00000070
  #define SYNOPSYS_USB_DCTL_TSTCTL_SHIFT           4
  #define SYNOPSYS_USB_DCTL_TSTCTL_SHIFT_VAL(v)    ((SYNOPSYS_USB_DCTL_TSTCTL_##v) << 4)
  #define SYNOPSYS_USB_DCTL_TSTCTL_SET(x, v)       do { (x) = (((x) & ~0x70) | ((SYNOPSYS_USB_DCTL_TSTCTL_##v) << 4)); } while(0)
  #define SYNOPSYS_USB_DCTL_TSTCTL_SETVAL(x, v)    do { (x) = (((x) & ~0x70) | ((v) << 4)); } while(0)
  #define SYNOPSYS_USB_DCTL_TSTCTL_GET(x)          (((x) >> 4) & 0x7)
    #define SYNOPSYS_USB_DCTL_TSTCTL_DISABLE         0x00000000
    #define SYNOPSYS_USB_DCTL_TSTCTL_J               0x00000001
    #define SYNOPSYS_USB_DCTL_TSTCTL_K               0x00000002
    #define SYNOPSYS_USB_DCTL_TSTCTL_SE0NAK          0x00000003
    #define SYNOPSYS_USB_DCTL_TSTCTL_PACKET          0x00000004
    #define SYNOPSYS_USB_DCTL_TSTCTL_FORCE           0x00000005
/** A write to this field sets the Global Non-periodic IN NAK. The application
   uses this bit to send a NAK handshake on all non-periodic IN endpoints. The
   application must set this bit only after making sure that the Global IN NAK
   Effective bit in the Core Interrupt Register (USB_GINTSTS.GINNAKEFF) is
   cleared. @multiple */
  #define SYNOPSYS_USB_DCTL_SGNPINNAK              0x00000080
  #define SYNOPSYS_USB_DCTL_SGNPINNAK_SHIFT        7
/** A write to this field clears the Global Non-periodic IN NAK. @multiple */
  #define SYNOPSYS_USB_DCTL_CGNPINNAK              0x00000100
  #define SYNOPSYS_USB_DCTL_CGNPINNAK_SHIFT        8
/** A write to this field sets the Global OUT NAK. The application uses this bit
   to send a NAK handshake on all OUT endpoints. The application must set this
   bit only after making sure that the Global OUT NAK Effective bit in the Core
   Interrupt Register (USB_GINTSTS.GOUTNAKEFF) is cleared. @multiple */
  #define SYNOPSYS_USB_DCTL_SGOUTNAK               0x00000200
  #define SYNOPSYS_USB_DCTL_SGOUTNAK_SHIFT         9
/** A write to this field clears the Global OUT NAK. @multiple */
  #define SYNOPSYS_USB_DCTL_CGOUTNAK               0x00000400
  #define SYNOPSYS_USB_DCTL_CGOUTNAK_SHIFT         10
/** The application uses this bit to indicate that register programming is
   completed after a wake-up from Power Down mode. @multiple */
  #define SYNOPSYS_USB_DCTL_PWRONPRGDONE           0x00000800
  #define SYNOPSYS_USB_DCTL_PWRONPRGDONE_SHIFT     11
/** When set to 0 the core transmits the packets only in the frame number in
   which they are intended to be transmitted. When set to 1 the core ignores the
   frame number, sending packets immediately as the packets are ready. @multiple
   */
  #define SYNOPSYS_USB_DCTL_IGNRFRMNUM             0x00008000
  #define SYNOPSYS_USB_DCTL_IGNRFRMNUM_SHIFT       15
/** Set NAK automatically on babble. The core sets NAK automatically for the
   endpoint on which babble is received. @multiple */
  #define SYNOPSYS_USB_DCTL_NAKONBBLE              0x00010000
  #define SYNOPSYS_USB_DCTL_NAKONBBLE_SHIFT        16

#define SYNOPSYS_USB_DSTS_ADDR                       0x00000808
#define SYNOPSYS_USB_DSTS_MASK                       0x003fff0f
/** In Device mode, this bit is set as long as a Suspend condition is detected on
   the USB. The core enters the Suspended state when there is no activity on the
   bus for an extended period of time. The core comes out of the suspend when
   there is any activity on the bus or when the application writes to the Remote
   Wakeup Signaling bit in the Device Control register (USB_DCTL.RMTWKUPSIG).
   @multiple */
  #define SYNOPSYS_USB_DSTS_SUSPSTS                0x00000001
  #define SYNOPSYS_USB_DSTS_SUSPSTS_SHIFT          0
/** Indicates the speed at which the core has come up after speed detection
   through a chirp sequence. @multiple */
  #define SYNOPSYS_USB_DSTS_ENUMSPD                0x00000006
  #define SYNOPSYS_USB_DSTS_ENUMSPD_SHIFT          1
  #define SYNOPSYS_USB_DSTS_ENUMSPD_SHIFT_VAL(v)   ((v) << 1)
  #define SYNOPSYS_USB_DSTS_ENUMSPD_SET(x, v)      do { (x) = (((x) & ~0x6) | ((v) << 1)); } while(0)
  #define SYNOPSYS_USB_DSTS_ENUMSPD_GET(x)         (((x) >> 1) & 0x3)
/** The core sets this bit to report any erratic errors (PHY error) Due to
   erratic errors, the core goes into Suspended state and an interrupt is
   generated to the application with Early Suspend bit of the Core Interrupt
   register (USB_GINTSTS.ERLYSUSP). If the early suspend is asserted due to an
   erratic error, the application can only perform a soft disconnect recover.
   @multiple */
  #define SYNOPSYS_USB_DSTS_ERRTICERR              0x00000008
  #define SYNOPSYS_USB_DSTS_ERRTICERR_SHIFT        3
/** This field contains a Frame number. This field may return a non zero value if
   read immediately after power on reset. In case the register bits reads non
   zero immediately after power on reset it does not indicate that SOF has been
   received from the host. The read value of this interrupt is valid only after a
   valid connection between host and device is established. he core sets this bit
   to report any erratic errors (PHY error) Due to erratic errors, the core goes
   into Suspended state and an interrupt @multiple */
  #define SYNOPSYS_USB_DSTS_SOFFN                  0x003fff00
  #define SYNOPSYS_USB_DSTS_SOFFN_SHIFT            8
  #define SYNOPSYS_USB_DSTS_SOFFN_SHIFT_VAL(v)     ((v) << 8)
  #define SYNOPSYS_USB_DSTS_SOFFN_SET(x, v)        do { (x) = (((x) & ~0x3fff00) | ((v) << 8)); } while(0)
  #define SYNOPSYS_USB_DSTS_SOFFN_GET(x)           (((x) >> 8) & 0x3fff)

#define SYNOPSYS_USB_DIEPMSK_ADDR                    0x00000810
#define SYNOPSYS_USB_DIEPMSK_MASK                    0x0000315f
/** Set to 1 to unmask XFERCOMPL interrupt. @multiple */
  #define SYNOPSYS_USB_DIEPMSK_XFERCOMPLMSK        0x00000001
  #define SYNOPSYS_USB_DIEPMSK_XFERCOMPLMSK_SHIFT  0
/** Set to 1 to unmask EPDISBLD interrupt. @multiple */
  #define SYNOPSYS_USB_DIEPMSK_EPDISBLDMSK         0x00000002
  #define SYNOPSYS_USB_DIEPMSK_EPDISBLDMSK_SHIFT   1
/** Set to 1 to unmask AHBERR interrupt. @multiple */
  #define SYNOPSYS_USB_DIEPMSK_AHBERRMSK           0x00000004
  #define SYNOPSYS_USB_DIEPMSK_AHBERRMSK_SHIFT     2
/** Set to 1 to unmask Interrupt TIMEOUT. Applies to Non-isochronous endpoints.
   @multiple */
  #define SYNOPSYS_USB_DIEPMSK_TIMEOUTMSK          0x00000008
  #define SYNOPSYS_USB_DIEPMSK_TIMEOUTMSK_SHIFT    3
/** Set to 1 to unmask INTKNTXFEMP interrupt. @multiple */
  #define SYNOPSYS_USB_DIEPMSK_INTKNTXFEMPMSK      0x00000010
  #define SYNOPSYS_USB_DIEPMSK_INTKNTXFEMPMSK_SHIFT 4
/** Set to 1 to unmask INEPNAKEFF interrupt. @multiple */
  #define SYNOPSYS_USB_DIEPMSK_INEPNAKEFFMSK       0x00000040
  #define SYNOPSYS_USB_DIEPMSK_INEPNAKEFFMSK_SHIFT 6
/** Set to 1 to unmask TXFIFOUNDRN interrupt. @multiple */
  #define SYNOPSYS_USB_DIEPMSK_TXFIFOUNDRNMSK      0x00000100
  #define SYNOPSYS_USB_DIEPMSK_TXFIFOUNDRNMSK_SHIFT 8
/** Set to 1 to unmask BBLEERR interrupt. @multiple */
  #define SYNOPSYS_USB_DIEPMSK_BBLEERRMSK          0x00001000
  #define SYNOPSYS_USB_DIEPMSK_BBLEERRMSK_SHIFT    12
/** Set to 1 to unmask NAK interrupt. @multiple */
  #define SYNOPSYS_USB_DIEPMSK_NAKMSK              0x00002000
  #define SYNOPSYS_USB_DIEPMSK_NAKMSK_SHIFT        13

#define SYNOPSYS_USB_DOEPMSK_ADDR                    0x00000814
#define SYNOPSYS_USB_DOEPMSK_MASK                    0x0000315f
/** Set to 1 to unmask XFERCOMPL Interrupt. @multiple */
  #define SYNOPSYS_USB_DOEPMSK_XFERCOMPLMSK        0x00000001
  #define SYNOPSYS_USB_DOEPMSK_XFERCOMPLMSK_SHIFT  0
/** Set to 1 to unmask EPDISBLD Interrupt. @multiple */
  #define SYNOPSYS_USB_DOEPMSK_EPDISBLDMSK         0x00000002
  #define SYNOPSYS_USB_DOEPMSK_EPDISBLDMSK_SHIFT   1
/** Set to 1 to unmask AHBERR Interrupt. @multiple */
  #define SYNOPSYS_USB_DOEPMSK_AHBERRMSK           0x00000004
  #define SYNOPSYS_USB_DOEPMSK_AHBERRMSK_SHIFT     2
/** Set to 1 to unmask SETUP Interrupt. Applies to control endpoints only.
   @multiple */
  #define SYNOPSYS_USB_DOEPMSK_SETUPMSK            0x00000008
  #define SYNOPSYS_USB_DOEPMSK_SETUPMSK_SHIFT      3
/** Set to 1 to unmask OUTTKNTXFEMP Interrupt. @multiple */
  #define SYNOPSYS_USB_DOEPMSK_OUTTKNTXFEMPMSK     0x00000010
  #define SYNOPSYS_USB_DOEPMSK_OUTTKNTXFEMPMSK_SHIFT 4
/** Set to 1 to unmask BACK2BACKSETUP Interrupt. Applies to control OUT endpoints
   only. @multiple */
  #define SYNOPSYS_USB_DOEPMSK_BACK2BACKSETUP      0x00000040
  #define SYNOPSYS_USB_DOEPMSK_BACK2BACKSETUP_SHIFT 6
/** Set to 1 to unmask OUTPKTERR Interrupt. @multiple */
  #define SYNOPSYS_USB_DOEPMSK_OUTPKTERRMSK        0x00000100
  #define SYNOPSYS_USB_DOEPMSK_OUTPKTERRMSK_SHIFT  8
/** Set to 1 to unmask NAK Interrupt. @multiple */
  #define SYNOPSYS_USB_DOEPMSK_BBLEERRMSK          0x00001000
  #define SYNOPSYS_USB_DOEPMSK_BBLEERRMSK_SHIFT    12
/** Set to 1 to unmask BBLEERR Interrupt. @multiple */
  #define SYNOPSYS_USB_DOEPMSK_NAKMSK              0x00002000
  #define SYNOPSYS_USB_DOEPMSK_NAKMSK_SHIFT        13

#define SYNOPSYS_USB_DAINT_ADDR                      0x00000818
#define SYNOPSYS_USB_DAINT_MASK                      0x007f007f
/** This bit is set when one or more of the interrupt flags in USB_DIEP0INT are
   set. @multiple */
  #define SYNOPSYS_USB_DAINT_INEPINT_COUNT         7
  #define SYNOPSYS_USB_DAINT_INEPINT(fidx)         (0x00000001 << ((fidx)))
  #define SYNOPSYS_USB_DAINT_INEPINT_SHIFT(fidx)   ((fidx) + 0)
/** This bit is set when one or more of the interrupt flags in USB_DOEP0INT are
   set. @multiple */
  #define SYNOPSYS_USB_DAINT_OUTEPINT_COUNT        7
  #define SYNOPSYS_USB_DAINT_OUTEPINT(fidx)        (0x00010000 << ((fidx)))
  #define SYNOPSYS_USB_DAINT_OUTEPINT_SHIFT(fidx)  ((fidx) + 16)

#define SYNOPSYS_USB_DAINTMSK_ADDR                   0x0000081c
#define SYNOPSYS_USB_DAINTMSK_MASK                   0x007f007f
/** Set to 1 to unmask USB_DAINT.INEPINTX. @multiple */
  #define SYNOPSYS_USB_DAINTMSK_INEPMSK_COUNT      7
  #define SYNOPSYS_USB_DAINTMSK_INEPMSK(fidx)      (0x00000001 << ((fidx)))
  #define SYNOPSYS_USB_DAINTMSK_INEPMSK_SHIFT(fidx) ((fidx) + 0)
/** Set to 1 to unmask USB_DAINT.OUTEPINTX. @multiple */
  #define SYNOPSYS_USB_DAINTMSK_OUTEPMSK_COUNT     7
  #define SYNOPSYS_USB_DAINTMSK_OUTEPMSK(fidx)     (0x00010000 << ((fidx)))
  #define SYNOPSYS_USB_DAINTMSK_OUTEPMSK_SHIFT(fidx) ((fidx) + 16)

#define SYNOPSYS_USB_DVBUSDIS_ADDR                   0x00000828
#define SYNOPSYS_USB_DVBUSDIS_MASK                   0x0000ffff
/** Specifies the VBUS discharge time after VBUS pulsing during SRP. This value
   equals VBUS discharge time in PHY clocks / 1024. Depending on your VBUS load,
   this value can need adjustment. @multiple */
  #define SYNOPSYS_USB_DVBUSDIS_VAL                0x0000ffff
  #define SYNOPSYS_USB_DVBUSDIS_VAL_SHIFT          0
  #define SYNOPSYS_USB_DVBUSDIS_VAL_SHIFT_VAL(v)   ((v) << 0)
  #define SYNOPSYS_USB_DVBUSDIS_VAL_SET(x, v)      do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_DVBUSDIS_VAL_GET(x)         (((x) >> 0) & 0xffff)

#define SYNOPSYS_USB_DVBUSPULSE_ADDR                 0x0000082c
#define SYNOPSYS_USB_DVBUSPULSE_MASK                 0x0000ffff
/** Specifies the VBUS pulsing time during SRP. This value equals VBUS pulsing
   time in PHY clocks / 1024. e in PHY clocks / 1024. @multiple */
  #define SYNOPSYS_USB_DVBUSPULSE_VAL              0x0000ffff
  #define SYNOPSYS_USB_DVBUSPULSE_VAL_SHIFT        0
  #define SYNOPSYS_USB_DVBUSPULSE_VAL_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_DVBUSPULSE_VAL_SET(x, v)    do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_DVBUSPULSE_VAL_GET(x)       (((x) >> 0) & 0xffff)

#define SYNOPSYS_USB_DIEPEMPMSK_ADDR                 0x00000834
#define SYNOPSYS_USB_DIEPEMPMSK_MASK                 0x0000ffff
/** These bits acts as mask bits for USB_DIEP0INT.TXFEMP/USB_DIEPx_INT.TXFEMP
   interrupt. One bit per IN Endpoint: Bit 0 for IN EP 0, bit 6 for IN EP 6.
   @multiple */
  #define SYNOPSYS_USB_DIEPEMPMSK_VAL              0x0000ffff
  #define SYNOPSYS_USB_DIEPEMPMSK_VAL_SHIFT        0
  #define SYNOPSYS_USB_DIEPEMPMSK_VAL_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_DIEPEMPMSK_VAL_SET(x, v)    do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_DIEPEMPMSK_VAL_GET(x)       (((x) >> 0) & 0xffff)

#define SYNOPSYS_USB_DIEPCTL_ADDR(ridx)              (0x00000900 + (ridx) * 32)
#define SYNOPSYS_USB_DIEPCTL_COUNT                   7
#define SYNOPSYS_USB_DIEPCTL_MASK                    0xffef87ff
/** The application must program this field with the maximum packet size for the
   current logical endpoint. @multiple */
  #define SYNOPSYS_USB_DIEPCTL_MPS                 0x000007ff
  #define SYNOPSYS_USB_DIEPCTL_MPS_SHIFT           0
  #define SYNOPSYS_USB_DIEPCTL_MPS_SHIFT_VAL(v)    ((v) << 0)
  #define SYNOPSYS_USB_DIEPCTL_MPS_SET(x, v)       do { (x) = (((x) & ~0x7ff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_DIEPCTL_MPS_GET(x)          (((x) >> 0) & 0x7ff)
/** This bit is always 1, indicating that control endpoint 0 is always active in
   all configurations and interfaces. @multiple */
  #define SYNOPSYS_USB_DIEPCTL_USBACTEP            0x00008000
  #define SYNOPSYS_USB_DIEPCTL_USBACTEP_SHIFT      15
/** For interrupt/bulk endpoints this field contains the PID of the packet to be
   received or transmitted on this endpoint. The application must program the PID
   of the first packet to be received or transmitted on this endpoint, after the
   endpoint is activated. The applications use the SETD1PIDOF and SETD0PIDEF
   fields of this register to program either DATA0 or DATA1 PID. For isochronous
   endpoints, this field indicates the frame number in which the core
   transmits/receives isochronous data for this endpoint. The application must
   program the even/odd frame number in which it intends to transmit/receive
   isochronous data for this endpoint using the SETD0PIDEF and SETD1PIDOF fields
   in this register. @multiple */
  #define SYNOPSYS_USB_DIEPCTL_DPIDEOF             0x00010000
  #define SYNOPSYS_USB_DIEPCTL_DPIDEOF_SHIFT       16
  #define SYNOPSYS_USB_DIEPCTL_DPIDEOF_SHIFT_VAL(v) ((SYNOPSYS_USB_DIEPCTL_DPIDEOF_##v) << 16)
  #define SYNOPSYS_USB_DIEPCTL_DPIDEOF_SET(x, v)   do { (x) = (((x) & ~0x10000) | ((SYNOPSYS_USB_DIEPCTL_DPIDEOF_##v) << 16)); } while(0)
  #define SYNOPSYS_USB_DIEPCTL_DPIDEOF_SETVAL(x, v) do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define SYNOPSYS_USB_DIEPCTL_DPIDEOF_GET(x)      (((x) >> 16) & 0x1)
    #define SYNOPSYS_USB_DIEPCTL_DPIDEOF_EVEN        0x00000000
    #define SYNOPSYS_USB_DIEPCTL_DPIDEOF_ODD         0x00000001
/** When this bit is 0 the core is transmitting non-NAK handshakes based on the
   FIFO status. When this bit is 1 the core is transmitting NAK handshakes on
   this endpoint. When either the application or the core sets this bit the core
   stops receiving any data on an OUT endpoint, even if there is space in the
   RxFIFO to accommodate the incoming packet. For non-isochronous IN endpoints
   the core stops transmitting any data on an IN endpoint, even if there data is
   available in the TxFIFO. For isochronous IN endpoints the core sends out a
   zero-length data packet, even if there data is available in the TxFIFO.
   Irrespective of this bit's setting, the core always responds to SETUP data
   packets with an ACK handshake. @multiple */
  #define SYNOPSYS_USB_DIEPCTL_NAKSTS              0x00020000
  #define SYNOPSYS_USB_DIEPCTL_NAKSTS_SHIFT        17
/** This is the transfer type supported by this logical endpoint. @multiple */
  #define SYNOPSYS_USB_DIEPCTL_ETYPE               0x000c0000
  #define SYNOPSYS_USB_DIEPCTL_ETYPE_SHIFT         18
  #define SYNOPSYS_USB_DIEPCTL_ETYPE_SHIFT_VAL(v)  ((SYNOPSYS_USB_DIEPCTL_ETYPE_##v) << 18)
  #define SYNOPSYS_USB_DIEPCTL_ETYPE_SET(x, v)     do { (x) = (((x) & ~0xc0000) | ((SYNOPSYS_USB_DIEPCTL_ETYPE_##v) << 18)); } while(0)
  #define SYNOPSYS_USB_DIEPCTL_ETYPE_SETVAL(x, v)  do { (x) = (((x) & ~0xc0000) | ((v) << 18)); } while(0)
  #define SYNOPSYS_USB_DIEPCTL_ETYPE_GET(x)        (((x) >> 18) & 0x3)
    #define SYNOPSYS_USB_DIEPCTL_ETYPE_CONTROL       0x00000000
    #define SYNOPSYS_USB_DIEPCTL_ETYPE_ISO           0x00000001
    #define SYNOPSYS_USB_DIEPCTL_ETYPE_BULK          0x00000002
    #define SYNOPSYS_USB_DIEPCTL_ETYPE_INT           0x00000003
/** For bulk and interrupt endpoints: The application sets this bit to stall all
   tokens from the USB host to this endpoint. If a NAK bit, Global Non-periodic
   IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes
   priority. In this case only the application can clear this bit, never the
   core. When control endpoint: The application can only set this bit, and the
   core clears it, when a SETUP token is received for this endpoint. If a NAK
   bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit,
   the STALL bit takes priority. Irrespective of this bit's setting, the core
   always responds to SETUP data packets with an ACK handshake. @multiple */
  #define SYNOPSYS_USB_DIEPCTL_STALL               0x00200000
  #define SYNOPSYS_USB_DIEPCTL_STALL_SHIFT         21
/** These bits specify the FIFO number associated with this endpoint. Each active
   IN endpoint must be programmed to a separate FIFO number. This field is valid
   only for IN endpoints. @multiple */
  #define SYNOPSYS_USB_DIEPCTL_TXFNUM              0x03c00000
  #define SYNOPSYS_USB_DIEPCTL_TXFNUM_SHIFT        22
  #define SYNOPSYS_USB_DIEPCTL_TXFNUM_SHIFT_VAL(v) ((v) << 22)
  #define SYNOPSYS_USB_DIEPCTL_TXFNUM_SET(x, v)    do { (x) = (((x) & ~0x3c00000) | ((v) << 22)); } while(0)
  #define SYNOPSYS_USB_DIEPCTL_TXFNUM_GET(x)       (((x) >> 22) & 0xf)
/** A write to this bit clears the NAK bit for the endpoint. @multiple */
  #define SYNOPSYS_USB_DIEPCTL_CNAK                0x04000000
  #define SYNOPSYS_USB_DIEPCTL_CNAK_SHIFT          26
/** A write to this bit sets the NAK bit for the endpoint. Using this bit, the
   application can control the transmission of NAK handshakes on an endpoint. The
   core can also set this bit for an endpoint after a SETUP packet is received on
   that endpoint. @multiple */
  #define SYNOPSYS_USB_DIEPCTL_SNAK                0x08000000
  #define SYNOPSYS_USB_DIEPCTL_SNAK_SHIFT          27
/** For bulk and interrupt endpoints writing this field sets the Endpoint Data
   PID / Even or Odd Frame (DPIDEOF) field in this register to DATA0EVEN. For
   isochronous endpoints writing this field sets the Endpoint Data PID / Even or
   Odd Frame (DPIDEOF) field to odd (DATA0EVEN). @multiple */
  #define SYNOPSYS_USB_DIEPCTL_SETD0PIDEF          0x10000000
  #define SYNOPSYS_USB_DIEPCTL_SETD0PIDEF_SHIFT    28
/** For bulk and interrupt endpoints writing this field sets the Endpoint Data
   PID / Even or Odd Frame (DPIDEOF) field in this register to DATA1ODD. For
   isochronous endpoints writing this field sets the Endpoint Data PID / Even or
   Odd Frame (DPIDEOF) field to odd (DATA1ODD). @multiple */
  #define SYNOPSYS_USB_DIEPCTL_SETD1PIDOF          0x20000000
  #define SYNOPSYS_USB_DIEPCTL_SETD1PIDOF_SHIFT    29
/** The application sets this bit to stop transmitting data on an endpoint, even
   before the transfer for that endpoint is complete. The application must wait
   for the Endpoint Disabled interrupt before treating the endpoint as disabled.
   The core clears this bit before setting the Endpoint Disabled Interrupt. The
   application must set this bit only if Endpoint Enable is already set for this
   endpoint. @multiple */
  #define SYNOPSYS_USB_DIEPCTL_EPDIS               0x40000000
  #define SYNOPSYS_USB_DIEPCTL_EPDIS_SHIFT         30
/** In DMA mode for IN endpoints, this bit indicates that data is ready to be
   transmitted on the endpoint. The core clears this bit before setting any of
   the following interrupts on this endpoint: SETUP Phase Done, Endpoint
   Disabled, Transfer Completed. For control endpoints in DMA mode, this bit must
   be set to be able to transfer SETUP data packets in memory. @multiple */
  #define SYNOPSYS_USB_DIEPCTL_EPENA               0x80000000
  #define SYNOPSYS_USB_DIEPCTL_EPENA_SHIFT         31

#define SYNOPSYS_USB_DIEPINT_ADDR(ridx)              (0x00000908 + (ridx) * 32)
#define SYNOPSYS_USB_DIEPINT_COUNT                   7
#define SYNOPSYS_USB_DIEPINT_MASK                    0x000038df
/** This field indicates that the programmed transfer is complete on the AHB as
   well as on the USB, for this endpoint. @multiple */
  #define SYNOPSYS_USB_DIEPINT_XFERCOMPL           0x00000001
  #define SYNOPSYS_USB_DIEPINT_XFERCOMPL_SHIFT     0
/** This bit indicates that the endpoint is disabled per the application's
   request. @multiple */
  #define SYNOPSYS_USB_DIEPINT_EPDISBLD            0x00000002
  #define SYNOPSYS_USB_DIEPINT_EPDISBLD_SHIFT      1
/** This is generated in DMA mode when there is an AHB error during an AHB
   read/write. The application can read the corresponding endpoint DMA address
   register to get the error address. @multiple */
  #define SYNOPSYS_USB_DIEPINT_AHBERR              0x00000004
  #define SYNOPSYS_USB_DIEPINT_AHBERR_SHIFT        2
/** Applies only to Control IN endpoints. Indicates that the core has detected a
   timeout condition on the USB for the last IN token on this endpoint. @multiple
   */
  #define SYNOPSYS_USB_DIEPINT_TIMEOUT             0x00000008
  #define SYNOPSYS_USB_DIEPINT_TIMEOUT_SHIFT       3
/** Applies to non-periodic IN endpoints only. Indicates that an IN token was
   received when the associated TxFIFO (periodic/non- periodic) was empty. This
   interrupt is asserted on the endpoint for which the IN token was received.
   @multiple */
  #define SYNOPSYS_USB_DIEPINT_INTKNTXFEMP         0x00000010
  #define SYNOPSYS_USB_DIEPINT_INTKNTXFEMP_SHIFT   4
/** Applies to periodic IN endpoints only. This bit can be cleared when the
   application clears the IN endpoint NAK by writing to USB_DIEP0CTL.CNAK. This
   interrupt indicates that the core has sampled the NAK bit set (either by the
   application or by the core). The interrupt indicates that the IN endpoint NAK
   bit set by the application has taken effect in the core. This interrupt does
   not guarantee that a NAK handshake is sent on the USB. A STALL bit takes
   priority over a NAK bit. @multiple */
  #define SYNOPSYS_USB_DIEPINT_INEPNAKEFF          0x00000040
  #define SYNOPSYS_USB_DIEPINT_INEPNAKEFF_SHIFT    6
/** This interrupt is asserted when the TxFIFO for this endpoint is either half
   or completely empty. The half or completely empty status is determined by the
   TxFIFO Empty Level bit in the Core AHB Configuration register
   (USB_GAHBCFG.NPTXFEMPLVL). @multiple */
  #define SYNOPSYS_USB_DIEPINT_TXFEMP              0x00000080
  #define SYNOPSYS_USB_DIEPINT_TXFEMP_SHIFT        7
/** This bit indicates to the application that an ISO OUT packet has been
   dropped. This bit does not have an associated mask bit and does not generate
   an interrupt. @multiple */
  #define SYNOPSYS_USB_DIEPINT_PKTDRPSTS           0x00000800
  #define SYNOPSYS_USB_DIEPINT_PKTDRPSTS_SHIFT     11
/** The core generates this interrupt when babble is received for the endpoint.
   @multiple */
  #define SYNOPSYS_USB_DIEPINT_BBLERR              0x00001000
  #define SYNOPSYS_USB_DIEPINT_BBLERR_SHIFT        12
/** The core generates this interrupt when a NAK is transmitted or received by
   the device. In case of isochronous IN endpoints the interrupt gets generated
   when a zero length packet is transmitted due to un-availability of data in the
   TXFifo. @multiple */
  #define SYNOPSYS_USB_DIEPINT_NAKINTRPT           0x00002000
  #define SYNOPSYS_USB_DIEPINT_NAKINTRPT_SHIFT     13

#define SYNOPSYS_USB_DIEPTSIZE_ADDR(ridx)            (0x00000910 + (ridx) * 32)
#define SYNOPSYS_USB_DIEPTSIZE_COUNT                 7
#define SYNOPSYS_USB_DIEPTSIZE_MASK                  0x7fffffff
/** Indicates the transfer size in bytes for endpoint 0. The core interrupts the
   application only after it has exhausted the transfer size amount of data. The
   transfer size can be set to the maximum packet size of the endpoint, to be
   interrupted at the end of each packet. The core decrements this field every
   time a packet from the external memory is written to the TxFIFO. @multiple */
  #define SYNOPSYS_USB_DIEPTSIZE_XFERSIZE          0x0007ffff
  #define SYNOPSYS_USB_DIEPTSIZE_XFERSIZE_SHIFT    0
  #define SYNOPSYS_USB_DIEPTSIZE_XFERSIZE_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_DIEPTSIZE_XFERSIZE_SET(x, v) do { (x) = (((x) & ~0x7ffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_DIEPTSIZE_XFERSIZE_GET(x)   (((x) >> 0) & 0x7ffff)
/** Indicates the total number of USB packets that constitute the Transfer Size
   amount of data for endpoint 0. This field is decremented every time a packet
   (maximum size or short packet) is read from the TxFIFO. @multiple */
  #define SYNOPSYS_USB_DIEPTSIZE_PKTCNT            0x1ff80000
  #define SYNOPSYS_USB_DIEPTSIZE_PKTCNT_SHIFT      19
  #define SYNOPSYS_USB_DIEPTSIZE_PKTCNT_SHIFT_VAL(v) ((v) << 19)
  #define SYNOPSYS_USB_DIEPTSIZE_PKTCNT_SET(x, v)  do { (x) = (((x) & ~0x1ff80000) | ((v) << 19)); } while(0)
  #define SYNOPSYS_USB_DIEPTSIZE_PKTCNT_GET(x)     (((x) >> 19) & 0x3ff)
/** For periodic IN endpoints, this field indicates the number of packets that
   must be transmitted per frame on the USB. The core uses this field to
   calculate the data PID for isochronous IN endpoints. @multiple */
  #define SYNOPSYS_USB_DIEPTSIZE_MC                0x60000000
  #define SYNOPSYS_USB_DIEPTSIZE_MC_SHIFT          29
  #define SYNOPSYS_USB_DIEPTSIZE_MC_SHIFT_VAL(v)   ((v) << 29)
  #define SYNOPSYS_USB_DIEPTSIZE_MC_SET(x, v)      do { (x) = (((x) & ~0x60000000) | ((v) << 29)); } while(0)
  #define SYNOPSYS_USB_DIEPTSIZE_MC_GET(x)         (((x) >> 29) & 0x3)

#define SYNOPSYS_USB_DIEPDMAADDR_ADDR(ridx)          (0x00000914 + (ridx) * 32)
#define SYNOPSYS_USB_DIEPDMAADDR_COUNT               7
#define SYNOPSYS_USB_DIEPDMAADDR_MASK                0xffffffff
/** Holds the start address of the external memory for fetching endpoint data.
   For control endpoints, this field stores control OUT data packets as well as
   SETUP transaction data packets. When more than three SETUP packets are
   received back-to-back, the SETUP data packet in the memory is overwritten.
   This register is incremented on every AHB transaction. The application can
   give only a DWORD-aligned address. The data for this register field is stored
   in RAM. Thus, the reset value is undefined (X). @multiple */
  #define SYNOPSYS_USB_DIEPDMAADDR_VAL             0xffffffff
  #define SYNOPSYS_USB_DIEPDMAADDR_VAL_SHIFT       0
  #define SYNOPSYS_USB_DIEPDMAADDR_VAL_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_DIEPDMAADDR_VAL_SET(x, v)   do { (x) = (((x) & ~0xffffffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_DIEPDMAADDR_VAL_GET(x)      (((x) >> 0) & 0xffffffff)

#define SYNOPSYS_USB_DIEPTXFSTS_ADDR(ridx)           (0x00000918 + (ridx) * 32)
#define SYNOPSYS_USB_DIEPTXFSTS_COUNT                7
#define SYNOPSYS_USB_DIEPTXFSTS_MASK                 0x0000ffff
/** Indicates the amount of free space available in the Endpoint TxFIFO. Values
   are in terms of 32-bit words. @multiple */
  #define SYNOPSYS_USB_DIEPTXFSTS_SPCAVAIL         0x0000ffff
  #define SYNOPSYS_USB_DIEPTXFSTS_SPCAVAIL_SHIFT   0
  #define SYNOPSYS_USB_DIEPTXFSTS_SPCAVAIL_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_DIEPTXFSTS_SPCAVAIL_SET(x, v) do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_DIEPTXFSTS_SPCAVAIL_GET(x)  (((x) >> 0) & 0xffff)

#define SYNOPSYS_USB_DOEPCTL_ADDR(ridx)              (0x00000b00 + (ridx) * 32)
#define SYNOPSYS_USB_DOEPCTL_COUNT                   7
#define SYNOPSYS_USB_DOEPCTL_MASK                    0xfc3f87ff
/** The application must program this field with the maximum packet size for the
   current logical endpoint. This value is in bytes. @multiple */
  #define SYNOPSYS_USB_DOEPCTL_MPS                 0x000007ff
  #define SYNOPSYS_USB_DOEPCTL_MPS_SHIFT           0
  #define SYNOPSYS_USB_DOEPCTL_MPS_SHIFT_VAL(v)    ((v) << 0)
  #define SYNOPSYS_USB_DOEPCTL_MPS_SET(x, v)       do { (x) = (((x) & ~0x7ff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_DOEPCTL_MPS_GET(x)          (((x) >> 0) & 0x7ff)
/** Indicates whether this endpoint is active in the current configuration and
   interface. The core clears this bit for all endpoints after detecting a USB
   reset. After receiving the SetConfiguration and SetInterface commands, the
   application must program endpoint registers accordingly and set this bit.
   @multiple */
  #define SYNOPSYS_USB_DOEPCTL_USBACTEP            0x00008000
  #define SYNOPSYS_USB_DOEPCTL_USBACTEP_SHIFT      15
/** For interrupt/bulk endpoints: Contains the PID of the packet to be received
   or transmitted on this endpoint. The application must program the PID of the
   first packet to be received or transmitted on this endpoint, after the
   endpoint is activated. The application use the SETD1PIDOF and SETD0PIDEF
   fields of this register to program either DATA0 or DATA1 PID. For isochronous
   endpoints: Indicates the frame number in which the core transmits/receives
   isochronous data for this endpoint. The application must program the even/odd
   frame number in which it intends to transmit/receive isochronous data for this
   endpoint using the SETD1PIDOF and SETD0PIDEF fields in this register.
   @multiple */
  #define SYNOPSYS_USB_DOEPCTL_DPIDEOF             0x00010000
  #define SYNOPSYS_USB_DOEPCTL_DPIDEOF_SHIFT       16
  #define SYNOPSYS_USB_DOEPCTL_DPIDEOF_SHIFT_VAL(v) ((SYNOPSYS_USB_DOEPCTL_DPIDEOF_##v) << 16)
  #define SYNOPSYS_USB_DOEPCTL_DPIDEOF_SET(x, v)   do { (x) = (((x) & ~0x10000) | ((SYNOPSYS_USB_DOEPCTL_DPIDEOF_##v) << 16)); } while(0)
  #define SYNOPSYS_USB_DOEPCTL_DPIDEOF_SETVAL(x, v) do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define SYNOPSYS_USB_DOEPCTL_DPIDEOF_GET(x)      (((x) >> 16) & 0x1)
    #define SYNOPSYS_USB_DOEPCTL_DPIDEOF_EVEN        0x00000000
    #define SYNOPSYS_USB_DOEPCTL_DPIDEOF_ODD         0x00000001
/** When this bit is 0 the core is transmitting non-NAK handshakes based on the
   FIFO status. When this bit is 1 the core is transmitting NAK handshakes on
   this endpoint. When this bit is set, either by the application or core, the
   core stops transmitting data, even if there is data available in the TxFIFO.
   Irrespective of this bit's setting, the core always responds to SETUP data
   packets with an ACK handshake. @multiple */
  #define SYNOPSYS_USB_DOEPCTL_NAKSTS              0x00020000
  #define SYNOPSYS_USB_DOEPCTL_NAKSTS_SHIFT        17
/** This is the transfer type supported by this logical endpoint. @multiple */
  #define SYNOPSYS_USB_DOEPCTL_ETYPE               0x000c0000
  #define SYNOPSYS_USB_DOEPCTL_ETYPE_SHIFT         18
  #define SYNOPSYS_USB_DOEPCTL_ETYPE_SHIFT_VAL(v)  ((SYNOPSYS_USB_DOEPCTL_ETYPE_##v) << 18)
  #define SYNOPSYS_USB_DOEPCTL_ETYPE_SET(x, v)     do { (x) = (((x) & ~0xc0000) | ((SYNOPSYS_USB_DOEPCTL_ETYPE_##v) << 18)); } while(0)
  #define SYNOPSYS_USB_DOEPCTL_ETYPE_SETVAL(x, v)  do { (x) = (((x) & ~0xc0000) | ((v) << 18)); } while(0)
  #define SYNOPSYS_USB_DOEPCTL_ETYPE_GET(x)        (((x) >> 18) & 0x3)
    #define SYNOPSYS_USB_DOEPCTL_ETYPE_CONTROL       0x00000000
    #define SYNOPSYS_USB_DOEPCTL_ETYPE_ISO           0x00000001
    #define SYNOPSYS_USB_DOEPCTL_ETYPE_BULK          0x00000002
    #define SYNOPSYS_USB_DOEPCTL_ETYPE_INT           0x00000003
/** This bit configures the endpoint to Snoop mode. In Snoop mode, the core does
   not check the correctness of OUT packets before transferring them to
   application memory. @multiple */
  #define SYNOPSYS_USB_DOEPCTL_SNP                 0x00100000
  #define SYNOPSYS_USB_DOEPCTL_SNP_SHIFT           20
/** For non-control, non-isochronous endpoints: The application sets this bit to
   stall all tokens from the USB host to this endpoint. If a NAK bit, Global
   Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL
   bit takes priority. Only the application can clear this bit, never the core.
   For control endpoints: The application can only set this bit, and the core
   clears it, when a SETUP token is received for this endpoint. If a NAK bit,
   Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the
   STALL bit takes priority. Irrespective of this bit's setting, the core always
   responds to SETUP data packets with an ACK handshake. @multiple */
  #define SYNOPSYS_USB_DOEPCTL_STALL               0x00200000
  #define SYNOPSYS_USB_DOEPCTL_STALL_SHIFT         21
/** A write to this bit clears the NAK bit for the endpoint. @multiple */
  #define SYNOPSYS_USB_DOEPCTL_CNAK                0x04000000
  #define SYNOPSYS_USB_DOEPCTL_CNAK_SHIFT          26
/** A write to this bit sets the NAK bit for the endpoint. Using this bit, the
   application can control the transmission of NAK handshakes on an endpoint. The
   core can also set this bit for an endpoint after a SETUP packet is received on
   that endpoint. @multiple */
  #define SYNOPSYS_USB_DOEPCTL_SNAK                0x08000000
  #define SYNOPSYS_USB_DOEPCTL_SNAK_SHIFT          27
/** For bulk and interrupt endpoints writing this field sets the Endpoint Data
   PID / Even or Odd Frame (DPIDEOF) field in this register to DATA0EVEN. For
   isochronous endpoints writing this field sets the Endpoint Data PID / Even or
   Odd Frame (DPIDEOF) field to odd (DATA0EVEN). @multiple */
  #define SYNOPSYS_USB_DOEPCTL_SETD0PIDEF          0x10000000
  #define SYNOPSYS_USB_DOEPCTL_SETD0PIDEF_SHIFT    28
/** For bulk and interrupt endpoints writing this field sets the Endpoint Data
   PID / Even or Odd Frame (DPIDEOF) field in this register to DATA1ODD. For
   isochronous endpoints writing this field sets the Endpoint Data PID / Even or
   Odd Frame (DPIDEOF) field to odd (DATA1ODD). @multiple */
  #define SYNOPSYS_USB_DOEPCTL_SETD1PIDOF          0x20000000
  #define SYNOPSYS_USB_DOEPCTL_SETD1PIDOF_SHIFT    29
/** The application sets this bit to stop transmitting/receiving data on an
   endpoint, even before the transfer for that endpoint is complete. The
   application must wait for the Endpoint Disabled interrupt before treating the
   endpoint as disabled. The core clears this bit before setting the Endpoint
   Disabled interrupt. The application must set this bit only if Endpoint Enable
   is already set for this endpoint. @multiple */
  #define SYNOPSYS_USB_DOEPCTL_EPDIS               0x40000000
  #define SYNOPSYS_USB_DOEPCTL_EPDIS_SHIFT         30
/** In DMA mode this bit indicates that the application has allocated the memory
   to start receiving data from the USB. The core clears this bit before setting
   any of the following interrupts on this endpoint: SETUP Phase Done, Endpoint
   Disabled, Transfer Completed. In DMA mode, this bit must be set for the core
   to transfer SETUP data packets into memory. @multiple */
  #define SYNOPSYS_USB_DOEPCTL_EPENA               0x80000000
  #define SYNOPSYS_USB_DOEPCTL_EPENA_SHIFT         31

#define SYNOPSYS_USB_DOEPINT_ADDR(ridx)              (0x00000b08 + (ridx) * 32)
#define SYNOPSYS_USB_DOEPINT_COUNT                   7
#define SYNOPSYS_USB_DOEPINT_MASK                    0x0000385f
/** This field indicates that the programmed transfer is complete on the AHB as
   well as on the USB, for this endpoint. @multiple */
  #define SYNOPSYS_USB_DOEPINT_XFERCOMPL           0x00000001
  #define SYNOPSYS_USB_DOEPINT_XFERCOMPL_SHIFT     0
/** This bit indicates that the endpoint is disabled per the application's
   request. @multiple */
  #define SYNOPSYS_USB_DOEPINT_EPDISBLD            0x00000002
  #define SYNOPSYS_USB_DOEPINT_EPDISBLD_SHIFT      1
/** This is generated in DMA mode when there is an AHB error during an AHB
   read/write. The application can read the corresponding endpoint DMA address
   register to get the error address. @multiple */
  #define SYNOPSYS_USB_DOEPINT_AHBERR              0x00000004
  #define SYNOPSYS_USB_DOEPINT_AHBERR_SHIFT        2
/** Applies to control OUT endpoints only. Indicates that the SETUP phase for the
   control endpoint is complete and no more back- to-back SETUP packets were
   received for the current control transfer. On this interrupt, the application
   can decode the received SETUP data packet. @multiple */
  #define SYNOPSYS_USB_DOEPINT_SETUP               0x00000008
  #define SYNOPSYS_USB_DOEPINT_SETUP_SHIFT         3
/** Applies only to control OUT endpoints. Indicates that an OUT token was
   received when the endpoint was not yet enabled. This interrupt is asserted on
   the endpoint for which the OUT token was received. @multiple */
  #define SYNOPSYS_USB_DOEPINT_OUTTKNEPDIS         0x00000010
  #define SYNOPSYS_USB_DOEPINT_OUTTKNEPDIS_SHIFT   4
/** Applies to Control OUT endpoints only. This bit indicates that the core has
   received more than three back-to-back SETUP packets for this particular
   endpoint. @multiple */
  #define SYNOPSYS_USB_DOEPINT_BACK2BACKSETUP      0x00000040
  #define SYNOPSYS_USB_DOEPINT_BACK2BACKSETUP_SHIFT 6
/** This bit indicates to the application that an ISO OUT packet has been
   dropped. This bit does not have an associated mask bit and does not generate
   an interrupt. @multiple */
  #define SYNOPSYS_USB_DOEPINT_PKTDRPSTS           0x00000800
  #define SYNOPSYS_USB_DOEPINT_PKTDRPSTS_SHIFT     11
/** The core generates this interrupt when babble is received for the endpoint.
   @multiple */
  #define SYNOPSYS_USB_DOEPINT_BBLERR              0x00001000
  #define SYNOPSYS_USB_DOEPINT_BBLERR_SHIFT        12
/** The core generates this interrupt when a NAK is transmitted or received by
   the device. In case of isochronous IN endpoints the interrupt gets generated
   when a zero length packet is transmitted due to un-availability of data in the
   TXFifo. @multiple */
  #define SYNOPSYS_USB_DOEPINT_NAKINTRPT           0x00002000
  #define SYNOPSYS_USB_DOEPINT_NAKINTRPT_SHIFT     13

#define SYNOPSYS_USB_DOEPTSIZE_ADDR(ridx)            (0x00000b10 + (ridx) * 32)
#define SYNOPSYS_USB_DOEPTSIZE_COUNT                 7
#define SYNOPSYS_USB_DOEPTSIZE_MASK                  0x7fffffff
/** Indicates the transfer size in bytes for endpoint 0. The core interrupts the
   application only after it has exhausted the transfer size amount of data. The
   transfer size can be set to the maximum packet size of the endpoint, to be
   interrupted at the end of each packet. The core decrements this field every
   time a packet from the external memory is written to the TxFIFO. @multiple */
  #define SYNOPSYS_USB_DOEPTSIZE_XFERSIZE          0x0007ffff
  #define SYNOPSYS_USB_DOEPTSIZE_XFERSIZE_SHIFT    0
  #define SYNOPSYS_USB_DOEPTSIZE_XFERSIZE_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_DOEPTSIZE_XFERSIZE_SET(x, v) do { (x) = (((x) & ~0x7ffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_DOEPTSIZE_XFERSIZE_GET(x)   (((x) >> 0) & 0x7ffff)
/** This field is decremented to zero after a packet is written into the RxFIFO.
   @multiple */
  #define SYNOPSYS_USB_DOEPTSIZE_PKTCNT            0x1ff80000
  #define SYNOPSYS_USB_DOEPTSIZE_PKTCNT_SHIFT      19
  #define SYNOPSYS_USB_DOEPTSIZE_PKTCNT_SHIFT_VAL(v) ((v) << 19)
  #define SYNOPSYS_USB_DOEPTSIZE_PKTCNT_SET(x, v)  do { (x) = (((x) & ~0x1ff80000) | ((v) << 19)); } while(0)
  #define SYNOPSYS_USB_DOEPTSIZE_PKTCNT_GET(x)     (((x) >> 19) & 0x3ff)
/** For isochronous OUT endpoints: This is the data PID received in the last
   packet for this endpoint. For control OUT Endpoints: This field specifies the
   number of back-to-back SETUP data packets the endpoint can receive. @multiple
   */
  #define SYNOPSYS_USB_DOEPTSIZE_RXDPIDSUPCNT      0x60000000
  #define SYNOPSYS_USB_DOEPTSIZE_RXDPIDSUPCNT_SHIFT 29
  #define SYNOPSYS_USB_DOEPTSIZE_RXDPIDSUPCNT_SHIFT_VAL(v) ((v) << 29)
  #define SYNOPSYS_USB_DOEPTSIZE_RXDPIDSUPCNT_SET(x, v) do { (x) = (((x) & ~0x60000000) | ((v) << 29)); } while(0)
  #define SYNOPSYS_USB_DOEPTSIZE_RXDPIDSUPCNT_GET(x) (((x) >> 29) & 0x3)

#define SYNOPSYS_USB_DOEPDMAADDR_ADDR(ridx)          (0x00000b14 + (ridx) * 32)
#define SYNOPSYS_USB_DOEPDMAADDR_COUNT               7
#define SYNOPSYS_USB_DOEPDMAADDR_MASK                0xffffffff
/** Holds the start address of the external memory for fetching endpoint data.
   For control endpoints, this field stores control OUT data packets as well as
   SETUP transaction data packets. When more than three SETUP packets are
   received back-to-back, the SETUP data packet in the memory is overwritten.
   This register is incremented on every AHB transaction. The application can
   give only a DWORD-aligned address. The data for this register field is stored
   in RAM. Thus, the reset value is undefined (X). @multiple */
  #define SYNOPSYS_USB_DOEPDMAADDR_VAL             0xffffffff
  #define SYNOPSYS_USB_DOEPDMAADDR_VAL_SHIFT       0
  #define SYNOPSYS_USB_DOEPDMAADDR_VAL_SHIFT_VAL(v) ((v) << 0)
  #define SYNOPSYS_USB_DOEPDMAADDR_VAL_SET(x, v)   do { (x) = (((x) & ~0xffffffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_DOEPDMAADDR_VAL_GET(x)      (((x) >> 0) & 0xffffffff)

#define SYNOPSYS_USB_PCGCCTL_ADDR                    0x00000e00
#define SYNOPSYS_USB_PCGCCTL_MASK                    0x0000014f
/** The application sets this bit to stop the PHY clock when the USB is
   suspended, the session is not valid, or the device is disconnected. The
   application clears this bit when the USB is resumed or a new session starts.
   @multiple */
  #define SYNOPSYS_USB_PCGCCTL_STOPPCLK            0x00000001
  #define SYNOPSYS_USB_PCGCCTL_STOPPCLK_SHIFT      0
/** The application sets this bit to gate the clock (HCLK) to modules other than
   the AHB Slave and Master and wakeup logic when the USB is suspended or the
   session is not valid. The application clears this bit when the USB is resumed
   or a new session starts. @multiple */
  #define SYNOPSYS_USB_PCGCCTL_GATEHCLK            0x00000002
  #define SYNOPSYS_USB_PCGCCTL_GATEHCLK_SHIFT      1
/** The application sets this bit before the power is turned off to clamp the
   signals between the power-on modules and the power-off modules of the USB
   core. The application clears the bit to disable the clamping. @multiple */
  #define SYNOPSYS_USB_PCGCCTL_PWRCLMP             0x00000004
  #define SYNOPSYS_USB_PCGCCTL_PWRCLMP_SHIFT       2
/** The application sets this bit to reset the part of the USB that is powered
   down during EM2. The application clears this bit to release reset after an
   waking up from EM2 when the PHY clock is back at 48/6 MHz. Accessing core
   registers is possible only when this bit is set to 0. @multiple */
  #define SYNOPSYS_USB_PCGCCTL_RSTPDWNMODULE       0x00000008
  #define SYNOPSYS_USB_PCGCCTL_RSTPDWNMODULE_SHIFT 3
/** Indicates that the PHY is in Sleep State. @multiple */
  #define SYNOPSYS_USB_PCGCCTL_PHYSLEEP            0x00000040
  #define SYNOPSYS_USB_PCGCCTL_PHYSLEEP_SHIFT      6
/** When exiting EM2, this bit needs to be set in host mode before clamp is
   removed if the host needs to issue reset after suspend. If this bit is not
   set, then the host issues resume after suspend. This bit is not applicable in
   device mode and when EM2 is not used. @multiple */
  #define SYNOPSYS_USB_PCGCCTL_RESETAFTERSUSP      0x00000100
  #define SYNOPSYS_USB_PCGCCTL_RESETAFTERSUSP_SHIFT 8

#define SYNOPSYS_USB_FIFO_ADDR(ridx)                 (0x0003d000 + (ridx) * 4096)
#define SYNOPSYS_USB_FIFO_COUNT                      14
#define SYNOPSYS_USB_FIFO_MASK                       0xffffffff
/** This register, available in both Host and Device modes, is used to read or
   write the FIFO space for endpoint 0 or channel 0, in a given direction. If a
   host channel is of type IN, the FIFO can only be read on the channel.
   Similarly, if a host channel is of type OUT, the FIFO can only be written on
   the channel. @multiple */
  #define SYNOPSYS_USB_FIFO_DATA                   0xffffffff
  #define SYNOPSYS_USB_FIFO_DATA_SHIFT             0
  #define SYNOPSYS_USB_FIFO_DATA_SHIFT_VAL(v)      ((v) << 0)
  #define SYNOPSYS_USB_FIFO_DATA_SET(x, v)         do { (x) = (((x) & ~0xffffffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_FIFO_DATA_GET(x)            (((x) >> 0) & 0xffffffff)

#define SYNOPSYS_USB_FIFORAM_ADDR                    0x0005c000
#define SYNOPSYS_USB_FIFORAM_MASK                    0xffffffff
/** Direct Access to Data FIFO RAM for Debugging (2 KB) @multiple */
  #define SYNOPSYS_USB_FIFORAM_DATA                0xffffffff
  #define SYNOPSYS_USB_FIFORAM_DATA_SHIFT          0
  #define SYNOPSYS_USB_FIFORAM_DATA_SHIFT_VAL(v)   ((v) << 0)
  #define SYNOPSYS_USB_FIFORAM_DATA_SET(x, v)      do { (x) = (((x) & ~0xffffffff) | ((v) << 0)); } while(0)
  #define SYNOPSYS_USB_FIFORAM_DATA_GET(x)         (((x) >> 0) & 0xffffffff)

#endif

