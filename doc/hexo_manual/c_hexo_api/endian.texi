

Hexo provided a set of inline functions and macros to perform bytes
swaping, endian dependent and non aligned memory access. These
features are available through the @code{<hexo/endian.h>} header file.

@strong{These functions and macros are properly designed to use
processor specific instructions when available while generating
constant values when used with compilation time constants.}

@menu
* Word access::                         Access to memory with bytes swaping
* Bitfield decalaration::               Declare bitfields in an endian independent manner
* Non-aligned memory access::           Access to non-aligned words in memory
* Addresses and values alignment::      Check and compute aligned values and addresses
@end menu

@node Word access, Bitfield decalaration, , Endian and alignment
@subsection Word access

The Hexo API includes some function to access words with a specific byte order.

The following functions can be used to perform unconditional bytes swaping:

@itemize
@item @code{static inline uint16_t endian_swap16(uint16_t x);}
@item @code{static inline uint32_t endian_swap32(uint32_t x);}
@item @code{static inline uint64_t endian_swap64(uint64_t x);}
@end itemize

The following macros can be used to access big or little endian words data:

@itemize
@item @code{endian_be16(x)}
@item @code{endian_be32(x)}
@item @code{endian_be64(x)}
@item @code{endian_le16(x)}
@item @code{endian_le32(x)}
@item @code{endian_le64(x)}
@end itemize

@node Bitfield decalaration, Non-aligned memory access, Word access, Endian and alignment
@subsection Bitfield decalaration

Bitfield can be declared trough the @code{ENDIAN_BITFIELD()} macro in the
direct (big endian) order. bit field declaration order will be swaped
on little endian machines. See example below:

@verbatim
struct my_data_s
{
  ENDIAN_BITFIELD(uint32_t   a:8,
                  uint32_t   b:8,
                  uint32_t   c:16
                 );

  ENDIAN_BITFIELD(uint32_t   d:16,
                  uint32_t   e:16
                 );
};
@end verbatim

@node Non-aligned memory access, Addresses and values alignment, Bitfield decalaration, Endian and alignment
@subsection Non-aligned memory access

Non aligned memory access can be performed with the following macros:

@itemize
@item @code{endian_16_na_load(address)}
@item @code{endian_32_na_load(address)}
@item @code{endian_64_na_load(address)}
@item @code{endian_16_na_store(address, value)}
@item @code{endian_32_na_store(address, value)}
@item @code{endian_64_na_store(address, value)}
@end itemize

Endian dependent non aligned memory access memory access can be
performed with the following macros:

@itemize
@item @code{endian_le16_na_load(address)}
@item @code{endian_le32_na_load(address)}
@item @code{endian_le64_na_load(address)}
@item @code{endian_le16_na_store(address, value)}
@item @code{endian_le32_na_store(address, value)}
@item @code{endian_le64_na_store(address, value)}
@item @code{endian_be16_na_load(address)}
@item @code{endian_be32_na_load(address)}
@item @code{endian_be64_na_load(address)}
@item @code{endian_be16_na_store(address, value)}
@item @code{endian_be32_na_store(address, value)}
@item @code{endian_be64_na_store(address, value)}
@end itemize

@node Addresses and values alignment,  , Non-aligned memory access, Endian and alignment
@subsection Addresses and values alignment

Value @code{x} can be checked for equality with a power of 2 with the
@code{ALIGN_ISPOWTWO(x)} macro.

Value @code{x} can be checked for alignment on a boundary @code{b}
with the @code{IS_ALIGNED(x, b)} macro provided that @code{b} is a
power of 2.

Values and addresses can be aligned on the lower or upper boundaries
with the @code{ALIGN_VALUE_UP(x, b)}, @code{ALIGN_VALUE_LOW(x, b)},
@code{ALIGN_ADDRESS_UP(x, b)} and @code{ALIGN_ADDRESS_LOW(x, b)}
macros provided that @code{b} is a power of 2.

