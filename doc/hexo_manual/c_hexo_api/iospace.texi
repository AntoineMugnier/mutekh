
Some processors use specific address space to access peripherals 
while others use standard memory access. Hexo provides a small set
of functions to handle this difference.

The first set of function can be used to perform memory access to peripherals:

@findex cpu_mem_write_*
@findex cpu_mem_read_*
@itemize
@item @code{static void cpu_mem_write_8(uintptr_t addr, uint8_t data);}
@item @code{static uint8_t cpu_mem_read_8(uintptr_t addr);}
@item @code{static void cpu_mem_write_16(uintptr_t addr, uint8_t data);}
@item @code{static uint8_t cpu_mem_read_16(uintptr_t addr);}
@item @code{static void cpu_mem_write_32(uintptr_t addr, uint8_t data);}
@item @code{static uint8_t cpu_mem_read_32(uintptr_t addr);}
@item @code{static void cpu_mem_write_64(uintptr_t addr, uint8_t data);}
@item @code{static uint8_t cpu_mem_read_64(uintptr_t addr);}
@end itemize

A second set of function is provided for processor which relies on
specific address space to access peripherals:

@findex cpu_io_write_*
@findex cpu_io_read_*
@itemize
@item @code{static void cpu_io_write_8(uintptr_t addr, uint8_t data);}
@item @code{static uint8_t cpu_io_read_8(uintptr_t addr);}
@item @code{static void cpu_io_write_16(uintptr_t addr, uint8_t data);}
@item @code{static uint8_t cpu_io_read_16(uintptr_t addr);}
@item @code{static void cpu_io_write_32(uintptr_t addr, uint8_t data);}
@item @code{static uint8_t cpu_io_read_32(uintptr_t addr);}
@item @code{static void cpu_io_write_64(uintptr_t addr, uint8_t data);}
@item @code{static uint8_t cpu_io_read_64(uintptr_t addr);}
@end itemize

