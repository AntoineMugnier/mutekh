
@menu
* General purpose memory allocation::           Allocate and free memory blocks
* Memory regions::                              Control allocated blocks placement
@end menu

@node General purpose memory allocation, Memory regions, Memory allocation
@subsection General purpose memory allocation

@findex malloc
The general purpose memory allocation interface provided by Hexo allows
allocation of memory blocks for common programming tasks. These
features are similar to the @code{malloc()} functions family with
optional memory region selection mechanism. Memory allocation and
freeing can be perform with the following functions:

@itemize

@findex mem_alloc
@item @code{void *mem_alloc(size_t size, struct mem_alloc_region_s *region)}
      allocates a block of memory of the requested size in the specified memory
      region. A set of macro must be used to allocate memory on standard region.
      This function is equivalent to @code{malloc()} when called with the
      @code{(mem_scope_default)} macro as second parameters. @xref{Memory regions} for details.

@findex mem_free
@item @code{void mem_free(void *ptr)} frees a block of memory.

@findex mem_alloc_getsize
@item @code{size_t mem_alloc_getsize(void *ptr)} returns the size of
      an allocated memory block.

@findex mem_alloc_set_default
@item @code{void mem_alloc_set_default(struct mem_alloc_region_s *region)} changes
      the default memory allocation scope. @xref{Memory regions} for details.

@findex calloc
@findex free
@findex realloc
Standards functions @code{calloc()}, @code{malloc()},  @code{free()} and 
@code{realloc()} functions found in @code{<stdlib.h>} use the above functions.

@end itemize

@node Memory regions,  , General purpose memory allocation, Memory allocation
@subsection Memory regions

Hexo allows control of allocated memory blocks placement in
memory. Memory address space is split in regions, this allows placement
of allocated memory blocks in different location like global system
memory area, cpu local memory area, ... Available regions may vary
depending on current platform and Hexo configuration.

A set of macros are defined to allow placement of allocated memory
blocks in the right region. Each macro defined a different memory
scope. Macro definitions may change to allow transparent fall back to
other memory region when the requested scope is not available.

Here is a list of default memory scope macros:

@itemize
@vindex (mem_scope_sys)TEM
@item The @code{(mem_scope_sys)TEM} macro must be used when memory block must be
      accessed from all processors in the system.

@vindex (mem_scope_cluster)
@item The @code{(mem_scope_cluster)} macro must be used when memory block will be
      accessed from all processors of the current cluster only. This is
      equivalent to @code{(mem_scope_sys)TEM} when cluster support is disabled.

@vindex (mem_scope_cpu)
@item The @code{(mem_scope_cpu)} macro must be used when memory block will be
      accessed from the current processor only. This is equivalent to
      @code{(mem_scope_sys)TEM} when multiprocessor support is disabled.

@vindex (mem_scope_context)
@item The @code{(mem_scope_context)} macro must be used when memory block will be
      accessed from the current running context only. This may be equivalent to
      @code{(mem_scope_cpu)}, @code{(mem_scope_cluster)} or @code{(mem_scope_sys)TEM}
      depending on cache coherency mechanism and scheduler context migration
      configuration.

@vindex (mem_scope_default)
@item The @code{(mem_scope_default)} macro selects the default memory scope. The
      default allocation scope can be changed with the
      @code{void mem_alloc_set_default(struct mem_alloc_region_s *region)} function.
      This allow control of memory allocation policy in generic library code.

@end itemize

