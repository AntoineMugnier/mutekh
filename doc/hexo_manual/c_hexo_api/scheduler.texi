
Hexo provides an execution context scheduler which can be used to
write higher level thread, task, process... related APIs.

Context scheduler functions are available in the
@code{<mutek/scheduler.h>} header file.

The Hexo scheduler handles @code{struct sched_context_s}
objects. These objects can be put in the main running queue or can be
chained on any existing wait queue object. Hexo provides the idle
execution context and is responsible for running the main scheduler
loop.

The following functions manage the Hexo scheduler:

@itemize

@findex sched_global_init
@item @code{void sched_global_init(void)} function performs scheduler global initialization.
This function must be called once.

@findex sched_cpu_init
@item @code{void sched_cpu_init(void)} function performs scheduler processor local initialization.
This function must be called for each processor.

@findex sched_lock
@item @code{void sched_lock()} function locks the scheduler running queue.

@findex sched_unlock
@item @code{void sched_unlock()} function releases the scheduler running queue.

@end itemize

The following functions manage scheduler execution contexts:

@itemize

@tindex struct sched_context_s

@findex sched_context_init
@item @code{void sched_context_init(struct sched_context_s *sched_ctx)}
function initializes the scheduler context object. The scheduler
context object contains an execution context (@code{struct context_s})
object which must intialized before.

@findex sched_context_start
@item @code{void sched_context_start(struct sched_context_s *sched_ctx)} function
enqueues scheduler context for execution.

@findex sched_context_exit
@item @code{void sched_context_exit()} function jump to next context
without saving current context. current context is lost.

@findex sched_context_stop
@item @code{void sched_context_stop()} function switchs to next context without
pushing current context back in the running queue.

@findex sched_context_switch
@item @code{void sched_context_switch()} function switches to the next
context in the scheduler running queue.

@end itemize

@tindex sched_queue_root_t

The following functions manage scheduler wait queues:

@itemize
@findex sched_queue_init
@item @code{error_t sched_queue_init(sched_queue_root_t *queue)} function
initializes a wait queue object.

@findex sched_queue_destroy
@item @code{void sched_queue_destroy(sched_queue_root_t *queue)} function
destroys a wait queue object.

@findex sched_queue_lock
@item @code{sched_queue_lock(sched_queue_root_t *queue)} function locks a
context wait queue.

@findex sched_queue_unlock
@item @code{sched_queue_unlock(sched_queue_root_t *queue)} function release a
context wait queue.

@findex sched_wait_unlock
@item @code{void sched_wait_unlock(sched_queue_root_t *queue)} function
adds current context on the wait queue, release queue lock and switch to
next context without pushing current context back in the running queue.

@findex sched_wake
@item @code{struct sched_context_s *sched_wake(sched_queue_root_t *queue)} function
wakes the first context found on wait queue. This function returns a pointer to the
awakened context object.

@end itemize

@subsubheading Example

The program below creates 3 execution contexts managed by the
scheduler and put them in the run queue. Every context execute the
@code{a_entry} function when started. This function print a string
passed as context entry argument and let the scheduler switch to the
next context available in run queue.

The @code{main} function must return to let Hexo start contexts
execution on the current processor. Contexts execution may start
earlier if other processors are present.

@verbatim
#include <hexo/context.h>
#include <mutek/scheduler.h>

struct sched_context_s a, b, c;

static CONTEXT_ENTRY(a_entry)
{
  sched_unlock();

  while (1)
    {
      puts(param);
      sched_context_switch();
    }
}

int main()
{
  CPU_INTERRUPT_SAVESTATE_DISABLE;
  context_init(&a.context, 256, a_entry, "A");
  sched_context_init(&a);
  sched_context_start(&a);

  context_init(&b.context, 256, a_entry, "B");
  sched_context_init(&b);
  sched_context_start(&b);

  context_init(&c.context, 256, a_entry, "C");
  sched_context_init(&c);
  sched_context_start(&c);
  CPU_INTERRUPT_RESTORESTATE;
}
@end verbatim

