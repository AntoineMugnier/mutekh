\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename hexo_manual.info
@settitle Hexo manual version 1.0
@c %**end of header

@copying
This manual is for Hexo an exokernel for heterogeneous multiprocessor
systems, version 1.0.

Copyright @copyright{} 2006 Alexandre Becoulet.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being "A GNU Manual,"
and with the Back-Cover Texts as in (a) below.  A copy of the license
is included in the section entitled "GNU Free Documentation
License."

(a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the
Free Software Foundation raise funds for GNU development."
@end quotation
@end copying

@titlepage
@title MutekH pthreads
@subtitle Posix thread over Hexo implementation overview
@author Alexandre Becoulet - UPMC / LIP6

@c @page
@c @vskip 0pt plus 1filll
@c @insertcopying
@end titlepage

@contents
@paragraphindent none

@ifnottex
@node Top
@top Hexo

@insertcopying
@end ifnottex


@unnumbered Preamble

This document gives an overview of the use of Hexo scheduler
primitives through MutekH POSIX thread library implementation. This
document is not a comprehensive guide POSIX thread library. The reader
should first refer to the Hexo manual and to the MutekH @code{libpthread}
source code.

This pthread implementation provides POSIX threads primitives for super
user mode applications.

@chapter Hexo scheduler API

Hexo provides an execution context scheduler which can be used to
write higher level thread, task, process... related APIs.

Context scheduler functions are available in the
@code{<hexo/scheduler.h>} header file.

@section Scheduler contexts

The Hexo scheduler handle execution contexts. An execution context is
used to store processor register values. Processor state can be saved
and restored to switch between contexts.

All runnable contexts are stored in the main running queue. Every
context can be put in or removed from this running queue.

Hexo scheduler API provides all functions related to context
initialization (@code{sched_context_init()}), switching
(@code{sched_context_switch()}), execution scheduling
(@code{sched_context_start()} and @code{sched_context_stop()}).

@subsubheading Example

The following example program initializes 2 scheduler contexts and
puts them in the running queue. Each context executes the @code{entry}
function which print a string and switch to the next runnable context.

@smallexample
@verbatim
#include <hexo/context.h>
#include <hexo/scheduler.h>

struct sched_context_s a, b;

static CONTEXT_ENTRY(entry)
{
  sched_unlock();

  while (1)
    {
      puts(param);
      sched_context_switch();
    }
}

int main()
{
  CPU_INTERRUPT_SAVESTATE_DISABLE;
  context_init(&a.context, 256, entry, "A");
  sched_context_init(&a);
  sched_context_start(&a);

  context_init(&b.context, 256, entry, "B");
  sched_context_init(&b);
  sched_context_start(&b);
  CPU_INTERRUPT_RESTORESTATE;
}
@end verbatim
@end smallexample

@node Wait queues
@section Wait queues

All context not ready for execution can be put in wait queues. Wait
queues can be declared using the @code{sched_queue_root_t} object
type.

Hexo scheduler API provides functions to put a context in a wait queue
(@code{sched_wait_unlock()}) and to wake a context from a wait
queue (@code{sched_wake()}). Hexo wait queues can be used to write all higher level
synchronization primitives.

Hexo wait queues are protected by built-in spin locks. Functions are
provided to ensure atomic access to wait queues
(@code{sched_queue_wrlock} and @code{sched_queue_unlock}).

Most scheduler functions must be called with interrupts disabled.

@subsubheading Example

The following example shows a simple implementation of standard C
semaphore using Hexo scheduler wait queues.

@smallexample
@verbatim
typedef struct         sem_s
{
  /* sem counter */
  char                 count;
  /* blocked threads wait queue */
  sched_queue_root_t   wait;
}                      sem_t;

error_t sem_init(sem_t *sem, bool_t pshared, char value)
{
  sem->count = value;
  return sched_queue_init(&sem->wait);
}

error_t sem_destroy(sem_t *sem)
{
  sched_queue_destroy(&sem->wait);

  return 0;
}

error_t sem_wait(sem_t *sem)
{
  CPU_INTERRUPT_SAVESTATE_DISABLE;
  sched_queue_wrlock(&sem->wait);

  if (sem->count <= 0)
    {
      /* add current thread in sem wait
       * queue and release queue lock and switch */
      sched_wait_unlock(&sem->wait);
    }
  else
    {
      sem->count--;
      sched_queue_unlock(&sem->wait);
    }

  CPU_INTERRUPT_RESTORESTATE;

  return 0;
}

error_t sem_post(sem_t *sem)
{
  CPU_INTERRUPT_SAVESTATE_DISABLE;
  sched_queue_wrlock(&sem->wait);

  /* try to wake a waiting context,
   * increment counter if none available */ 
  if (sched_wake(&sem->wait) == NULL)
    sem->count++;

  sched_queue_unlock(&sem->wait);
  CPU_INTERRUPT_RESTORESTATE;

  return 0;
}
@end verbatim
@end smallexample

@chapter Pthread implementation

The MutekH pthread implementation is based on Hexo scheduler API. All
pthread sources are located in the @code{libpthread} directory.

@section Threads management

The pthread thread object structure contains a scheduler context
object. Other pthread specific features related fields won't be
described here.

The pthread structure defined in @code{pthread.h} contains a scheduler
context object:

@smallexample
@verbatim
struct pthread_s
{
  struct sched_context_s        sched_ctx;

  /** start routine argument */
  void                          *arg;
  /** start routine pointer */
  pthread_start_routine_t       *start_routine;

  ...

};
@end verbatim
@end smallexample

The thread creation function allocates the thread object, initializes
execution context and scheduler context. The newly allocated thread is
then put in the execution queue:

@smallexample
@verbatim
error_t
pthread_create(pthread_t *thread_, const pthread_attr_t *attr,
               pthread_start_routine_t *start_routine, void *arg)
{
  struct pthread_s      *thread;

  thread = malloc(sizeof (struct pthread_s));

  /* setup context for new thread */
  context_init(&thread->sched_ctx.context, CONFIG_PTHREAD_STACK_SIZE,
               pthread_context_entry, thread);

  sched_context_init(&thread->sched_ctx);
  thread->sched_ctx.private = thread;

  /* pthread specific features initialization */
  ...

  thread->start_routine = start_routine;
  thread->arg = arg;

  *thread_ = thread;

  /* add new thread to runnable threads list */
  CPU_INTERRUPT_SAVESTATE_DISABLE;
  sched_context_start(&thread->sched_ctx);
  CPU_INTERRUPT_RESTORESTATE;

  return 0;
}
@end verbatim
@end smallexample

The @code{pthread_context_entry()} function is used as context entry
point, the @code{void *} parameter to this function points to the
pthread object. This function will be called on context first execution.

The pthread start routine will be called at end of the context entry
function. A few mandatory initialization are performed before starting
the pthread start routine. The current pthread pointer is first saved
in a context local variable. The scheduler lock must then be
released. Finally, interrupts are enabled before pthread user code
execution. The @code{pthread_exit()} function will be called if the
start routine returns.

@smallexample
@verbatim
static CONTEXT_ENTRY(pthread_context_entry)
{
  struct pthread_s      *thread = param;

  CONTEXT_LOCAL_SET(__pthread_current, thread);

  /* release lock acquired in previous sched_context_switch() call */
  sched_unlock();

  /* enable interrupts for current thread */
  cpu_interrupt_enable();

  /* call pthread_exit with return value if thread main functions returns */
  pthread_exit(thread->start_routine(thread->arg));
}
@end verbatim
@end smallexample

@section Synchronization primitives

All pthread synchronization primitives are implemented using the
@code{sched_queue_wrlock()}, @code{sched_wake()},
@code{sched_wait_unlock()} and @code{sched_queue_unlock()} functions
as shown in the standard semaphore code example (@xref{Wait queues}).

@subsubheading Example

The normal pthread mutex functions implementation is presented here as an
example.

@smallexample
@verbatim
typedef struct                          pthread_mutex_s
{
  /** mutex status */
  bool_t                                status;
  /** blocked threads wait queue */
  sched_queue_root_t                    wait;
}                                       pthread_mutex_t;
@end verbatim
@end smallexample

@smallexample
@verbatim
error_t pthread_mutex_lock(pthread_mutex_t *mutex)
{
  CPU_INTERRUPT_SAVESTATE_DISABLE;
  sched_queue_wrlock(&mutex->wait);

  /* check current mutex state */
  if (mutex->status)
    {
      /* add current thread in mutex wait queue */
      sched_wait_unlock(&mutex->wait);
    }
  else
    {
      /* mark mutex as used */
      mutex->status = 1;
      sched_queue_unlock(&mutex->wait);
    }

  CPU_INTERRUPT_RESTORESTATE;

  return 0;
}

error_t pthread_mutex_unlock(pthread_mutex_t *mutex)
{
  CPU_INTERRUPT_SAVESTATE_DISABLE;
  sched_queue_wrlock(&mutex->wait);

  if (!sched_wake(&mutex->wait))
    mutex->status = 0;

  sched_queue_unlock(&mutex->wait);
  CPU_INTERRUPT_RESTORESTATE;

  return 0;
}
@end verbatim
@end smallexample

@chapter Available pthread services

The following synchronization primitives are available:

@bye

