/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -o cdefs                                                              \
     -O /home/cerdan/Work/mutekh/arch/efm32/include/arch/efm32_dma_channel.h   \
     cdefs_use_reg_mask=1 cdefs_use_field_setval=1
*/

#ifndef _DMA_CHANNEL_BFGEN_DEFS_
#define _DMA_CHANNEL_BFGEN_DEFS_

#define DMA_CHANNEL_SRC_DATA_END_ADDR                0x00000000
#define DMA_CHANNEL_SRC_DATA_END_MASK                0xffffffff
/** Pointer to the end address of the source data @multiple */
  #define DMA_CHANNEL_SRC_DATA_END_ADD(v)          ((v) << 0)
  #define DMA_CHANNEL_SRC_DATA_END_ADD_SET(x, v)   do { (x) = (((x) & ~0xffffffff) | ((v) << 0)); } while(0)
  #define DMA_CHANNEL_SRC_DATA_END_ADD_GET(x)      (((x) >> 0) & 0xffffffff)

#define DMA_CHANNEL_DST_DATA_END_ADDR                0x00000004
#define DMA_CHANNEL_DST_DATA_END_MASK                0xffffffff
/** Pointer to the end address of the destination data @multiple */
  #define DMA_CHANNEL_DST_DATA_END_ADD(v)          ((v) << 0)
  #define DMA_CHANNEL_DST_DATA_END_ADD_SET(x, v)   do { (x) = (((x) & ~0xffffffff) | ((v) << 0)); } while(0)
  #define DMA_CHANNEL_DST_DATA_END_ADD_GET(x)      (((x) >> 0) & 0xffffffff)

#define DMA_CHANNEL_CFG_ADDR                         0x00000008
#define DMA_CHANNEL_CFG_MASK                         0xffffffff
/** The operating mode of the DMA cycle. @multiple */
  #define DMA_CHANNEL_CFG_CYCLE_CTR(v)             ((DMA_CHANNEL_CFG_CYCLE_CTR_##v) << 0)
  #define DMA_CHANNEL_CFG_CYCLE_CTR_SET(x, v)      do { (x) = (((x) & ~0x7) | ((DMA_CHANNEL_CFG_CYCLE_CTR_##v) << 0)); } while(0)
  #define DMA_CHANNEL_CFG_CYCLE_CTR_SETVAL(x, v)   do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define DMA_CHANNEL_CFG_CYCLE_CTR_GET(x)         (((x) >> 0) & 0x7)
    #define DMA_CHANNEL_CFG_CYCLE_CTR_STOP           0x00000000
    #define DMA_CHANNEL_CFG_CYCLE_CTR_BASIC          0x00000001
    #define DMA_CHANNEL_CFG_CYCLE_CTR_AUTOREQUEST    0x00000002
    #define DMA_CHANNEL_CFG_CYCLE_CTR_PINGPONG       0x00000003
    #define DMA_CHANNEL_CFG_CYCLE_CTR_MEM_SG_PRI     0x00000004
    #define DMA_CHANNEL_CFG_CYCLE_CTR_MEM_SG_ALT     0x00000005
    #define DMA_CHANNEL_CFG_CYCLE_CTR_PER_SG_PRI     0x00000006
    #define DMA_CHANNEL_CFG_CYCLE_CTR_PER_SG_ALT     0x00000007
/** Controls if the chnl_useburst_set [C] bit is set to a 1, when the controller
   is performing a peripheral scatter-gather and is completing a DMA cycle that
   uses the alternate data structure @multiple */
  #define DMA_CHANNEL_CFG_NEXT_USEBURST            0x00000008
/** Prior to the DMA cycle commencing, these bits represent the total number of
   DMA transfers that the DMA cycle contains. You must set these bits according
   to the size of DMA cycle that you require. The 10-bit value indicates the
   number of DMA transfers, minus one. @multiple */
  #define DMA_CHANNEL_CFG_N_MINUS_1(v)             ((v) << 4)
  #define DMA_CHANNEL_CFG_N_MINUS_1_SET(x, v)      do { (x) = (((x) & ~0x3ff0) | ((v) << 4)); } while(0)
  #define DMA_CHANNEL_CFG_N_MINUS_1_GET(x)         (((x) >> 4) & 0x3ff)
/** Set these bits to control how many DMA transfers can occur before the
   controller rearbitrates. @multiple */
  #define DMA_CHANNEL_CFG_R_POWER(v)               ((DMA_CHANNEL_CFG_R_POWER_##v) << 14)
  #define DMA_CHANNEL_CFG_R_POWER_SET(x, v)        do { (x) = (((x) & ~0x3c000) | ((DMA_CHANNEL_CFG_R_POWER_##v) << 14)); } while(0)
  #define DMA_CHANNEL_CFG_R_POWER_SETVAL(x, v)     do { (x) = (((x) & ~0x3c000) | ((v) << 14)); } while(0)
  #define DMA_CHANNEL_CFG_R_POWER_GET(x)           (((x) >> 14) & 0xf)
    #define DMA_CHANNEL_CFG_R_POWER_AFTER1           0x00000000
    #define DMA_CHANNEL_CFG_R_POWER_AFTER2           0x00000001
    #define DMA_CHANNEL_CFG_R_POWER_AFTER4           0x00000002
    #define DMA_CHANNEL_CFG_R_POWER_AFTER8           0x00000003
    #define DMA_CHANNEL_CFG_R_POWER_AFTER16          0x00000004
    #define DMA_CHANNEL_CFG_R_POWER_AFTER32          0x00000005
    #define DMA_CHANNEL_CFG_R_POWER_AFTER64          0x00000006
    #define DMA_CHANNEL_CFG_R_POWER_AFTER128         0x00000007
    #define DMA_CHANNEL_CFG_R_POWER_AFTER256         0x00000008
    #define DMA_CHANNEL_CFG_R_POWER_AFTER512         0x00000009
    #define DMA_CHANNEL_CFG_R_POWER_AFTER1024        0x0000000a
/** Set the bits to control the state of HPROT[3:1] when the controller reads the
   source data. @multiple */
  #define DMA_CHANNEL_CFG_SRC_PROT_CTRL(v)         ((v) << 18)
  #define DMA_CHANNEL_CFG_SRC_PROT_CTRL_SET(x, v)  do { (x) = (((x) & ~0x1c0000) | ((v) << 18)); } while(0)
  #define DMA_CHANNEL_CFG_SRC_PROT_CTRL_GET(x)     (((x) >> 18) & 0x7)
/** Set the bits to control the state of HPROT[3:1] when the controller writes
   the destination. @multiple */
  #define DMA_CHANNEL_CFG_DST_PROT_CTRL(v)         ((v) << 21)
  #define DMA_CHANNEL_CFG_DST_PROT_CTRL_SET(x, v)  do { (x) = (((x) & ~0xe00000) | ((v) << 21)); } while(0)
  #define DMA_CHANNEL_CFG_DST_PROT_CTRL_GET(x)     (((x) >> 21) & 0x7)
/** Set the bits to match the size of the source data: @multiple */
  #define DMA_CHANNEL_CFG_SRC_SIZE(v)              ((DMA_CHANNEL_CFG_SRC_SIZE_##v) << 24)
  #define DMA_CHANNEL_CFG_SRC_SIZE_SET(x, v)       do { (x) = (((x) & ~0x3000000) | ((DMA_CHANNEL_CFG_SRC_SIZE_##v) << 24)); } while(0)
  #define DMA_CHANNEL_CFG_SRC_SIZE_SETVAL(x, v)    do { (x) = (((x) & ~0x3000000) | ((v) << 24)); } while(0)
  #define DMA_CHANNEL_CFG_SRC_SIZE_GET(x)          (((x) >> 24) & 0x3)
    #define DMA_CHANNEL_CFG_SRC_SIZE_BYTE            0x00000000
    #define DMA_CHANNEL_CFG_SRC_SIZE_HALFWORD        0x00000001
    #define DMA_CHANNEL_CFG_SRC_SIZE_WORD            0x00000002
/** Set the bits to control the source address increment. The address increment
   depends on the source data width. @multiple */
  #define DMA_CHANNEL_CFG_SRC_INC(v)               ((DMA_CHANNEL_CFG_SRC_INC_##v) << 26)
  #define DMA_CHANNEL_CFG_SRC_INC_SET(x, v)        do { (x) = (((x) & ~0xc000000) | ((DMA_CHANNEL_CFG_SRC_INC_##v) << 26)); } while(0)
  #define DMA_CHANNEL_CFG_SRC_INC_SETVAL(x, v)     do { (x) = (((x) & ~0xc000000) | ((v) << 26)); } while(0)
  #define DMA_CHANNEL_CFG_SRC_INC_GET(x)           (((x) >> 26) & 0x3)
    #define DMA_CHANNEL_CFG_SRC_INC_BYTE             0x00000000
    #define DMA_CHANNEL_CFG_SRC_INC_HALFWORD         0x00000001
    #define DMA_CHANNEL_CFG_SRC_INC_WORD             0x00000002
    #define DMA_CHANNEL_CFG_SRC_INC_NOINC            0x00000003
/** Set the bits to match the size of the destonation data: @multiple */
  #define DMA_CHANNEL_CFG_DST_SIZE(v)              ((DMA_CHANNEL_CFG_DST_SIZE_##v) << 28)
  #define DMA_CHANNEL_CFG_DST_SIZE_SET(x, v)       do { (x) = (((x) & ~0x30000000) | ((DMA_CHANNEL_CFG_DST_SIZE_##v) << 28)); } while(0)
  #define DMA_CHANNEL_CFG_DST_SIZE_SETVAL(x, v)    do { (x) = (((x) & ~0x30000000) | ((v) << 28)); } while(0)
  #define DMA_CHANNEL_CFG_DST_SIZE_GET(x)          (((x) >> 28) & 0x3)
    #define DMA_CHANNEL_CFG_DST_SIZE_BYTE            0x00000000
    #define DMA_CHANNEL_CFG_DST_SIZE_HALFWORD        0x00000001
    #define DMA_CHANNEL_CFG_DST_SIZE_WORD            0x00000002
/** Set the bits to control the destination address increment. The address
   increment depends on the destination data width. @multiple */
  #define DMA_CHANNEL_CFG_DST_INC(v)               ((DMA_CHANNEL_CFG_DST_INC_##v) << 30)
  #define DMA_CHANNEL_CFG_DST_INC_SET(x, v)        do { (x) = (((x) & ~0xc0000000) | ((DMA_CHANNEL_CFG_DST_INC_##v) << 30)); } while(0)
  #define DMA_CHANNEL_CFG_DST_INC_SETVAL(x, v)     do { (x) = (((x) & ~0xc0000000) | ((v) << 30)); } while(0)
  #define DMA_CHANNEL_CFG_DST_INC_GET(x)           (((x) >> 30) & 0x3)
    #define DMA_CHANNEL_CFG_DST_INC_BYTE             0x00000000
    #define DMA_CHANNEL_CFG_DST_INC_HALFWORD         0x00000001
    #define DMA_CHANNEL_CFG_DST_INC_WORD             0x00000002
    #define DMA_CHANNEL_CFG_DST_INC_NOINC            0x00000003

#define DMA_CHANNEL_UNUSED_ADDR                      0x0000000c
#define DMA_CHANNEL_UNUSED_MASK                      0x00000000

#endif

