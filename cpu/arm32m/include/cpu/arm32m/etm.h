/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -I arm/etm.bf                                                         \
     -O /home/nipo/projects/mutekh/cpu/arm32m/include/cpu/arm32m/etm.h -o cdefs \
     cdefs_use_field_shift=1
*/

#ifndef _ETM_BFGEN_DEFS_
#define _ETM_BFGEN_DEFS_

/** Main Control Register @multiple */
#define ETM_CR_ADDR                                  0xe0041000
/** ETM power down. This bit can be used by an implementation to control if the
   ETM is in a low power state. This bit must be cleared by the trace software
   tools at the beginning of a debug session. When this bit is set to 1, writes
   to some registers and fields might be ignored @multiple */
  #define ETM_CR_ETMPD                             0x00000001
  #define ETM_CR_ETMPD_SHIFT                       0
/** Port size. The ETM-M4 has no influence over the external pins used for trace.
   These bits are implemented but not used. On an ETM reset these bits reset to
   0b001 @multiple */
  #define ETM_CR_PS_SHIFT                          4
  #define ETM_CR_PS(v)                             ((v) << 4)
  #define ETM_CR_PS_SET(x, v)                      do { (x) = (((x) & ~0x70) | ((v) << 4)); } while(0)
  #define ETM_CR_PS_GET(x)                         (((x) >> 4) & 0x7)
/** Stall processor. The FIFOFULL output can be used to stall the processor to
   prevent overflow. The FIFOFULL output is only enabled when the stall processor
   bit is set to 1. When the bit is 0 the FIFOFULL output remains LOW at all
   times and the FIFO overflows if there are too many trace packets. Trace
   resumes without corruption once the FIFO has drained, if overflow does occur.
   An ETM reset sets this bit to 0 @multiple */
  #define ETM_CR_SP                                0x00000080
  #define ETM_CR_SP_SHIFT                          7
/** Branch output. When set to 1 all branch addresses are output, even if the
   branch was because of a direct branch instruction. Setting this bit enables
   reconstruction of the program flow without having access to the memory image
   of the code being executed. When this bit is set to 1, more trace data is
   generated, and this may affect the performance of the trace system.
   Information about the execution of a branch is traced regardless of the state
   of this bit. An ETM reset sets this bit to 0 @multiple */
  #define ETM_CR_BO                                0x00000100
  #define ETM_CR_BO_SHIFT                          8
/** Debug request control. When set to 1 and the trigger event occurs, the DBGRQ
   output is asserted until DBGACK is observed. This enables the ARM processor to
   be forced into Debug state. An ETM reset sets this bit to 0 @multiple */
  #define ETM_CR_DRC                               0x00000200
  #define ETM_CR_DRC_SHIFT                         9
/** ETM programming. This bit must be set to 1 at the start of the ETM
   programming sequence. Tracing is prevented while this bit is set to 1. On an
   ETM reset this bit is set to b1 @multiple */
  #define ETM_CR_PROG                              0x00000400
  #define ETM_CR_PROG_SHIFT                        10
/** ETM port selection. This bit can be used to control other trace components in
   an implementation. This bit must be set by the trace software tools to ensure
   that trace output is enabled from this ETM. @multiple */
  #define ETM_CR_EN                                0x00000800
  #define ETM_CR_EN_SHIFT                          11
/** This bit is implemented but has no function. An ETM reset sets this bit to 0
   @multiple */
  #define ETM_CR_PM2                               0x00002000
  #define ETM_CR_PM2_SHIFT                         13
/** These bits are implemented but have no function. An ETM reset sets these bits
   to 0 @multiple */
  #define ETM_CR_PM_SHIFT                          16
  #define ETM_CR_PM(v)                             ((v) << 16)
  #define ETM_CR_PM_SET(x, v)                      do { (x) = (((x) & ~0x30000) | ((v) << 16)); } while(0)
  #define ETM_CR_PM_GET(x)                         (((x) >> 16) & 0x3)
/** This bit is implemented but has no function. An ETM reset sets this bit to 0
   @multiple */
  #define ETM_CR_PS3                               0x00200000
  #define ETM_CR_PS3_SHIFT                         21
/** When set, this bit enables timestamping. An ETM reset sets this bit to 0
   @multiple */
  #define ETM_CR_TE                                0x10000000
  #define ETM_CR_TE_SHIFT                          28

/** Configuration Code Register @multiple */
#define ETM_CCR_ADDR                                 0xe0041004
/** Number of address comparator pairs. The value of these bits is b0000,
   indicating that address comparator pairs are not implemented @multiple */
  #define ETM_CCR_NUMBEROFADDRESSCOMPARATORPAIRS_SHIFT 0
  #define ETM_CCR_NUMBEROFADDRESSCOMPARATORPAIRS(v) ((v) << 0)
  #define ETM_CCR_NUMBEROFADDRESSCOMPARATORPAIRS_SET(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define ETM_CCR_NUMBEROFADDRESSCOMPARATORPAIRS_GET(x) (((x) >> 0) & 0xf)
/** Number of data value comparators. The value of these bits is b0000,
   indicating that data value comparators are not implemented @multiple */
  #define ETM_CCR_NDVC_SHIFT                       4
  #define ETM_CCR_NDVC(v)                          ((v) << 4)
  #define ETM_CCR_NDVC_SET(x, v)                   do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define ETM_CCR_NDVC_GET(x)                      (((x) >> 4) & 0xf)
/** Number of memory map decoders. The value of these bits is b00000, indicating
   that memory map decoder inputs are not implemented @multiple */
  #define ETM_CCR_NMMD_SHIFT                       8
  #define ETM_CCR_NMMD(v)                          ((v) << 8)
  #define ETM_CCR_NMMD_SET(x, v)                   do { (x) = (((x) & ~0x1f00) | ((v) << 8)); } while(0)
  #define ETM_CCR_NMMD_GET(x)                      (((x) >> 8) & 0x1f)
/** Number of counters. The value of these bits is b001, indicating that one
   counter is implemented @multiple */
  #define ETM_CCR_NC_SHIFT                         13
  #define ETM_CCR_NC(v)                            ((v) << 13)
  #define ETM_CCR_NC_SET(x, v)                     do { (x) = (((x) & ~0xe000) | ((v) << 13)); } while(0)
  #define ETM_CCR_NC_GET(x)                        (((x) >> 13) & 0x7)
/** Sequencer present. The value of this bit is 0, indicating that the sequencer
   is not implemented @multiple */
  #define ETM_CCR_SP                               0x00010000
  #define ETM_CCR_SP_SHIFT                         16
/** Number of external inputs. The value of these bits is between b000 and b010,
   indicating the number of external inputs, from 0 to 2, implemented in the
   system @multiple */
  #define ETM_CCR_NEI_SHIFT                        17
  #define ETM_CCR_NEI(v)                           ((v) << 17)
  #define ETM_CCR_NEI_SET(x, v)                    do { (x) = (((x) & ~0xe0000) | ((v) << 17)); } while(0)
  #define ETM_CCR_NEI_GET(x)                       (((x) >> 17) & 0x7)
/** Number of external outputs. The value of these bits is b000, indicating that
   no external outputs are supported @multiple */
  #define ETM_CCR_NEO_SHIFT                        20
  #define ETM_CCR_NEO(v)                           ((v) << 20)
  #define ETM_CCR_NEO_SET(x, v)                    do { (x) = (((x) & ~0x700000) | ((v) << 20)); } while(0)
  #define ETM_CCR_NEO_GET(x)                       (((x) >> 20) & 0x7)
/** FIFOFULL logic present. The value of this bit is 1, indicating that FIFOFULL
   logic is present in the ETM. To use FIFOFULL the system must also support the
   function, as indicated by bit [8] of ETMSCR @multiple */
  #define ETM_CCR_FFLP                             0x00800000
  #define ETM_CCR_FFLP_SHIFT                       23
/** Number of Context ID comparators. The value of these bits is b00, indicating
   that Context ID comparators are not implemented @multiple */
  #define ETM_CCR_NCIDC_SHIFT                      24
  #define ETM_CCR_NCIDC(v)                         ((v) << 24)
  #define ETM_CCR_NCIDC_SET(x, v)                  do { (x) = (((x) & ~0x3000000) | ((v) << 24)); } while(0)
  #define ETM_CCR_NCIDC_GET(x)                     (((x) >> 24) & 0x3)
/** Trace start/stop block present. The value of this bit is 1, indicating that
   the Trace start/stop block is present @multiple */
  #define ETM_CCR_TSSBP                            0x04000000
  #define ETM_CCR_TSSBP_SHIFT                      26
/** Coprocessor and memory access. The value of this bit is 1, indicating that
   memory-mapped access to registers is supported @multiple */
  #define ETM_CCR_CMA                              0x08000000
  #define ETM_CCR_CMA_SHIFT                        27
/** The value of this bit is 1, indicating that the ETMIDR, register 0x79, is
   present and defines the ETM architecture version in use @multiple */
  #define ETM_CCR_ETMIDRP                          0x80000000
  #define ETM_CCR_ETMIDRP_SHIFT                    31

/** Trigger Event Register @multiple */
#define ETM_TRIGGER_ADDR                             0xe0041008
/** Trigger event @multiple */
  #define ETM_TRIGGER_TRIGGEREVENT_SHIFT           0
  #define ETM_TRIGGER_TRIGGEREVENT(v)              ((v) << 0)
  #define ETM_TRIGGER_TRIGGEREVENT_SET(x, v)       do { (x) = (((x) & ~0x1ffff) | ((v) << 0)); } while(0)
  #define ETM_TRIGGER_TRIGGEREVENT_GET(x)          (((x) >> 0) & 0x1ffff)

/** ETM Status Register @multiple */
#define ETM_SR_ADDR                                  0xe0041010
/** Untraced overflow flag. If set to 1, there is an overflow that has not yet
   been traced. This bit is cleared to 0 when either: - trace is restarted - the
   ETM Power Down bit, bit [0] of the ETM Control Register, 0x00, is set to 1.
   Note: Setting or clearing the ETM programming bit does not cause this bit to
   be cleared to 0 @multiple */
  #define ETM_SR_UOF                               0x00000001
  #define ETM_SR_UOF_SHIFT                         0
/** ETM programming bit value (Progbit). The current effective value of the ETM
   Programming bit (ETM Control Register bit [10]). Tou must wait for this bit to
   go to 1 before you start to program the ETM @multiple */
  #define ETM_SR_PROGBIT                           0x00000002
  #define ETM_SR_PROGBIT_SHIFT                     1
/** Holds the current status of the trace start/stop resource. If set to 1, it
   indicates that a trace on address has been matched, without a corresponding
   trace off address match @multiple */
  #define ETM_SR_STATUS                            0x00000004
  #define ETM_SR_STATUS_SHIFT                      2
/** Trigger bit. Set when the trigger occurs, and prevents the trigger from being
   output until the ETM is next programmed @multiple */
  #define ETM_SR_TRIGGER                           0x00000008
  #define ETM_SR_TRIGGER_SHIFT                     3

/** System Configuration Register @multiple */
#define ETM_SCR_ADDR                                 0xe0041014
/** Maximum ETM port size bits [2:0]. These bits are used in conjunction with bit
   [9]. The value of these bits is b001 @multiple */
  #define ETM_SCR_MAXIMUMPORTSIZE_SHIFT            0
  #define ETM_SCR_MAXIMUMPORTSIZE(v)               ((v) << 0)
  #define ETM_SCR_MAXIMUMPORTSIZE_SET(x, v)        do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define ETM_SCR_MAXIMUMPORTSIZE_GET(x)           (((x) >> 0) & 0x7)
/** FIFOFULL supported. The value of this bit is 1, indicating that FIFOFULL is
   supported. This bit is used in conjunction with bit [23] of the ETMCCR
   @multiple */
  #define ETM_SCR_FIFOFULLSUPPORTED                0x00000100
  #define ETM_SCR_FIFOFULLSUPPORTED_SHIFT          8
/** Maximum ETM port size bit [3]. This bit is used in conjunction with bits
   [2:0]. Its value is 0. This has no effect on the TPIU trace port @multiple */
  #define ETM_SCR_MAXIMUMPORTSIZE3                 0x00000200
  #define ETM_SCR_MAXIMUMPORTSIZE3_SHIFT           9
/** Port size supported. This bit reads as 1 if the currently selected port size
   is supported. This has no effect on the TPIU trace port @multiple */
  #define ETM_SCR_PORTSIZESUPPORTED                0x00000400
  #define ETM_SCR_PORTSIZESUPPORTED_SHIFT          10
/** Port mode supported. This bit reads as 1 if the currently selected port mode
   is supported. This has no effect on the TPIU trace port @multiple */
  #define ETM_SCR_PORTMODESUPPORTED                0x00000800
  #define ETM_SCR_PORTMODESUPPORTED_SHIFT          11
/** These bits give the number of supported processors minus 1. The value of
   these bits is b000, indicating that there is only one processor connected
   @multiple */
  #define ETM_SCR_N_SHIFT                          12
  #define ETM_SCR_N(v)                             ((v) << 12)
  #define ETM_SCR_N_SET(x, v)                      do { (x) = (((x) & ~0x7000) | ((v) << 12)); } while(0)
  #define ETM_SCR_N_GET(x)                         (((x) >> 12) & 0x7)
/** No Fetch comparisons. The value of this bit is 1, indicating that fetch
   comparisons are not implemented @multiple */
  #define ETM_SCR_NOFETCHCOMPARISONS               0x00020000
  #define ETM_SCR_NOFETCHCOMPARISONS_SHIFT         17

/** Trace Enable Event Register @multiple */
#define ETM_EEVR_ADDR                                0xe0041020
/** Trace Enable event @multiple */
  #define ETM_EEVR_TRACEENABLEEVENT_SHIFT          0
  #define ETM_EEVR_TRACEENABLEEVENT(v)             ((v) << 0)
  #define ETM_EEVR_TRACEENABLEEVENT_SET(x, v)      do { (x) = (((x) & ~0x1ffff) | ((v) << 0)); } while(0)
  #define ETM_EEVR_TRACEENABLEEVENT_GET(x)         (((x) >> 0) & 0x1ffff)

/** Trace Enable Control 1 Register @multiple */
#define ETM_TECR1_ADDR                               0xe0041024
  #define ETM_TECR1_EXCLUDE                        0x01000000
  #define ETM_TECR1_EXCLUDE_SHIFT                  24
/** Trace start/stop enable. The trace start/stop resource, resource 0x5F, is
   unaffected by the value of this bit 0: Tracing is unaffected by the trace
   start/stop logic 1: Tracing is controlled by the trace on and off addresses
   configured for the trace start/stop logic @multiple */
  #define ETM_TECR1_TRACE_CONTROL_ENABLE           0x02000000
  #define ETM_TECR1_TRACE_CONTROL_ENABLE_SHIFT     25

/** FIFOFULL Level Register @multiple */
#define ETM_FFLR_ADDR                                0xe0041028
/** FIFO full level. The number of bytes left in FIFO, below which the FIFOFULL
   or SupressData signal is asserted. For example, setting this value to 15
   causes data trace suppression or processor stalling, if enabled, when there
   are less than 15 free bytes in the FIFO @multiple */
  #define ETM_FFLR_FIFOFULLLEVEL_SHIFT             0
  #define ETM_FFLR_FIFOFULLLEVEL(v)                ((v) << 0)
  #define ETM_FFLR_FIFOFULLLEVEL_SET(x, v)         do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define ETM_FFLR_FIFOFULLLEVEL_GET(x)            (((x) >> 0) & 0xff)

/** Free-running counter reload value @multiple */
#define ETM_CNTRLDVR1_ADDR                           0xe0041140
/** Initial count @multiple */
  #define ETM_CNTRLDVR1_INTITIALCOUNT_SHIFT        0
  #define ETM_CNTRLDVR1_INTITIALCOUNT(v)           ((v) << 0)
  #define ETM_CNTRLDVR1_INTITIALCOUNT_SET(x, v)    do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define ETM_CNTRLDVR1_INTITIALCOUNT_GET(x)       (((x) >> 0) & 0xffff)

/** Synchronization Frequency Register @multiple */
#define ETM_SYNCFR_ADDR                              0xe00411e0
/** Synchronization frequency. Default value is 1024 @multiple */
  #define ETM_SYNCFR_SYNCFREQUENCY_SHIFT           0
  #define ETM_SYNCFR_SYNCFREQUENCY(v)              ((v) << 0)
  #define ETM_SYNCFR_SYNCFREQUENCY_SET(x, v)       do { (x) = (((x) & ~0xfff) | ((v) << 0)); } while(0)
  #define ETM_SYNCFR_SYNCFREQUENCY_GET(x)          (((x) >> 0) & 0xfff)

/** ID Register @multiple */
#define ETM_IDR_ADDR                                 0xe00411e4
/** Implementation revision. The value of these bits is b0000, indicating
   implementation revision, 0 @multiple */
  #define ETM_IDR_IMPLEMENTATIONREVISION_SHIFT     0
  #define ETM_IDR_IMPLEMENTATIONREVISION(v)        ((v) << 0)
  #define ETM_IDR_IMPLEMENTATIONREVISION_SET(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define ETM_IDR_IMPLEMENTATIONREVISION_GET(x)    (((x) >> 0) & 0xf)
/** Minor ETM architecture version. The value of these bits is 0b0101, indicating
   minor architecture version number 5 @multiple */
  #define ETM_IDR_MINORETMARCHITECTUREVERSION_SHIFT 4
  #define ETM_IDR_MINORETMARCHITECTUREVERSION(v)   ((v) << 4)
  #define ETM_IDR_MINORETMARCHITECTUREVERSION_SET(x, v) do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define ETM_IDR_MINORETMARCHITECTUREVERSION_GET(x) (((x) >> 4) & 0xf)
/** Major ETM architecture version. The value of these bits is 0b0010, indicating
   major architecture version number 3, ETMv3 @multiple */
  #define ETM_IDR_MAJORETMARCHITECTUREVERSION_SHIFT 8
  #define ETM_IDR_MAJORETMARCHITECTUREVERSION(v)   ((v) << 8)
  #define ETM_IDR_MAJORETMARCHITECTUREVERSION_SET(x, v) do { (x) = (((x) & ~0xf00) | ((v) << 8)); } while(0)
  #define ETM_IDR_MAJORETMARCHITECTUREVERSION_GET(x) (((x) >> 8) & 0xf)
/** Processor family. The value of these bits is 0b1111, indicating that the
   processor family is not identified in this register @multiple */
  #define ETM_IDR_PROCESSORFAMILY_SHIFT            12
  #define ETM_IDR_PROCESSORFAMILY(v)               ((v) << 12)
  #define ETM_IDR_PROCESSORFAMILY_SET(x, v)        do { (x) = (((x) & ~0xf000) | ((v) << 12)); } while(0)
  #define ETM_IDR_PROCESSORFAMILY_GET(x)           (((x) >> 12) & 0xf)
/** Load PC first. The value of this bit is 0, indicating that data tracing is
   not supported @multiple */
  #define ETM_IDR_LOADPCFIRST                      0x00010000
  #define ETM_IDR_LOADPCFIRST_SHIFT                16
/** 32-bit Thumb instruction tracing. The value of this bit is 1, indicating that
   a 32-bit Thumb instruction is traced as a single instruction @multiple */
  #define ETM_IDR_THUMBINSTRUCTIONTRACING_SHIFT    18
  #define ETM_IDR_THUMBINSTRUCTIONTRACING(v)       ((ETM_IDR_THUMBINSTRUCTIONTRACING_##v) << 18)
  #define ETM_IDR_THUMBINSTRUCTIONTRACING_SET(x, v) do { (x) = (((x) & ~0x40000) | ((ETM_IDR_THUMBINSTRUCTIONTRACING_##v) << 18)); } while(0)
  #define ETM_IDR_THUMBINSTRUCTIONTRACING_GET(x)   (((x) >> 18) & 0x1)
    #define ETM_IDR_THUMBINSTRUCTIONTRACING_A_32_BIT_THUMB_INSTRUCTION_IS_TRACED_AS_TWO_INSTRUCTIONS_AND_EXCEPTIONS_MIGHT_OCCUR_BETWEEN_THESE_TWO_INSTRUCTIONS 0x00000000
    #define ETM_IDR_THUMBINSTRUCTIONTRACING_A_32_BIT_THIMB_INSTRUCTION_IS_TRACED_AS_A_SINGLE_INSTRUCTION 0x00000001
/** Security Extensions support. The value of this bit is 0, indicating that the
   ETM behaves as if the processor is in Secure state at all times @multiple */
  #define ETM_IDR_SECURITYEXTENSIONSUPPORT_SHIFT   19
  #define ETM_IDR_SECURITYEXTENSIONSUPPORT(v)      ((ETM_IDR_SECURITYEXTENSIONSUPPORT_##v) << 19)
  #define ETM_IDR_SECURITYEXTENSIONSUPPORT_SET(x, v) do { (x) = (((x) & ~0x80000) | ((ETM_IDR_SECURITYEXTENSIONSUPPORT_##v) << 19)); } while(0)
  #define ETM_IDR_SECURITYEXTENSIONSUPPORT_GET(x)  (((x) >> 19) & 0x1)
    #define ETM_IDR_SECURITYEXTENSIONSUPPORT_THE_ETM_BEHAVES_AS_IF_THE_PROCESSOR_IS_IN_SECURE_STATE_AT_ALL_TIMES 0x00000000
    #define ETM_IDR_SECURITYEXTENSIONSUPPORT_THE_ARM_ARCHITECTURE_SECURITY_EXTENSIONS_ARE_IMPLEMENTED_BY_THE_PROCESSOR 0x00000001
/** Branch packet encoding. The value of this bit is 1, indicating that
   alternative branch packet encoding is implemented @multiple */
  #define ETM_IDR_BRANCHPACKETENCODING_SHIFT       20
  #define ETM_IDR_BRANCHPACKETENCODING(v)          ((ETM_IDR_BRANCHPACKETENCODING_##v) << 20)
  #define ETM_IDR_BRANCHPACKETENCODING_SET(x, v)   do { (x) = (((x) & ~0x100000) | ((ETM_IDR_BRANCHPACKETENCODING_##v) << 20)); } while(0)
  #define ETM_IDR_BRANCHPACKETENCODING_GET(x)      (((x) >> 20) & 0x1)
    #define ETM_IDR_BRANCHPACKETENCODING_THE_ETM_IMPLEMENTS_THE_ORIGINAL_BRANCH_PACKET_ENCODING 0x00000000
    #define ETM_IDR_BRANCHPACKETENCODING_THE_ETM_IMPLEMENTS_THE_ALTERNATIVE_BRANCH_PACKET_ENCODING 0x00000001
/** Implementor code. These bits identify ARM as the implementor of the
   processor. The value of these bits is 01000001 @multiple */
  #define ETM_IDR_IMPLEMENTORCODE_SHIFT            24
  #define ETM_IDR_IMPLEMENTORCODE(v)               ((v) << 24)
  #define ETM_IDR_IMPLEMENTORCODE_SET(x, v)        do { (x) = (((x) & ~0xff000000) | ((v) << 24)); } while(0)
  #define ETM_IDR_IMPLEMENTORCODE_GET(x)           (((x) >> 24) & 0xff)

/** Configuration Code Extension Register @multiple */
#define ETM_CCER_ADDR                                0xe00411e8
/** Extended external input selectors. The value of these bits is 0, indicating
   that extended external input selectors are not implemented @multiple */
  #define ETM_CCER_EXTENDEDEXTERNALINPUTSELECTORS_SHIFT 0
  #define ETM_CCER_EXTENDEDEXTERNALINPUTSELECTORS(v) ((v) << 0)
  #define ETM_CCER_EXTENDEDEXTERNALINPUTSELECTORS_SET(x, v) do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define ETM_CCER_EXTENDEDEXTERNALINPUTSELECTORS_GET(x) (((x) >> 0) & 0x7)
/** Extended external input bus. The value of these bits is 0, indicating that
   the extended external input bus is not implemented @multiple */
  #define ETM_CCER_EXTENDEDEXTERNALINPUTBUS_SHIFT  3
  #define ETM_CCER_EXTENDEDEXTERNALINPUTBUS(v)     ((v) << 3)
  #define ETM_CCER_EXTENDEDEXTERNALINPUTBUS_SET(x, v) do { (x) = (((x) & ~0x7f8) | ((v) << 3)); } while(0)
  #define ETM_CCER_EXTENDEDEXTERNALINPUTBUS_GET(x) (((x) >> 3) & 0xff)
/** Readable registers. The value of this bit is 1, indicating that all registers
   are readable @multiple */
  #define ETM_CCER_READABLEREGISTERS               0x00000800
  #define ETM_CCER_READABLEREGISTERS_SHIFT         11
/** Data address comparisons. The value of this bit is 1, indicating that data
   address comparisons are not supported @multiple */
  #define ETM_CCER_DATAADDRESSCOMPARISONS          0x00001000
  #define ETM_CCER_DATAADDRESSCOMPARISONS_SHIFT    12
/** Instrumentation resources. The value of these bits is 0b000, indicating that
   no Instrumentation resources are supported @multiple */
  #define ETM_CCER_INSTRUMENTATIONRESOURCES_SHIFT  13
  #define ETM_CCER_INSTRUMENTATIONRESOURCES(v)     ((v) << 13)
  #define ETM_CCER_INSTRUMENTATIONRESOURCES_SET(x, v) do { (x) = (((x) & ~0xe000) | ((v) << 13)); } while(0)
  #define ETM_CCER_INSTRUMENTATIONRESOURCES_GET(x) (((x) >> 13) & 0x7)
/** EmbeddedICE watchpoint inputs. The value of these bits is 0b0100, indicating
   that the number of EmbeddedICE watchpoint inputs implemented is four. These
   inputs come from the DWT @multiple */
  #define ETM_CCER_EMBEDDEDICEWATCHPOINTINPUTS_SHIFT 16
  #define ETM_CCER_EMBEDDEDICEWATCHPOINTINPUTS(v)  ((v) << 16)
  #define ETM_CCER_EMBEDDEDICEWATCHPOINTINPUTS_SET(x, v) do { (x) = (((x) & ~0xf0000) | ((v) << 16)); } while(0)
  #define ETM_CCER_EMBEDDEDICEWATCHPOINTINPUTS_GET(x) (((x) >> 16) & 0xf)
/** Trace Start/Stop block uses EmbeddedICE watchpoint inputs. The value of this
   bit is 1, indicating that the Trace Start/Stop block uses the EmbeddedICE
   watchpoint inputs @multiple */
  #define ETM_CCER_TRACESTARTSTOPBLOCKUSESEMBEDDEDICEWATCHPOINTINPUTS 0x00100000
  #define ETM_CCER_TRACESTARTSTOPBLOCKUSESEMBEDDEDICEWATCHPOINTINPUTS_SHIFT 20
/** EmbeddedICE behavior control implemented. The value of this bit is 0,
   indicating that the ETMEIBCR is not implemented @multiple */
  #define ETM_CCER_EMBEDDEDICEBEHAVIORCONTROLIMPLEMENTED 0x00200000
  #define ETM_CCER_EMBEDDEDICEBEHAVIORCONTROLIMPLEMENTED_SHIFT 21
/** Timestamping implemented. This bit is set to 1, indicating that timestamping
   is implemented @multiple */
  #define ETM_CCER_TIMESTAMPINGIMPLEMENTED         0x00400000
  #define ETM_CCER_TIMESTAMPINGIMPLEMENTED_SHIFT   22
/** Reduced function counter. Set to 1 to indicate that Counter 1 is a reduced
   function counter @multiple */
  #define ETM_CCER_REDUCEDFUNCTIONCOUNTER          0x08000000
  #define ETM_CCER_REDUCEDFUNCTIONCOUNTER_SHIFT    27
/** Timestamp encoding. Set to 1 to indicate that the timestamp is encoded as a
   natural binary number @multiple */
  #define ETM_CCER_TIMESTAMPENCODING               0x10000000
  #define ETM_CCER_TIMESTAMPENCODING_SHIFT         28
/** Timestamp size. Set to 0 to indicate a size of 48 bits @multiple */
  #define ETM_CCER_TIMESTAMPSIZE                   0x20000000
  #define ETM_CCER_TIMESTAMPSIZE_SHIFT             29

/** TraceEnable Start/Stop EmbeddedICE Control Register @multiple */
#define ETM_TESSEICR_ADDR                            0xe00411f0
/** Start resource selection. Setting any of these bits to 1 selects the
   corresponding EmbeddedICE watchpoint input as a TraceEnable start resource.
   Bit [0] corresponds to input 1, bit [1] corresponds to input 2, bit [2]
   corresponds to input 3, and bit [3] corresponds to input 4 @multiple */
  #define ETM_TESSEICR_STARTRESOURCESELECTION_SHIFT 0
  #define ETM_TESSEICR_STARTRESOURCESELECTION(v)   ((v) << 0)
  #define ETM_TESSEICR_STARTRESOURCESELECTION_SET(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define ETM_TESSEICR_STARTRESOURCESELECTION_GET(x) (((x) >> 0) & 0xf)
/** Stop resource selection. Setting any of these bits to 1 selects the
   corresponding EmbeddedICE watchpoint input as a TraceEnable stop resource. Bit
   [16] corresponds to input 1, bit [17] corresponds to input 2, bit [18]
   corresponds to input 3, and bit [19] corresponds to input 4 @multiple */
  #define ETM_TESSEICR_STOPRESOURCESELECTION_SHIFT 16
  #define ETM_TESSEICR_STOPRESOURCESELECTION(v)    ((v) << 16)
  #define ETM_TESSEICR_STOPRESOURCESELECTION_SET(x, v) do { (x) = (((x) & ~0xf0000) | ((v) << 16)); } while(0)
  #define ETM_TESSEICR_STOPRESOURCESELECTION_GET(x) (((x) >> 16) & 0xf)

/** Timestamp Event Register @multiple */
#define ETM_TSEVR_ADDR                               0xe00411f8
/** Timestamp event @multiple */
  #define ETM_TSEVR_TIMESTAMPEVENT_SHIFT           0
  #define ETM_TSEVR_TIMESTAMPEVENT(v)              ((v) << 0)
  #define ETM_TSEVR_TIMESTAMPEVENT_SET(x, v)       do { (x) = (((x) & ~0xfff) | ((v) << 0)); } while(0)
  #define ETM_TSEVR_TIMESTAMPEVENT_GET(x)          (((x) >> 0) & 0xfff)

/** CoreSight Trace ID Register @multiple */
#define ETM_TRACEIDR_ADDR                            0xe0041200
/** Trace ID to output onto the trace bus. On an ETM reset this field is cleared
   to 0x00 @multiple */
  #define ETM_TRACEIDR_TRACEID_SHIFT               0
  #define ETM_TRACEIDR_TRACEID(v)                  ((v) << 0)
  #define ETM_TRACEIDR_TRACEID_SET(x, v)           do { (x) = (((x) & ~0x7f) | ((v) << 0)); } while(0)
  #define ETM_TRACEIDR_TRACEID_GET(x)              (((x) >> 0) & 0x7f)

/** ETM ID Register 2 @multiple */
#define ETM_IDR2_ADDR                                0xe0041208

/** Device Power-Down Status Register @multiple */
#define ETM_PDSR_ADDR                                0xe0041314
/** The value of this bit indicates whether you can access the ETM Trace
   Registers. The value of this bit is always 1, indicating that the ETM Trace
   Registers can be accessed @multiple */
  #define ETM_PDSR_ETMPOWEREDUP                    0x00000001
  #define ETM_PDSR_ETMPOWEREDUP_SHIFT              0

/** Integration Test Miscelaneous Inputs Register @multiple */
#define ETM__ITMISCIN_ADDR                           0xe0041ee0
/** A read of these bits returns the value of the EXTIN[1:0] input pins @multiple
   */
  #define ETM__ITMISCIN_EXTIN_SHIFT                0
  #define ETM__ITMISCIN_EXTIN(v)                   ((v) << 0)
  #define ETM__ITMISCIN_EXTIN_SET(x, v)            do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define ETM__ITMISCIN_EXTIN_GET(x)               (((x) >> 0) & 0x3)
/** A read of this bit returns the value of the COREHALT input pin @multiple */
  #define ETM__ITMISCIN_COREHALT                   0x00000010
  #define ETM__ITMISCIN_COREHALT_SHIFT             4

/** Integration Test Trigger Out Register @multiple */
#define ETM__ITTRIGOUT_ADDR                          0xe0041ee8
/** A write to this bit sets the TRIGGER output @multiple */
  #define ETM__ITTRIGOUT_TRIGGER                   0x00000001
  #define ETM__ITTRIGOUT_TRIGGER_SHIFT             0

/** ETM Integration Test ATB Control 2 Register @multiple */
#define ETM__ITATBCTR2_ADDR                          0xe0041ef0
/** A read of this bit returns the value of the ETM ATREADY input @multiple */
  #define ETM__ITATBCTR2_ATREADY                   0x00000001
  #define ETM__ITATBCTR2_ATREADY_SHIFT             0

/** ETM Integration Test ATB Control 0 Register @multiple */
#define ETM__ITATBCTR0_ADDR                          0xe0041ef8
/** A write to this bit sets the value of the ETM ATVALID output @multiple */
  #define ETM__ITATBCTR0_ATVALID                   0x00000001
  #define ETM__ITATBCTR0_ATVALID_SHIFT             0

/** Integration Mode Control Register @multiple */
#define ETM_ITCTRL_ADDR                              0xe0041f00
/** Enable integration mode. When this bit is set to 1, the device enters
   integration mode to enable Topology Detection or Integration Testing to be
   checked. On an ETM reset this bit is cleared to 0 @multiple */
  #define ETM_ITCTRL_MODE                          0x00000001
  #define ETM_ITCTRL_MODE_SHIFT                    0

/** Claim Tag Set Register @multiple */
#define ETM_CLAIMSET_ADDR                            0xe0041fa0
/** A bit programmable register bank which sets the Claim Tag Value. Write 1 to
   set the bit in the claim tag. A read will return a logic 1 for all implemented
   locations @multiple */
  #define ETM_CLAIMSET_CLAIMSET_SHIFT              0
  #define ETM_CLAIMSET_CLAIMSET(v)                 ((v) << 0)
  #define ETM_CLAIMSET_CLAIMSET_SET(x, v)          do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define ETM_CLAIMSET_CLAIMSET_GET(x)             (((x) >> 0) & 0xf)

/** Claim Tag Clear Register @multiple */
#define ETM_CLAIMCLR_ADDR                            0xe0041fa4
/** A bit programmable register bank that is zero at reset. Write 1 to clear the
   bit in the claim tag. On reads, returns the current setting of the claim tag
   @multiple */
  #define ETM_CLAIMCLR_CLAIMCLR_SHIFT              0
  #define ETM_CLAIMCLR_CLAIMCLR(v)                 ((v) << 0)
  #define ETM_CLAIMCLR_CLAIMCLR_SET(x, v)          do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define ETM_CLAIMCLR_CLAIMCLR_GET(x)             (((x) >> 0) & 0xf)

/** Lock Access Register @multiple */
#define ETM_LAR_ADDR                                 0xe0041fb0
/** Access Code @multiple */
  #define ETM_LAR_ACCESS_SHIFT                     0
  #define ETM_LAR_ACCESS(v)                        ((ETM_LAR_ACCESS_##v) << 0)
  #define ETM_LAR_ACCESS_SET(x, v)                 do { (x) = (((x) & ~0xffffffff) | ((ETM_LAR_ACCESS_##v) << 0)); } while(0)
  #define ETM_LAR_ACCESS_GET(x)                    (((x) >> 0) & 0xffffffff)
    #define ETM_LAR_ACCESS_DISABLE                   0x00000000
    #define ETM_LAR_ACCESS_ENABLE                    0xc5acce55

/** Lock Status Register @multiple */
#define ETM_LSR_ADDR                                 0xe0041fb4
/** Lock mechanism is implemented. This bit always reads 1 @multiple */
  #define ETM_LSR_IMP                              0x00000001
  #define ETM_LSR_IMP_SHIFT                        0
/** Lock Status. This bit is HIGH when the device is locked, and LOW when
   unlocked @multiple */
  #define ETM_LSR_STATUS_SHIFT                     1
  #define ETM_LSR_STATUS(v)                        ((ETM_LSR_STATUS_##v) << 1)
  #define ETM_LSR_STATUS_SET(x, v)                 do { (x) = (((x) & ~0x2) | ((ETM_LSR_STATUS_##v) << 1)); } while(0)
  #define ETM_LSR_STATUS_GET(x)                    (((x) >> 1) & 0x1)
    #define ETM_LSR_STATUS_ACCESS_PERMITTED          0x00000000
    #define ETM_LSR_STATUS_WRITE_ACCESS_TO_THE_COMPONENT_IS_BLOCKED_ALL_WRITES_TO_CONTROL_REGISTERS_ARE_IGNORED_READS_ARE_PERMITTED 0x00000001
/** Access Lock Register size. This bit reads 0 to indicate a 32-bit register is
   present @multiple */
  #define ETM_LSR_S8BIT                            0x00000004
  #define ETM_LSR_S8BIT_SHIFT                      2

/** Authentication Status Register @multiple */
#define ETM_AUTHSTATUS_ADDR                          0xe0041fb8
/** Reads as b00, Non-secure invasive debug not supported by the ETM @multiple */
  #define ETM_AUTHSTATUS_NSID_SHIFT                0
  #define ETM_AUTHSTATUS_NSID(v)                   ((v) << 0)
  #define ETM_AUTHSTATUS_NSID_SET(x, v)            do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define ETM_AUTHSTATUS_NSID_GET(x)               (((x) >> 0) & 0x3)
/** Permission for Non-secure non-invasive debug @multiple */
  #define ETM_AUTHSTATUS_NSNID_SHIFT               2
  #define ETM_AUTHSTATUS_NSNID(v)                  ((ETM_AUTHSTATUS_NSNID_##v) << 2)
  #define ETM_AUTHSTATUS_NSNID_SET(x, v)           do { (x) = (((x) & ~0xc) | ((ETM_AUTHSTATUS_NSNID_##v) << 2)); } while(0)
  #define ETM_AUTHSTATUS_NSNID_GET(x)              (((x) >> 2) & 0x3)
    #define ETM_AUTHSTATUS_NSNID_NON_SECURE_NON_INVASIVE_DEBUG_DISABLED 0x00000002
    #define ETM_AUTHSTATUS_NSNID_NON_SECURE_NON_INVASIVE_DEBUG_ENABLED 0x00000003
/** Reads as b00, Secure invasive debug not supported by the ETM @multiple */
  #define ETM_AUTHSTATUS_SID_SHIFT                 4
  #define ETM_AUTHSTATUS_SID(v)                    ((v) << 4)
  #define ETM_AUTHSTATUS_SID_SET(x, v)             do { (x) = (((x) & ~0x30) | ((v) << 4)); } while(0)
  #define ETM_AUTHSTATUS_SID_GET(x)                (((x) >> 4) & 0x3)
/** Permission for Secure non-invasive debug @multiple */
  #define ETM_AUTHSTATUS_SNID_SHIFT                6
  #define ETM_AUTHSTATUS_SNID(v)                   ((v) << 6)
  #define ETM_AUTHSTATUS_SNID_SET(x, v)            do { (x) = (((x) & ~0xc0) | ((v) << 6)); } while(0)
  #define ETM_AUTHSTATUS_SNID_GET(x)               (((x) >> 6) & 0x3)

/** CoreSight Device Type Register @multiple */
#define ETM_DEVTYPE_ADDR                             0xe0041fcc
/** Major Type and Class @multiple */
  #define ETM_DEVTYPE_MAJORTYPE_SHIFT              0
  #define ETM_DEVTYPE_MAJORTYPE(v)                 ((ETM_DEVTYPE_MAJORTYPE_##v) << 0)
  #define ETM_DEVTYPE_MAJORTYPE_SET(x, v)          do { (x) = (((x) & ~0xf) | ((ETM_DEVTYPE_MAJORTYPE_##v) << 0)); } while(0)
  #define ETM_DEVTYPE_MAJORTYPE_GET(x)             (((x) >> 0) & 0xf)
    #define ETM_DEVTYPE_MAJORTYPE_TRACE_SOURCE       0x00000003
/** Sub Type @multiple */
  #define ETM_DEVTYPE_SUBTYPE_SHIFT                4
  #define ETM_DEVTYPE_SUBTYPE(v)                   ((ETM_DEVTYPE_SUBTYPE_##v) << 4)
  #define ETM_DEVTYPE_SUBTYPE_SET(x, v)            do { (x) = (((x) & ~0xf0) | ((ETM_DEVTYPE_SUBTYPE_##v) << 4)); } while(0)
  #define ETM_DEVTYPE_SUBTYPE_GET(x)               (((x) >> 4) & 0xf)
    #define ETM_DEVTYPE_SUBTYPE_PROCESSOR_TRACE      0x00000001

/** Peripheral Identification Register 4 @multiple */
#define ETM_PIDR4_ADDR                               0xe0041fd0
/** JEP106 continuation code @multiple */
  #define ETM_PIDR4_JEP106_SHIFT                   0
  #define ETM_PIDR4_JEP106(v)                      ((v) << 0)
  #define ETM_PIDR4_JEP106_SET(x, v)               do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define ETM_PIDR4_JEP106_GET(x)                  (((x) >> 0) & 0xf)
/** 4KB Count @multiple */
  #define ETM_PIDR4_C4KB_SHIFT                     4
  #define ETM_PIDR4_C4KB(v)                        ((v) << 4)
  #define ETM_PIDR4_C4KB_SET(x, v)                 do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define ETM_PIDR4_C4KB_GET(x)                    (((x) >> 4) & 0xf)

/** Peripheral Identification Register 5 @multiple */
#define ETM_PIDR5_ADDR                               0xe0041fd4

/** Peripheral Identification Register 6 @multiple */
#define ETM_PIDR6_ADDR                               0xe0041fd8

/** Peripheral Identification Register 7 @multiple */
#define ETM_PIDR7_ADDR                               0xe0041fdc

/** Peripheral Identification Register 0 @multiple */
#define ETM_PIDR0_ADDR                               0xe0041fe0
/** Part Number [7:0] @multiple */
  #define ETM_PIDR0_PARTNUMBER_SHIFT               0
  #define ETM_PIDR0_PARTNUMBER(v)                  ((v) << 0)
  #define ETM_PIDR0_PARTNUMBER_SET(x, v)           do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define ETM_PIDR0_PARTNUMBER_GET(x)              (((x) >> 0) & 0xff)

/** Peripheral Identification Register 1 @multiple */
#define ETM_PIDR1_ADDR                               0xe0041fe4
/** Part Number [11:8] @multiple */
  #define ETM_PIDR1_PARTNUMBER_SHIFT               0
  #define ETM_PIDR1_PARTNUMBER(v)                  ((v) << 0)
  #define ETM_PIDR1_PARTNUMBER_SET(x, v)           do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define ETM_PIDR1_PARTNUMBER_GET(x)              (((x) >> 0) & 0xf)
/** JEP106 identity code [3:0] @multiple */
  #define ETM_PIDR1_JEP106_IDENTITY_CODE_SHIFT     4
  #define ETM_PIDR1_JEP106_IDENTITY_CODE(v)        ((v) << 4)
  #define ETM_PIDR1_JEP106_IDENTITY_CODE_SET(x, v) do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define ETM_PIDR1_JEP106_IDENTITY_CODE_GET(x)    (((x) >> 4) & 0xf)

/** Peripheral Identification Register 2 @multiple */
#define ETM_PIDR2_ADDR                               0xe0041fe8
/** JEP106 identity code [6:4] @multiple */
  #define ETM_PIDR2_JEP106_IDENTITY_CODE_SHIFT     0
  #define ETM_PIDR2_JEP106_IDENTITY_CODE(v)        ((v) << 0)
  #define ETM_PIDR2_JEP106_IDENTITY_CODE_SET(x, v) do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define ETM_PIDR2_JEP106_IDENTITY_CODE_GET(x)    (((x) >> 0) & 0x7)
/** Revision @multiple */
  #define ETM_PIDR2_REVISION_SHIFT                 4
  #define ETM_PIDR2_REVISION(v)                    ((v) << 4)
  #define ETM_PIDR2_REVISION_SET(x, v)             do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define ETM_PIDR2_REVISION_GET(x)                (((x) >> 4) & 0xf)

/** Peripheral Identification Register 3 @multiple */
#define ETM_PIDR3_ADDR                               0xe0041fec
/** Customer Modified @multiple */
  #define ETM_PIDR3_CUSTOMERMODIFIED_SHIFT         0
  #define ETM_PIDR3_CUSTOMERMODIFIED(v)            ((v) << 0)
  #define ETM_PIDR3_CUSTOMERMODIFIED_SET(x, v)     do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define ETM_PIDR3_CUSTOMERMODIFIED_GET(x)        (((x) >> 0) & 0xf)
/** RevAnd @multiple */
  #define ETM_PIDR3_REVAND_SHIFT                   4
  #define ETM_PIDR3_REVAND(v)                      ((v) << 4)
  #define ETM_PIDR3_REVAND_SET(x, v)               do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define ETM_PIDR3_REVAND_GET(x)                  (((x) >> 4) & 0xf)

/** Component Identification Register 0 @multiple */
#define ETM_CIDR0_ADDR                               0xe0041ff0
/** Preamble @multiple */
  #define ETM_CIDR0_PREAMBLE_SHIFT                 0
  #define ETM_CIDR0_PREAMBLE(v)                    ((v) << 0)
  #define ETM_CIDR0_PREAMBLE_SET(x, v)             do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define ETM_CIDR0_PREAMBLE_GET(x)                (((x) >> 0) & 0xff)

/** Component Identification Register 1 @multiple */
#define ETM_CIDR1_ADDR                               0xe0041ff4
/** Preamble @multiple */
  #define ETM_CIDR1_PREAMBLE_SHIFT                 0
  #define ETM_CIDR1_PREAMBLE(v)                    ((v) << 0)
  #define ETM_CIDR1_PREAMBLE_SET(x, v)             do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define ETM_CIDR1_PREAMBLE_GET(x)                (((x) >> 0) & 0xf)
/** Component class @multiple */
  #define ETM_CIDR1_COMPONENTCLASS_SHIFT           4
  #define ETM_CIDR1_COMPONENTCLASS(v)              ((ETM_CIDR1_COMPONENTCLASS_##v) << 4)
  #define ETM_CIDR1_COMPONENTCLASS_SET(x, v)       do { (x) = (((x) & ~0xf0) | ((ETM_CIDR1_COMPONENTCLASS_##v) << 4)); } while(0)
  #define ETM_CIDR1_COMPONENTCLASS_GET(x)          (((x) >> 4) & 0xf)
    #define ETM_CIDR1_COMPONENTCLASS_ROM_TABLE       0x00000001
    #define ETM_CIDR1_COMPONENTCLASS_CORESIGHT_COMPONENT 0x00000009
    #define ETM_CIDR1_COMPONENTCLASS_PRIMECELL_OF_SYSTEM_COMPONENT_WITH_NO_STANDARDIZED_REGISTER_LAYOUT_FOR_BACKWARD_COMPATIBILITY 0x0000000f

/** Component Identification Register 2 @multiple */
#define ETM_CIDR2_ADDR                               0xe0041ff8
/** Preamble @multiple */
  #define ETM_CIDR2_PREAMBLE_SHIFT                 0
  #define ETM_CIDR2_PREAMBLE(v)                    ((v) << 0)
  #define ETM_CIDR2_PREAMBLE_SET(x, v)             do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define ETM_CIDR2_PREAMBLE_GET(x)                (((x) >> 0) & 0xff)

/** Component Identification Register 3 @multiple */
#define ETM_CIDR3_ADDR                               0xe0041ffc
/** Preamble @multiple */
  #define ETM_CIDR3_PREAMBLE_SHIFT                 0
  #define ETM_CIDR3_PREAMBLE(v)                    ((v) << 0)
  #define ETM_CIDR3_PREAMBLE_SET(x, v)             do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define ETM_CIDR3_PREAMBLE_GET(x)                (((x) >> 0) & 0xff)

#endif

