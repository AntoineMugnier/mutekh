/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -o cdefs cdefs_use_reg_meask=1 cdefs_use_field_set=1                  \
     cdefs_use_field_get=1 reg_prefix=STM32 field_prefix=STM32                 \
     cdefs_use_field_mask=1 cdefs_use_field_setval=1
*/

#ifndef _RCC_BFGEN_DEFS_
#define _RCC_BFGEN_DEFS_

/** Clock control register @multiple */
#define STM32_RCC_CR_ADDR                            0x00000000
/** MSI clock enable @multiple */
  #define STM32_RCC_CR_MSION_MASK                  0x00000001
  #define STM32_RCC_CR_MSION                       0x00000001
  #define STM32_RCC_CR_MSION_SET(x, v)             do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_CR_MSION_GET(x)                (((x) >> 0) & 0x1)
/** MSI clock ready flag @multiple */
  #define STM32_RCC_CR_MSIRDY_MASK                 0x00000001
  #define STM32_RCC_CR_MSIRDY                      0x00000002
  #define STM32_RCC_CR_MSIRDY_SET(x, v)            do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_CR_MSIRDY_GET(x)               (((x) >> 1) & 0x1)
/** MSI clock PLL enable @multiple */
  #define STM32_RCC_CR_MSIPLLEN_MASK               0x00000001
  #define STM32_RCC_CR_MSIPLLEN                    0x00000004
  #define STM32_RCC_CR_MSIPLLEN_SET(x, v)          do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define STM32_RCC_CR_MSIPLLEN_GET(x)             (((x) >> 2) & 0x1)
/** MSI clock range selection @multiple */
  #define STM32_RCC_CR_MSIRGSEL_MASK               0x00000001
  #define STM32_RCC_CR_MSIRGSEL                    0x00000008
  #define STM32_RCC_CR_MSIRGSEL_SET(x, v)          do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define STM32_RCC_CR_MSIRGSEL_GET(x)             (((x) >> 3) & 0x1)
/** MSI clock ranges @multiple */
  #define STM32_RCC_CR_MSIRANGE_MASK               0x0000000f
  #define STM32_RCC_CR_MSIRANGE(v)                 ((v) << 4)
  #define STM32_RCC_CR_MSIRANGE_SET(x, v)          do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define STM32_RCC_CR_MSIRANGE_GET(x)             (((x) >> 4) & 0xf)
/** HSI clock enable @multiple */
  #define STM32_RCC_CR_HSION_MASK                  0x00000001
  #define STM32_RCC_CR_HSION                       0x00000100
  #define STM32_RCC_CR_HSION_SET(x, v)             do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define STM32_RCC_CR_HSION_GET(x)                (((x) >> 8) & 0x1)
/** HSI always enable for peripheral kernels @multiple */
  #define STM32_RCC_CR_HSIKERON_MASK               0x00000001
  #define STM32_RCC_CR_HSIKERON                    0x00000200
  #define STM32_RCC_CR_HSIKERON_SET(x, v)          do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
  #define STM32_RCC_CR_HSIKERON_GET(x)             (((x) >> 9) & 0x1)
/** HSI clock ready flag @multiple */
  #define STM32_RCC_CR_HSIRDY_MASK                 0x00000001
  #define STM32_RCC_CR_HSIRDY                      0x00000400
  #define STM32_RCC_CR_HSIRDY_SET(x, v)            do { (x) = (((x) & ~0x400) | ((v) << 10)); } while(0)
  #define STM32_RCC_CR_HSIRDY_GET(x)               (((x) >> 10) & 0x1)
/** HSI automatic start from Stop @multiple */
  #define STM32_RCC_CR_HSIASFS_MASK                0x00000001
  #define STM32_RCC_CR_HSIASFS                     0x00000800
  #define STM32_RCC_CR_HSIASFS_SET(x, v)           do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
  #define STM32_RCC_CR_HSIASFS_GET(x)              (((x) >> 11) & 0x1)
/** HSE clock enable @multiple */
  #define STM32_RCC_CR_HSEON_MASK                  0x00000001
  #define STM32_RCC_CR_HSEON                       0x00010000
  #define STM32_RCC_CR_HSEON_SET(x, v)             do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define STM32_RCC_CR_HSEON_GET(x)                (((x) >> 16) & 0x1)
/** HSE clock ready flag @multiple */
  #define STM32_RCC_CR_HSERDY_MASK                 0x00000001
  #define STM32_RCC_CR_HSERDY                      0x00020000
  #define STM32_RCC_CR_HSERDY_SET(x, v)            do { (x) = (((x) & ~0x20000) | ((v) << 17)); } while(0)
  #define STM32_RCC_CR_HSERDY_GET(x)               (((x) >> 17) & 0x1)
/** HSE crystal oscillator bypass @multiple */
  #define STM32_RCC_CR_HSEBYP_MASK                 0x00000001
  #define STM32_RCC_CR_HSEBYP                      0x00040000
  #define STM32_RCC_CR_HSEBYP_SET(x, v)            do { (x) = (((x) & ~0x40000) | ((v) << 18)); } while(0)
  #define STM32_RCC_CR_HSEBYP_GET(x)               (((x) >> 18) & 0x1)
/** Clock security system enable @multiple */
  #define STM32_RCC_CR_CSSON_MASK                  0x00000001
  #define STM32_RCC_CR_CSSON                       0x00080000
  #define STM32_RCC_CR_CSSON_SET(x, v)             do { (x) = (((x) & ~0x80000) | ((v) << 19)); } while(0)
  #define STM32_RCC_CR_CSSON_GET(x)                (((x) >> 19) & 0x1)
/** Main PLL enable @multiple */
  #define STM32_RCC_CR_PLLON_MASK                  0x00000001
  #define STM32_RCC_CR_PLLON                       0x01000000
  #define STM32_RCC_CR_PLLON_SET(x, v)             do { (x) = (((x) & ~0x1000000) | ((v) << 24)); } while(0)
  #define STM32_RCC_CR_PLLON_GET(x)                (((x) >> 24) & 0x1)
/** Main PLL clock ready flag @multiple */
  #define STM32_RCC_CR_PLLRDY_MASK                 0x00000001
  #define STM32_RCC_CR_PLLRDY                      0x02000000
  #define STM32_RCC_CR_PLLRDY_SET(x, v)            do { (x) = (((x) & ~0x2000000) | ((v) << 25)); } while(0)
  #define STM32_RCC_CR_PLLRDY_GET(x)               (((x) >> 25) & 0x1)
/** SAI1 PLL enable @multiple */
  #define STM32_RCC_CR_PLLSAI1ON_MASK              0x00000001
  #define STM32_RCC_CR_PLLSAI1ON                   0x04000000
  #define STM32_RCC_CR_PLLSAI1ON_SET(x, v)         do { (x) = (((x) & ~0x4000000) | ((v) << 26)); } while(0)
  #define STM32_RCC_CR_PLLSAI1ON_GET(x)            (((x) >> 26) & 0x1)
/** SAI1 PLL clock ready flag @multiple */
  #define STM32_RCC_CR_PLLSAI1RDY_MASK             0x00000001
  #define STM32_RCC_CR_PLLSAI1RDY                  0x08000000
  #define STM32_RCC_CR_PLLSAI1RDY_SET(x, v)        do { (x) = (((x) & ~0x8000000) | ((v) << 27)); } while(0)
  #define STM32_RCC_CR_PLLSAI1RDY_GET(x)           (((x) >> 27) & 0x1)
/** SAI2 PLL enable @multiple */
  #define STM32_RCC_CR_PLLSAI2ON_MASK              0x00000001
  #define STM32_RCC_CR_PLLSAI2ON                   0x10000000
  #define STM32_RCC_CR_PLLSAI2ON_SET(x, v)         do { (x) = (((x) & ~0x10000000) | ((v) << 28)); } while(0)
  #define STM32_RCC_CR_PLLSAI2ON_GET(x)            (((x) >> 28) & 0x1)
/** SAI2 PLL clock ready flag @multiple */
  #define STM32_RCC_CR_PLLSAI2RDY_MASK             0x00000001
  #define STM32_RCC_CR_PLLSAI2RDY                  0x20000000
  #define STM32_RCC_CR_PLLSAI2RDY_SET(x, v)        do { (x) = (((x) & ~0x20000000) | ((v) << 29)); } while(0)
  #define STM32_RCC_CR_PLLSAI2RDY_GET(x)           (((x) >> 29) & 0x1)

/** Internal clock sources calibration register @multiple */
#define STM32_RCC_ICSCR_ADDR                         0x00000004
/** MSI clock calibration @multiple */
  #define STM32_RCC_ICSCR_MSICAL_MASK              0x000000ff
  #define STM32_RCC_ICSCR_MSICAL(v)                ((v) << 0)
  #define STM32_RCC_ICSCR_MSICAL_SET(x, v)         do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define STM32_RCC_ICSCR_MSICAL_GET(x)            (((x) >> 0) & 0xff)
/** MSI clock trimming @multiple */
  #define STM32_RCC_ICSCR_MSITRIM_MASK             0x000000ff
  #define STM32_RCC_ICSCR_MSITRIM(v)               ((v) << 8)
  #define STM32_RCC_ICSCR_MSITRIM_SET(x, v)        do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define STM32_RCC_ICSCR_MSITRIM_GET(x)           (((x) >> 8) & 0xff)
/** HSI clock calibration @multiple */
  #define STM32_RCC_ICSCR_HSICAL_MASK              0x000000ff
  #define STM32_RCC_ICSCR_HSICAL(v)                ((v) << 16)
  #define STM32_RCC_ICSCR_HSICAL_SET(x, v)         do { (x) = (((x) & ~0xff0000) | ((v) << 16)); } while(0)
  #define STM32_RCC_ICSCR_HSICAL_GET(x)            (((x) >> 16) & 0xff)
/** HSI clock trimming @multiple */
  #define STM32_RCC_ICSCR_HSITRIM_MASK             0x0000001f
  #define STM32_RCC_ICSCR_HSITRIM(v)               ((v) << 24)
  #define STM32_RCC_ICSCR_HSITRIM_SET(x, v)        do { (x) = (((x) & ~0x1f000000) | ((v) << 24)); } while(0)
  #define STM32_RCC_ICSCR_HSITRIM_GET(x)           (((x) >> 24) & 0x1f)

/** Clock configuration register @multiple */
#define STM32_RCC_CFGR_ADDR                          0x00000008
/** System clock switch @multiple */
  #define STM32_RCC_CFGR_SW_MASK                   0x00000003
  #define STM32_RCC_CFGR_SW(v)                     ((v) << 0)
  #define STM32_RCC_CFGR_SW_SET(x, v)              do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define STM32_RCC_CFGR_SW_GET(x)                 (((x) >> 0) & 0x3)
/** System clock switch status @multiple */
  #define STM32_RCC_CFGR_SWS_MASK                  0x00000003
  #define STM32_RCC_CFGR_SWS(v)                    ((v) << 2)
  #define STM32_RCC_CFGR_SWS_SET(x, v)             do { (x) = (((x) & ~0xc) | ((v) << 2)); } while(0)
  #define STM32_RCC_CFGR_SWS_GET(x)                (((x) >> 2) & 0x3)
/** AHB prescaler @multiple */
  #define STM32_RCC_CFGR_HPRE_MASK                 0x0000000f
  #define STM32_RCC_CFGR_HPRE(v)                   ((v) << 4)
  #define STM32_RCC_CFGR_HPRE_SET(x, v)            do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define STM32_RCC_CFGR_HPRE_GET(x)               (((x) >> 4) & 0xf)
/** PB low-speed prescaler (APB1) @multiple */
  #define STM32_RCC_CFGR_PPRE1_MASK                0x00000007
  #define STM32_RCC_CFGR_PPRE1(v)                  ((v) << 8)
  #define STM32_RCC_CFGR_PPRE1_SET(x, v)           do { (x) = (((x) & ~0x700) | ((v) << 8)); } while(0)
  #define STM32_RCC_CFGR_PPRE1_GET(x)              (((x) >> 8) & 0x7)
/** APB high-speed prescaler (APB2) @multiple */
  #define STM32_RCC_CFGR_PPRE2_MASK                0x00000007
  #define STM32_RCC_CFGR_PPRE2(v)                  ((v) << 11)
  #define STM32_RCC_CFGR_PPRE2_SET(x, v)           do { (x) = (((x) & ~0x3800) | ((v) << 11)); } while(0)
  #define STM32_RCC_CFGR_PPRE2_GET(x)              (((x) >> 11) & 0x7)
/** Wakeup from Stop and CSS backup clock selection @multiple */
  #define STM32_RCC_CFGR_STOPWUCK_MASK             0x00000001
  #define STM32_RCC_CFGR_STOPWUCK                  0x00008000
  #define STM32_RCC_CFGR_STOPWUCK_SET(x, v)        do { (x) = (((x) & ~0x8000) | ((v) << 15)); } while(0)
  #define STM32_RCC_CFGR_STOPWUCK_GET(x)           (((x) >> 15) & 0x1)
/** Microcontroller clock output @multiple */
  #define STM32_RCC_CFGR_MCOSEL_MASK               0x00000007
  #define STM32_RCC_CFGR_MCOSEL(v)                 ((v) << 24)
  #define STM32_RCC_CFGR_MCOSEL_SET(x, v)          do { (x) = (((x) & ~0x7000000) | ((v) << 24)); } while(0)
  #define STM32_RCC_CFGR_MCOSEL_GET(x)             (((x) >> 24) & 0x7)
/** Microcontroller clock output prescaler @multiple */
  #define STM32_RCC_CFGR_MCOPRE_MASK               0x00000007
  #define STM32_RCC_CFGR_MCOPRE(v)                 ((v) << 28)
  #define STM32_RCC_CFGR_MCOPRE_SET(x, v)          do { (x) = (((x) & ~0x70000000) | ((v) << 28)); } while(0)
  #define STM32_RCC_CFGR_MCOPRE_GET(x)             (((x) >> 28) & 0x7)

/** PLL configuration register @multiple */
#define STM32_RCC_PLLCFGR_ADDR                       0x0000000c
/** Main PLL, PLLSAI1 and PLLSAI2 entry clock source @multiple */
  #define STM32_RCC_PLLCFGR_PLLSRC_MASK            0x00000003
  #define STM32_RCC_PLLCFGR_PLLSRC(v)              ((v) << 0)
  #define STM32_RCC_PLLCFGR_PLLSRC_SET(x, v)       do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define STM32_RCC_PLLCFGR_PLLSRC_GET(x)          (((x) >> 0) & 0x3)
/** Division factor for the main PLL and audio PLL (PLLSAI1 and PLLSAI2) input
   clock @multiple */
  #define STM32_RCC_PLLCFGR_PLLM_MASK              0x00000007
  #define STM32_RCC_PLLCFGR_PLLM(v)                ((v) << 4)
  #define STM32_RCC_PLLCFGR_PLLM_SET(x, v)         do { (x) = (((x) & ~0x70) | ((v) << 4)); } while(0)
  #define STM32_RCC_PLLCFGR_PLLM_GET(x)            (((x) >> 4) & 0x7)
/** Main PLL multiplication factor for VCO @multiple */
  #define STM32_RCC_PLLCFGR_PLLN_MASK              0x0000007f
  #define STM32_RCC_PLLCFGR_PLLN(v)                ((v) << 8)
  #define STM32_RCC_PLLCFGR_PLLN_SET(x, v)         do { (x) = (((x) & ~0x7f00) | ((v) << 8)); } while(0)
  #define STM32_RCC_PLLCFGR_PLLN_GET(x)            (((x) >> 8) & 0x7f)
/** Main PLL PLLSAI3CLK output enable @multiple */
  #define STM32_RCC_PLLCFGR_PLLPEN_MASK            0x00000001
  #define STM32_RCC_PLLCFGR_PLLPEN                 0x00010000
  #define STM32_RCC_PLLCFGR_PLLPEN_SET(x, v)       do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define STM32_RCC_PLLCFGR_PLLPEN_GET(x)          (((x) >> 16) & 0x1)
/** Main PLL division factor for PLLSAI3CLK (SAI1 and SAI2 clock) @multiple */
  #define STM32_RCC_PLLCFGR_PLLP_MASK              0x00000001
  #define STM32_RCC_PLLCFGR_PLLP                   0x00020000
  #define STM32_RCC_PLLCFGR_PLLP_SET(x, v)         do { (x) = (((x) & ~0x20000) | ((v) << 17)); } while(0)
  #define STM32_RCC_PLLCFGR_PLLP_GET(x)            (((x) >> 17) & 0x1)
/** Main PLL PLLUSB1CLK output enable @multiple */
  #define STM32_RCC_PLLCFGR_PLLQEN_MASK            0x00000001
  #define STM32_RCC_PLLCFGR_PLLQEN                 0x00100000
  #define STM32_RCC_PLLCFGR_PLLQEN_SET(x, v)       do { (x) = (((x) & ~0x100000) | ((v) << 20)); } while(0)
  #define STM32_RCC_PLLCFGR_PLLQEN_GET(x)          (((x) >> 20) & 0x1)
/** Main PLL division factor for PLLUSB1CLK(48 MHz clock) @multiple */
  #define STM32_RCC_PLLCFGR_PLLQ_MASK              0x00000003
  #define STM32_RCC_PLLCFGR_PLLQ(v)                ((v) << 21)
  #define STM32_RCC_PLLCFGR_PLLQ_SET(x, v)         do { (x) = (((x) & ~0x600000) | ((v) << 21)); } while(0)
  #define STM32_RCC_PLLCFGR_PLLQ_GET(x)            (((x) >> 21) & 0x3)
/** Main PLL PLLCLK output enable @multiple */
  #define STM32_RCC_PLLCFGR_PLLREN_MASK            0x00000001
  #define STM32_RCC_PLLCFGR_PLLREN                 0x01000000
  #define STM32_RCC_PLLCFGR_PLLREN_SET(x, v)       do { (x) = (((x) & ~0x1000000) | ((v) << 24)); } while(0)
  #define STM32_RCC_PLLCFGR_PLLREN_GET(x)          (((x) >> 24) & 0x1)
/** Main PLL division factor for PLLCLK (system clock) @multiple */
  #define STM32_RCC_PLLCFGR_PLLR_MASK              0x00000003
  #define STM32_RCC_PLLCFGR_PLLR(v)                ((v) << 25)
  #define STM32_RCC_PLLCFGR_PLLR_SET(x, v)         do { (x) = (((x) & ~0x6000000) | ((v) << 25)); } while(0)
  #define STM32_RCC_PLLCFGR_PLLR_GET(x)            (((x) >> 25) & 0x3)

/** PLLSAI1 configuration register @multiple */
#define STM32_RCC_PLLSAI1CFGR_ADDR                   0x00000010
/** SAI1PLL multiplication factor for VCO @multiple */
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1N_MASK      0x0000007f
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1N(v)        ((v) << 8)
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1N_SET(x, v) do { (x) = (((x) & ~0x7f00) | ((v) << 8)); } while(0)
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1N_GET(x)    (((x) >> 8) & 0x7f)
/** SAI1PLL PLLSAI1CLK output enable @multiple */
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1PEN_MASK    0x00000001
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1PEN         0x00010000
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1PEN_SET(x, v) do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1PEN_GET(x)  (((x) >> 16) & 0x1)
/** SAI1PLL division factor for PLLSAI1CLK (SAI1 or SAI2 clock) @multiple */
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1P_MASK      0x00000001
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1P           0x00020000
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1P_SET(x, v) do { (x) = (((x) & ~0x20000) | ((v) << 17)); } while(0)
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1P_GET(x)    (((x) >> 17) & 0x1)
/** SAI1PLL PLLUSB2CLK output enable @multiple */
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1QEN_MASK    0x00000001
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1QEN         0x00100000
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1QEN_SET(x, v) do { (x) = (((x) & ~0x100000) | ((v) << 20)); } while(0)
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1QEN_GET(x)  (((x) >> 20) & 0x1)
/** SAI1PLL division factor for PLLUSB2CLK (48 MHz clock) @multiple */
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1Q_MASK      0x00000003
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1Q(v)        ((v) << 21)
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1Q_SET(x, v) do { (x) = (((x) & ~0x600000) | ((v) << 21)); } while(0)
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1Q_GET(x)    (((x) >> 21) & 0x3)
/** PLLSAI1 PLLADC1CLK output enable @multiple */
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1REN_MASK    0x00000001
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1REN         0x01000000
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1REN_SET(x, v) do { (x) = (((x) & ~0x1000000) | ((v) << 24)); } while(0)
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1REN_GET(x)  (((x) >> 24) & 0x1)
/** PLLSAI1 division factor for PLLADC1CLK (ADC clock) @multiple */
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1R_MASK      0x00000003
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1R(v)        ((v) << 25)
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1R_SET(x, v) do { (x) = (((x) & ~0x6000000) | ((v) << 25)); } while(0)
  #define STM32_RCC_PLLSAI1CFGR_PLLSAI1R_GET(x)    (((x) >> 25) & 0x3)

/** PLLSAI2 configuration register @multiple */
#define STM32_RCC_PLLSAI2CFGR_ADDR                   0x00000014
/** SAI2PLL multiplication factor for VCO @multiple */
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2N_MASK      0x0000007f
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2N(v)        ((v) << 8)
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2N_SET(x, v) do { (x) = (((x) & ~0x7f00) | ((v) << 8)); } while(0)
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2N_GET(x)    (((x) >> 8) & 0x7f)
/** SAI2PLL PLLSAI2CLK output enable @multiple */
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2PEN_MASK    0x00000001
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2PEN         0x00010000
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2PEN_SET(x, v) do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2PEN_GET(x)  (((x) >> 16) & 0x1)
/** SAI1PLL division factor for PLLSAI2CLK (SAI1 or SAI2 clock) @multiple */
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2P_MASK      0x00000001
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2P           0x00020000
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2P_SET(x, v) do { (x) = (((x) & ~0x20000) | ((v) << 17)); } while(0)
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2P_GET(x)    (((x) >> 17) & 0x1)
/** PLLSAI2 PLLADC2CLK output enable @multiple */
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2REN_MASK    0x00000001
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2REN         0x01000000
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2REN_SET(x, v) do { (x) = (((x) & ~0x1000000) | ((v) << 24)); } while(0)
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2REN_GET(x)  (((x) >> 24) & 0x1)
/** PLLSAI2 division factor for PLLADC2CLK (ADC clock) @multiple */
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2R_MASK      0x00000003
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2R(v)        ((v) << 25)
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2R_SET(x, v) do { (x) = (((x) & ~0x6000000) | ((v) << 25)); } while(0)
  #define STM32_RCC_PLLSAI2CFGR_PLLSAI2R_GET(x)    (((x) >> 25) & 0x3)

/** Clock interrupt enable register @multiple */
#define STM32_RCC_CIER_ADDR                          0x00000018
/** LSI ready interrupt enable @multiple */
  #define STM32_RCC_CIER_LSIRDYIE_MASK             0x00000001
  #define STM32_RCC_CIER_LSIRDYIE                  0x00000001
  #define STM32_RCC_CIER_LSIRDYIE_SET(x, v)        do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_CIER_LSIRDYIE_GET(x)           (((x) >> 0) & 0x1)
/** LSE ready interrupt enable @multiple */
  #define STM32_RCC_CIER_LSERDYIE_MASK             0x00000001
  #define STM32_RCC_CIER_LSERDYIE                  0x00000002
  #define STM32_RCC_CIER_LSERDYIE_SET(x, v)        do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_CIER_LSERDYIE_GET(x)           (((x) >> 1) & 0x1)
/** MSI ready interrupt enable @multiple */
  #define STM32_RCC_CIER_MSIRDYIE_MASK             0x00000001
  #define STM32_RCC_CIER_MSIRDYIE                  0x00000004
  #define STM32_RCC_CIER_MSIRDYIE_SET(x, v)        do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define STM32_RCC_CIER_MSIRDYIE_GET(x)           (((x) >> 2) & 0x1)
/** HSI ready interrupt enable @multiple */
  #define STM32_RCC_CIER_HSIRDYIE_MASK             0x00000001
  #define STM32_RCC_CIER_HSIRDYIE                  0x00000008
  #define STM32_RCC_CIER_HSIRDYIE_SET(x, v)        do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define STM32_RCC_CIER_HSIRDYIE_GET(x)           (((x) >> 3) & 0x1)
/** HSE ready interrupt enable @multiple */
  #define STM32_RCC_CIER_HSERDYIE_MASK             0x00000001
  #define STM32_RCC_CIER_HSERDYIE                  0x00000010
  #define STM32_RCC_CIER_HSERDYIE_SET(x, v)        do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define STM32_RCC_CIER_HSERDYIE_GET(x)           (((x) >> 4) & 0x1)
/** PLL ready interrupt enable @multiple */
  #define STM32_RCC_CIER_PLLRDYIE_MASK             0x00000001
  #define STM32_RCC_CIER_PLLRDYIE                  0x00000020
  #define STM32_RCC_CIER_PLLRDYIE_SET(x, v)        do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define STM32_RCC_CIER_PLLRDYIE_GET(x)           (((x) >> 5) & 0x1)
/** PLLSAI1 ready interrupt enable @multiple */
  #define STM32_RCC_CIER_PLLSAI1RDYIE_MASK         0x00000001
  #define STM32_RCC_CIER_PLLSAI1RDYIE              0x00000040
  #define STM32_RCC_CIER_PLLSAI1RDYIE_SET(x, v)    do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
  #define STM32_RCC_CIER_PLLSAI1RDYIE_GET(x)       (((x) >> 6) & 0x1)
/** PLLSAI2 ready interrupt enable @multiple */
  #define STM32_RCC_CIER_PLLSAI2RDYIE_MASK         0x00000001
  #define STM32_RCC_CIER_PLLSAI2RDYIE              0x00000080
  #define STM32_RCC_CIER_PLLSAI2RDYIE_SET(x, v)    do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
  #define STM32_RCC_CIER_PLLSAI2RDYIE_GET(x)       (((x) >> 7) & 0x1)
/** LSE clock security system interrupt enable @multiple */
  #define STM32_RCC_CIER_LSECSSIE_MASK             0x00000001
  #define STM32_RCC_CIER_LSECSSIE                  0x00000200
  #define STM32_RCC_CIER_LSECSSIE_SET(x, v)        do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
  #define STM32_RCC_CIER_LSECSSIE_GET(x)           (((x) >> 9) & 0x1)

/** Clock interrupt flag register @multiple */
#define STM32_RCC_CIFR_ADDR                          0x0000001c
/** LSI ready interrupt flag @multiple */
  #define STM32_RCC_CIFR_LSIRDYF_MASK              0x00000001
  #define STM32_RCC_CIFR_LSIRDYF                   0x00000001
  #define STM32_RCC_CIFR_LSIRDYF_SET(x, v)         do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_CIFR_LSIRDYF_GET(x)            (((x) >> 0) & 0x1)
/** LSE ready interrupt flag @multiple */
  #define STM32_RCC_CIFR_LSERDYF_MASK              0x00000001
  #define STM32_RCC_CIFR_LSERDYF                   0x00000002
  #define STM32_RCC_CIFR_LSERDYF_SET(x, v)         do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_CIFR_LSERDYF_GET(x)            (((x) >> 1) & 0x1)
/** MSI ready interrupt flag @multiple */
  #define STM32_RCC_CIFR_MSIRDYF_MASK              0x00000001
  #define STM32_RCC_CIFR_MSIRDYF                   0x00000004
  #define STM32_RCC_CIFR_MSIRDYF_SET(x, v)         do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define STM32_RCC_CIFR_MSIRDYF_GET(x)            (((x) >> 2) & 0x1)
/** HSI ready interrupt flag @multiple */
  #define STM32_RCC_CIFR_HSIRDYF_MASK              0x00000001
  #define STM32_RCC_CIFR_HSIRDYF                   0x00000008
  #define STM32_RCC_CIFR_HSIRDYF_SET(x, v)         do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define STM32_RCC_CIFR_HSIRDYF_GET(x)            (((x) >> 3) & 0x1)
/** HSE ready interrupt flag @multiple */
  #define STM32_RCC_CIFR_HSERDYF_MASK              0x00000001
  #define STM32_RCC_CIFR_HSERDYF                   0x00000010
  #define STM32_RCC_CIFR_HSERDYF_SET(x, v)         do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define STM32_RCC_CIFR_HSERDYF_GET(x)            (((x) >> 4) & 0x1)
/** PLL ready interrupt flag @multiple */
  #define STM32_RCC_CIFR_PLLRDYF_MASK              0x00000001
  #define STM32_RCC_CIFR_PLLRDYF                   0x00000020
  #define STM32_RCC_CIFR_PLLRDYF_SET(x, v)         do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define STM32_RCC_CIFR_PLLRDYF_GET(x)            (((x) >> 5) & 0x1)
/** PLLSAI1 ready interrupt flag @multiple */
  #define STM32_RCC_CIFR_PLLSAI1RDYF_MASK          0x00000001
  #define STM32_RCC_CIFR_PLLSAI1RDYF               0x00000040
  #define STM32_RCC_CIFR_PLLSAI1RDYF_SET(x, v)     do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
  #define STM32_RCC_CIFR_PLLSAI1RDYF_GET(x)        (((x) >> 6) & 0x1)
/** PLLSAI2 ready interrupt flag @multiple */
  #define STM32_RCC_CIFR_PLLSAI2RDYF_MASK          0x00000001
  #define STM32_RCC_CIFR_PLLSAI2RDYF               0x00000080
  #define STM32_RCC_CIFR_PLLSAI2RDYF_SET(x, v)     do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
  #define STM32_RCC_CIFR_PLLSAI2RDYF_GET(x)        (((x) >> 7) & 0x1)
/** Clock security system interrupt flag @multiple */
  #define STM32_RCC_CIFR_CSSF_MASK                 0x00000001
  #define STM32_RCC_CIFR_CSSF                      0x00000100
  #define STM32_RCC_CIFR_CSSF_SET(x, v)            do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define STM32_RCC_CIFR_CSSF_GET(x)               (((x) >> 8) & 0x1)
/** LSE Clock security system interrupt flag @multiple */
  #define STM32_RCC_CIFR_LSECSSF_MASK              0x00000001
  #define STM32_RCC_CIFR_LSECSSF                   0x00000200
  #define STM32_RCC_CIFR_LSECSSF_SET(x, v)         do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
  #define STM32_RCC_CIFR_LSECSSF_GET(x)            (((x) >> 9) & 0x1)

/** Clock interrupt clear register @multiple */
#define STM32_RCC_CICR_ADDR                          0x00000020
/** LSI ready interrupt clear @multiple */
  #define STM32_RCC_CICR_LSIRDYC_MASK              0x00000001
  #define STM32_RCC_CICR_LSIRDYC                   0x00000001
  #define STM32_RCC_CICR_LSIRDYC_SET(x, v)         do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_CICR_LSIRDYC_GET(x)            (((x) >> 0) & 0x1)
/** LSE ready interrupt clear @multiple */
  #define STM32_RCC_CICR_LSERDYC_MASK              0x00000001
  #define STM32_RCC_CICR_LSERDYC                   0x00000002
  #define STM32_RCC_CICR_LSERDYC_SET(x, v)         do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_CICR_LSERDYC_GET(x)            (((x) >> 1) & 0x1)
/** MSI ready interrupt clear @multiple */
  #define STM32_RCC_CICR_MSIRDYC_MASK              0x00000001
  #define STM32_RCC_CICR_MSIRDYC                   0x00000004
  #define STM32_RCC_CICR_MSIRDYC_SET(x, v)         do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define STM32_RCC_CICR_MSIRDYC_GET(x)            (((x) >> 2) & 0x1)
/** HSI ready interrupt clear @multiple */
  #define STM32_RCC_CICR_HSIRDYC_MASK              0x00000001
  #define STM32_RCC_CICR_HSIRDYC                   0x00000008
  #define STM32_RCC_CICR_HSIRDYC_SET(x, v)         do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define STM32_RCC_CICR_HSIRDYC_GET(x)            (((x) >> 3) & 0x1)
/** HSE ready interrupt clear @multiple */
  #define STM32_RCC_CICR_HSERDYC_MASK              0x00000001
  #define STM32_RCC_CICR_HSERDYC                   0x00000010
  #define STM32_RCC_CICR_HSERDYC_SET(x, v)         do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define STM32_RCC_CICR_HSERDYC_GET(x)            (((x) >> 4) & 0x1)
/** PLL ready interrupt clear @multiple */
  #define STM32_RCC_CICR_PLLRDYC_MASK              0x00000001
  #define STM32_RCC_CICR_PLLRDYC                   0x00000020
  #define STM32_RCC_CICR_PLLRDYC_SET(x, v)         do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define STM32_RCC_CICR_PLLRDYC_GET(x)            (((x) >> 5) & 0x1)
/** PLLSAI1 ready interrupt clear @multiple */
  #define STM32_RCC_CICR_PLLSAI1RDYC_MASK          0x00000001
  #define STM32_RCC_CICR_PLLSAI1RDYC               0x00000040
  #define STM32_RCC_CICR_PLLSAI1RDYC_SET(x, v)     do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
  #define STM32_RCC_CICR_PLLSAI1RDYC_GET(x)        (((x) >> 6) & 0x1)
/** PLLSAI2 ready interrupt clear @multiple */
  #define STM32_RCC_CICR_PLLSAI2RDYC_MASK          0x00000001
  #define STM32_RCC_CICR_PLLSAI2RDYC               0x00000080
  #define STM32_RCC_CICR_PLLSAI2RDYC_SET(x, v)     do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
  #define STM32_RCC_CICR_PLLSAI2RDYC_GET(x)        (((x) >> 7) & 0x1)
/** Clock security system interrupt clear @multiple */
  #define STM32_RCC_CICR_CSSC_MASK                 0x00000001
  #define STM32_RCC_CICR_CSSC                      0x00000100
  #define STM32_RCC_CICR_CSSC_SET(x, v)            do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define STM32_RCC_CICR_CSSC_GET(x)               (((x) >> 8) & 0x1)
/** LSE Clock security system interrupt clear @multiple */
  #define STM32_RCC_CICR_LSECSSC_MASK              0x00000001
  #define STM32_RCC_CICR_LSECSSC                   0x00000200
  #define STM32_RCC_CICR_LSECSSC_SET(x, v)         do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
  #define STM32_RCC_CICR_LSECSSC_GET(x)            (((x) >> 9) & 0x1)

/** AHB1 peripheral reset register @multiple */
#define STM32_RCC_AHB1RSTR_ADDR                      0x00000028
/** DMA1 reset @multiple */
  #define STM32_RCC_AHB1RSTR_DMA1RST_MASK          0x00000001
  #define STM32_RCC_AHB1RSTR_DMA1RST               0x00000001
  #define STM32_RCC_AHB1RSTR_DMA1RST_SET(x, v)     do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_AHB1RSTR_DMA1RST_GET(x)        (((x) >> 0) & 0x1)
/** DMA2 reset @multiple */
  #define STM32_RCC_AHB1RSTR_DMA2RST_MASK          0x00000001
  #define STM32_RCC_AHB1RSTR_DMA2RST               0x00000002
  #define STM32_RCC_AHB1RSTR_DMA2RST_SET(x, v)     do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_AHB1RSTR_DMA2RST_GET(x)        (((x) >> 1) & 0x1)
/** Flash memory interface reset @multiple */
  #define STM32_RCC_AHB1RSTR_FLASHRST_MASK         0x00000001
  #define STM32_RCC_AHB1RSTR_FLASHRST              0x00000100
  #define STM32_RCC_AHB1RSTR_FLASHRST_SET(x, v)    do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define STM32_RCC_AHB1RSTR_FLASHRST_GET(x)       (((x) >> 8) & 0x1)
/** Reserved @multiple */
  #define STM32_RCC_AHB1RSTR_CRCRST_MASK           0x00000001
  #define STM32_RCC_AHB1RSTR_CRCRST                0x00000800
  #define STM32_RCC_AHB1RSTR_CRCRST_SET(x, v)      do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
  #define STM32_RCC_AHB1RSTR_CRCRST_GET(x)         (((x) >> 11) & 0x1)
/** Touch Sensing Controller reset @multiple */
  #define STM32_RCC_AHB1RSTR_TSCRST_MASK           0x00000001
  #define STM32_RCC_AHB1RSTR_TSCRST                0x00010000
  #define STM32_RCC_AHB1RSTR_TSCRST_SET(x, v)      do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define STM32_RCC_AHB1RSTR_TSCRST_GET(x)         (((x) >> 16) & 0x1)

/** AHB2 peripheral reset register @multiple */
#define STM32_RCC_AHB2RSTR_ADDR                      0x0000002c
/** IO port A reset @multiple */
  #define STM32_RCC_AHB2RSTR_GPIOARST_MASK         0x00000001
  #define STM32_RCC_AHB2RSTR_GPIOARST              0x00000001
  #define STM32_RCC_AHB2RSTR_GPIOARST_SET(x, v)    do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_AHB2RSTR_GPIOARST_GET(x)       (((x) >> 0) & 0x1)
/** IO port B reset @multiple */
  #define STM32_RCC_AHB2RSTR_GPIOBRST_MASK         0x00000001
  #define STM32_RCC_AHB2RSTR_GPIOBRST              0x00000002
  #define STM32_RCC_AHB2RSTR_GPIOBRST_SET(x, v)    do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_AHB2RSTR_GPIOBRST_GET(x)       (((x) >> 1) & 0x1)
/** IO port C reset @multiple */
  #define STM32_RCC_AHB2RSTR_GPIOCRST_MASK         0x00000001
  #define STM32_RCC_AHB2RSTR_GPIOCRST              0x00000004
  #define STM32_RCC_AHB2RSTR_GPIOCRST_SET(x, v)    do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define STM32_RCC_AHB2RSTR_GPIOCRST_GET(x)       (((x) >> 2) & 0x1)
/** IO port D reset @multiple */
  #define STM32_RCC_AHB2RSTR_GPIODRST_MASK         0x00000001
  #define STM32_RCC_AHB2RSTR_GPIODRST              0x00000008
  #define STM32_RCC_AHB2RSTR_GPIODRST_SET(x, v)    do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define STM32_RCC_AHB2RSTR_GPIODRST_GET(x)       (((x) >> 3) & 0x1)
/** IO port E reset @multiple */
  #define STM32_RCC_AHB2RSTR_GPIOERST_MASK         0x00000001
  #define STM32_RCC_AHB2RSTR_GPIOERST              0x00000010
  #define STM32_RCC_AHB2RSTR_GPIOERST_SET(x, v)    do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define STM32_RCC_AHB2RSTR_GPIOERST_GET(x)       (((x) >> 4) & 0x1)
/** IO port F reset @multiple */
  #define STM32_RCC_AHB2RSTR_GPIOFRST_MASK         0x00000001
  #define STM32_RCC_AHB2RSTR_GPIOFRST              0x00000020
  #define STM32_RCC_AHB2RSTR_GPIOFRST_SET(x, v)    do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define STM32_RCC_AHB2RSTR_GPIOFRST_GET(x)       (((x) >> 5) & 0x1)
/** IO port G reset @multiple */
  #define STM32_RCC_AHB2RSTR_GPIOGRST_MASK         0x00000001
  #define STM32_RCC_AHB2RSTR_GPIOGRST              0x00000040
  #define STM32_RCC_AHB2RSTR_GPIOGRST_SET(x, v)    do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
  #define STM32_RCC_AHB2RSTR_GPIOGRST_GET(x)       (((x) >> 6) & 0x1)
/** IO port H reset @multiple */
  #define STM32_RCC_AHB2RSTR_GPIOHRST_MASK         0x00000001
  #define STM32_RCC_AHB2RSTR_GPIOHRST              0x00000080
  #define STM32_RCC_AHB2RSTR_GPIOHRST_SET(x, v)    do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
  #define STM32_RCC_AHB2RSTR_GPIOHRST_GET(x)       (((x) >> 7) & 0x1)
/** USB OTG FS reset @multiple */
  #define STM32_RCC_AHB2RSTR_OTGFSRST_MASK         0x00000001
  #define STM32_RCC_AHB2RSTR_OTGFSRST              0x00001000
  #define STM32_RCC_AHB2RSTR_OTGFSRST_SET(x, v)    do { (x) = (((x) & ~0x1000) | ((v) << 12)); } while(0)
  #define STM32_RCC_AHB2RSTR_OTGFSRST_GET(x)       (((x) >> 12) & 0x1)
/** ADC reset @multiple */
  #define STM32_RCC_AHB2RSTR_ADCRST_MASK           0x00000001
  #define STM32_RCC_AHB2RSTR_ADCRST                0x00002000
  #define STM32_RCC_AHB2RSTR_ADCRST_SET(x, v)      do { (x) = (((x) & ~0x2000) | ((v) << 13)); } while(0)
  #define STM32_RCC_AHB2RSTR_ADCRST_GET(x)         (((x) >> 13) & 0x1)
/** AES hardware accelerator reset @multiple */
  #define STM32_RCC_AHB2RSTR_AESRST_MASK           0x00000001
  #define STM32_RCC_AHB2RSTR_AESRST                0x00010000
  #define STM32_RCC_AHB2RSTR_AESRST_SET(x, v)      do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define STM32_RCC_AHB2RSTR_AESRST_GET(x)         (((x) >> 16) & 0x1)
/** Random number generator reset @multiple */
  #define STM32_RCC_AHB2RSTR_RNGRST_MASK           0x00000001
  #define STM32_RCC_AHB2RSTR_RNGRST                0x00040000
  #define STM32_RCC_AHB2RSTR_RNGRST_SET(x, v)      do { (x) = (((x) & ~0x40000) | ((v) << 18)); } while(0)
  #define STM32_RCC_AHB2RSTR_RNGRST_GET(x)         (((x) >> 18) & 0x1)

/** AHB3 peripheral reset register @multiple */
#define STM32_RCC_AHB3RSTR_ADDR                      0x00000030
/** Flexible memory controller reset @multiple */
  #define STM32_RCC_AHB3RSTR_FMCRST_MASK           0x00000001
  #define STM32_RCC_AHB3RSTR_FMCRST                0x00000001
  #define STM32_RCC_AHB3RSTR_FMCRST_SET(x, v)      do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_AHB3RSTR_FMCRST_GET(x)         (((x) >> 0) & 0x1)
/** Quad SPI memory interface reset @multiple */
  #define STM32_RCC_AHB3RSTR_QSPIRST_MASK          0x00000001
  #define STM32_RCC_AHB3RSTR_QSPIRST               0x00000100
  #define STM32_RCC_AHB3RSTR_QSPIRST_SET(x, v)     do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define STM32_RCC_AHB3RSTR_QSPIRST_GET(x)        (((x) >> 8) & 0x1)

/** APB1 peripheral reset register 1 @multiple */
#define STM32_RCC_APB1RSTR1_ADDR                     0x00000038
/** TIM2 timer reset @multiple */
  #define STM32_RCC_APB1RSTR1_TIM2RST_MASK         0x00000001
  #define STM32_RCC_APB1RSTR1_TIM2RST              0x00000001
  #define STM32_RCC_APB1RSTR1_TIM2RST_SET(x, v)    do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_APB1RSTR1_TIM2RST_GET(x)       (((x) >> 0) & 0x1)
/** TIM3 timer reset @multiple */
  #define STM32_RCC_APB1RSTR1_TIM3RST_MASK         0x00000001
  #define STM32_RCC_APB1RSTR1_TIM3RST              0x00000002
  #define STM32_RCC_APB1RSTR1_TIM3RST_SET(x, v)    do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_APB1RSTR1_TIM3RST_GET(x)       (((x) >> 1) & 0x1)
/** TIM3 timer reset @multiple */
  #define STM32_RCC_APB1RSTR1_TIM4RST_MASK         0x00000001
  #define STM32_RCC_APB1RSTR1_TIM4RST              0x00000004
  #define STM32_RCC_APB1RSTR1_TIM4RST_SET(x, v)    do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define STM32_RCC_APB1RSTR1_TIM4RST_GET(x)       (((x) >> 2) & 0x1)
/** TIM5 timer reset @multiple */
  #define STM32_RCC_APB1RSTR1_TIM5RST_MASK         0x00000001
  #define STM32_RCC_APB1RSTR1_TIM5RST              0x00000008
  #define STM32_RCC_APB1RSTR1_TIM5RST_SET(x, v)    do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define STM32_RCC_APB1RSTR1_TIM5RST_GET(x)       (((x) >> 3) & 0x1)
/** TIM6 timer reset @multiple */
  #define STM32_RCC_APB1RSTR1_TIM6RST_MASK         0x00000001
  #define STM32_RCC_APB1RSTR1_TIM6RST              0x00000010
  #define STM32_RCC_APB1RSTR1_TIM6RST_SET(x, v)    do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define STM32_RCC_APB1RSTR1_TIM6RST_GET(x)       (((x) >> 4) & 0x1)
/** TIM7 timer reset @multiple */
  #define STM32_RCC_APB1RSTR1_TIM7RST_MASK         0x00000001
  #define STM32_RCC_APB1RSTR1_TIM7RST              0x00000020
  #define STM32_RCC_APB1RSTR1_TIM7RST_SET(x, v)    do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define STM32_RCC_APB1RSTR1_TIM7RST_GET(x)       (((x) >> 5) & 0x1)
/** LCD interface reset @multiple */
  #define STM32_RCC_APB1RSTR1_LCDRST_MASK          0x00000001
  #define STM32_RCC_APB1RSTR1_LCDRST               0x00000200
  #define STM32_RCC_APB1RSTR1_LCDRST_SET(x, v)     do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
  #define STM32_RCC_APB1RSTR1_LCDRST_GET(x)        (((x) >> 9) & 0x1)
/** SPI2 reset @multiple */
  #define STM32_RCC_APB1RSTR1_SPI2RST_MASK         0x00000001
  #define STM32_RCC_APB1RSTR1_SPI2RST              0x00004000
  #define STM32_RCC_APB1RSTR1_SPI2RST_SET(x, v)    do { (x) = (((x) & ~0x4000) | ((v) << 14)); } while(0)
  #define STM32_RCC_APB1RSTR1_SPI2RST_GET(x)       (((x) >> 14) & 0x1)
/** SPI3 reset @multiple */
  #define STM32_RCC_APB1RSTR1_SPI3RST_MASK         0x00000001
  #define STM32_RCC_APB1RSTR1_SPI3RST              0x00008000
  #define STM32_RCC_APB1RSTR1_SPI3RST_SET(x, v)    do { (x) = (((x) & ~0x8000) | ((v) << 15)); } while(0)
  #define STM32_RCC_APB1RSTR1_SPI3RST_GET(x)       (((x) >> 15) & 0x1)
/** USART2 reset @multiple */
  #define STM32_RCC_APB1RSTR1_USART2RST_MASK       0x00000001
  #define STM32_RCC_APB1RSTR1_USART2RST            0x00020000
  #define STM32_RCC_APB1RSTR1_USART2RST_SET(x, v)  do { (x) = (((x) & ~0x20000) | ((v) << 17)); } while(0)
  #define STM32_RCC_APB1RSTR1_USART2RST_GET(x)     (((x) >> 17) & 0x1)
/** USART3 reset @multiple */
  #define STM32_RCC_APB1RSTR1_USART3RST_MASK       0x00000001
  #define STM32_RCC_APB1RSTR1_USART3RST            0x00040000
  #define STM32_RCC_APB1RSTR1_USART3RST_SET(x, v)  do { (x) = (((x) & ~0x40000) | ((v) << 18)); } while(0)
  #define STM32_RCC_APB1RSTR1_USART3RST_GET(x)     (((x) >> 18) & 0x1)
/** UART4 reset @multiple */
  #define STM32_RCC_APB1RSTR1_UART4RST_MASK        0x00000001
  #define STM32_RCC_APB1RSTR1_UART4RST             0x00080000
  #define STM32_RCC_APB1RSTR1_UART4RST_SET(x, v)   do { (x) = (((x) & ~0x80000) | ((v) << 19)); } while(0)
  #define STM32_RCC_APB1RSTR1_UART4RST_GET(x)      (((x) >> 19) & 0x1)
/** UART5 reset @multiple */
  #define STM32_RCC_APB1RSTR1_UART5RST_MASK        0x00000001
  #define STM32_RCC_APB1RSTR1_UART5RST             0x00100000
  #define STM32_RCC_APB1RSTR1_UART5RST_SET(x, v)   do { (x) = (((x) & ~0x100000) | ((v) << 20)); } while(0)
  #define STM32_RCC_APB1RSTR1_UART5RST_GET(x)      (((x) >> 20) & 0x1)
/** I2C1 reset @multiple */
  #define STM32_RCC_APB1RSTR1_I2C1RST_MASK         0x00000001
  #define STM32_RCC_APB1RSTR1_I2C1RST              0x00200000
  #define STM32_RCC_APB1RSTR1_I2C1RST_SET(x, v)    do { (x) = (((x) & ~0x200000) | ((v) << 21)); } while(0)
  #define STM32_RCC_APB1RSTR1_I2C1RST_GET(x)       (((x) >> 21) & 0x1)
/** I2C2 reset @multiple */
  #define STM32_RCC_APB1RSTR1_I2C2RST_MASK         0x00000001
  #define STM32_RCC_APB1RSTR1_I2C2RST              0x00400000
  #define STM32_RCC_APB1RSTR1_I2C2RST_SET(x, v)    do { (x) = (((x) & ~0x400000) | ((v) << 22)); } while(0)
  #define STM32_RCC_APB1RSTR1_I2C2RST_GET(x)       (((x) >> 22) & 0x1)
/** I2C3 reset @multiple */
  #define STM32_RCC_APB1RSTR1_I2C3RST_MASK         0x00000001
  #define STM32_RCC_APB1RSTR1_I2C3RST              0x00800000
  #define STM32_RCC_APB1RSTR1_I2C3RST_SET(x, v)    do { (x) = (((x) & ~0x800000) | ((v) << 23)); } while(0)
  #define STM32_RCC_APB1RSTR1_I2C3RST_GET(x)       (((x) >> 23) & 0x1)
/** CAN1 reset @multiple */
  #define STM32_RCC_APB1RSTR1_CAN1RST_MASK         0x00000001
  #define STM32_RCC_APB1RSTR1_CAN1RST              0x02000000
  #define STM32_RCC_APB1RSTR1_CAN1RST_SET(x, v)    do { (x) = (((x) & ~0x2000000) | ((v) << 25)); } while(0)
  #define STM32_RCC_APB1RSTR1_CAN1RST_GET(x)       (((x) >> 25) & 0x1)
/** Power interface reset @multiple */
  #define STM32_RCC_APB1RSTR1_PWRRST_MASK          0x00000001
  #define STM32_RCC_APB1RSTR1_PWRRST               0x10000000
  #define STM32_RCC_APB1RSTR1_PWRRST_SET(x, v)     do { (x) = (((x) & ~0x10000000) | ((v) << 28)); } while(0)
  #define STM32_RCC_APB1RSTR1_PWRRST_GET(x)        (((x) >> 28) & 0x1)
/** DAC1 interface reset @multiple */
  #define STM32_RCC_APB1RSTR1_DAC1RST_MASK         0x00000001
  #define STM32_RCC_APB1RSTR1_DAC1RST              0x20000000
  #define STM32_RCC_APB1RSTR1_DAC1RST_SET(x, v)    do { (x) = (((x) & ~0x20000000) | ((v) << 29)); } while(0)
  #define STM32_RCC_APB1RSTR1_DAC1RST_GET(x)       (((x) >> 29) & 0x1)
/** OPAMP interface reset @multiple */
  #define STM32_RCC_APB1RSTR1_OPAMPRST_MASK        0x00000001
  #define STM32_RCC_APB1RSTR1_OPAMPRST             0x40000000
  #define STM32_RCC_APB1RSTR1_OPAMPRST_SET(x, v)   do { (x) = (((x) & ~0x40000000) | ((v) << 30)); } while(0)
  #define STM32_RCC_APB1RSTR1_OPAMPRST_GET(x)      (((x) >> 30) & 0x1)
/** Low Power Timer 1 reset @multiple */
  #define STM32_RCC_APB1RSTR1_LPTIM1RST_MASK       0x00000001
  #define STM32_RCC_APB1RSTR1_LPTIM1RST            0x80000000
  #define STM32_RCC_APB1RSTR1_LPTIM1RST_SET(x, v)  do { (x) = (((x) & ~0x80000000) | ((v) << 31)); } while(0)
  #define STM32_RCC_APB1RSTR1_LPTIM1RST_GET(x)     (((x) >> 31) & 0x1)

/** APB1 peripheral reset register 2 @multiple */
#define STM32_RCC_APB1RSTR2_ADDR                     0x0000003c
/** Low-power UART 1 reset @multiple */
  #define STM32_RCC_APB1RSTR2_LPUART1RST_MASK      0x00000001
  #define STM32_RCC_APB1RSTR2_LPUART1RST           0x00000001
  #define STM32_RCC_APB1RSTR2_LPUART1RST_SET(x, v) do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_APB1RSTR2_LPUART1RST_GET(x)    (((x) >> 0) & 0x1)
/** Single wire protocol reset @multiple */
  #define STM32_RCC_APB1RSTR2_SWPMI1RST_MASK       0x00000001
  #define STM32_RCC_APB1RSTR2_SWPMI1RST            0x00000004
  #define STM32_RCC_APB1RSTR2_SWPMI1RST_SET(x, v)  do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define STM32_RCC_APB1RSTR2_SWPMI1RST_GET(x)     (((x) >> 2) & 0x1)
/** Low-power timer 2 reset @multiple */
  #define STM32_RCC_APB1RSTR2_LPTIM2RST_MASK       0x00000001
  #define STM32_RCC_APB1RSTR2_LPTIM2RST            0x00000020
  #define STM32_RCC_APB1RSTR2_LPTIM2RST_SET(x, v)  do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define STM32_RCC_APB1RSTR2_LPTIM2RST_GET(x)     (((x) >> 5) & 0x1)

/** APB2 peripheral reset register @multiple */
#define STM32_RCC_APB2RSTR_ADDR                      0x00000040
/** System configuration (SYSCFG) reset @multiple */
  #define STM32_RCC_APB2RSTR_SYSCFGRST_MASK        0x00000001
  #define STM32_RCC_APB2RSTR_SYSCFGRST             0x00000001
  #define STM32_RCC_APB2RSTR_SYSCFGRST_SET(x, v)   do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_APB2RSTR_SYSCFGRST_GET(x)      (((x) >> 0) & 0x1)
/** SDMMC reset @multiple */
  #define STM32_RCC_APB2RSTR_SDMMCRST_MASK         0x00000001
  #define STM32_RCC_APB2RSTR_SDMMCRST              0x00000400
  #define STM32_RCC_APB2RSTR_SDMMCRST_SET(x, v)    do { (x) = (((x) & ~0x400) | ((v) << 10)); } while(0)
  #define STM32_RCC_APB2RSTR_SDMMCRST_GET(x)       (((x) >> 10) & 0x1)
/** TIM1 timer reset @multiple */
  #define STM32_RCC_APB2RSTR_TIM1RST_MASK          0x00000001
  #define STM32_RCC_APB2RSTR_TIM1RST               0x00000800
  #define STM32_RCC_APB2RSTR_TIM1RST_SET(x, v)     do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
  #define STM32_RCC_APB2RSTR_TIM1RST_GET(x)        (((x) >> 11) & 0x1)
/** SPI1 reset @multiple */
  #define STM32_RCC_APB2RSTR_SPI1RST_MASK          0x00000001
  #define STM32_RCC_APB2RSTR_SPI1RST               0x00001000
  #define STM32_RCC_APB2RSTR_SPI1RST_SET(x, v)     do { (x) = (((x) & ~0x1000) | ((v) << 12)); } while(0)
  #define STM32_RCC_APB2RSTR_SPI1RST_GET(x)        (((x) >> 12) & 0x1)
/** TIM8 timer reset @multiple */
  #define STM32_RCC_APB2RSTR_TIM8RST_MASK          0x00000001
  #define STM32_RCC_APB2RSTR_TIM8RST               0x00002000
  #define STM32_RCC_APB2RSTR_TIM8RST_SET(x, v)     do { (x) = (((x) & ~0x2000) | ((v) << 13)); } while(0)
  #define STM32_RCC_APB2RSTR_TIM8RST_GET(x)        (((x) >> 13) & 0x1)
/** USART1 reset @multiple */
  #define STM32_RCC_APB2RSTR_USART1RST_MASK        0x00000001
  #define STM32_RCC_APB2RSTR_USART1RST             0x00004000
  #define STM32_RCC_APB2RSTR_USART1RST_SET(x, v)   do { (x) = (((x) & ~0x4000) | ((v) << 14)); } while(0)
  #define STM32_RCC_APB2RSTR_USART1RST_GET(x)      (((x) >> 14) & 0x1)
/** TIM15 timer reset @multiple */
  #define STM32_RCC_APB2RSTR_TIM15RST_MASK         0x00000001
  #define STM32_RCC_APB2RSTR_TIM15RST              0x00010000
  #define STM32_RCC_APB2RSTR_TIM15RST_SET(x, v)    do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define STM32_RCC_APB2RSTR_TIM15RST_GET(x)       (((x) >> 16) & 0x1)
/** TIM16 timer reset @multiple */
  #define STM32_RCC_APB2RSTR_TIM16RST_MASK         0x00000001
  #define STM32_RCC_APB2RSTR_TIM16RST              0x00020000
  #define STM32_RCC_APB2RSTR_TIM16RST_SET(x, v)    do { (x) = (((x) & ~0x20000) | ((v) << 17)); } while(0)
  #define STM32_RCC_APB2RSTR_TIM16RST_GET(x)       (((x) >> 17) & 0x1)
/** TIM17 timer reset @multiple */
  #define STM32_RCC_APB2RSTR_TIM17RST_MASK         0x00000001
  #define STM32_RCC_APB2RSTR_TIM17RST              0x00040000
  #define STM32_RCC_APB2RSTR_TIM17RST_SET(x, v)    do { (x) = (((x) & ~0x40000) | ((v) << 18)); } while(0)
  #define STM32_RCC_APB2RSTR_TIM17RST_GET(x)       (((x) >> 18) & 0x1)
/** Serial audio interface 1 (SAI1) reset @multiple */
  #define STM32_RCC_APB2RSTR_SAI1RST_MASK          0x00000001
  #define STM32_RCC_APB2RSTR_SAI1RST               0x00200000
  #define STM32_RCC_APB2RSTR_SAI1RST_SET(x, v)     do { (x) = (((x) & ~0x200000) | ((v) << 21)); } while(0)
  #define STM32_RCC_APB2RSTR_SAI1RST_GET(x)        (((x) >> 21) & 0x1)
/** Serial audio interface 2 (SAI2) reset @multiple */
  #define STM32_RCC_APB2RSTR_SAI2RST_MASK          0x00000001
  #define STM32_RCC_APB2RSTR_SAI2RST               0x00400000
  #define STM32_RCC_APB2RSTR_SAI2RST_SET(x, v)     do { (x) = (((x) & ~0x400000) | ((v) << 22)); } while(0)
  #define STM32_RCC_APB2RSTR_SAI2RST_GET(x)        (((x) >> 22) & 0x1)
/** Digital filters for sigma-delata modulators (DFSDM) reset @multiple */
  #define STM32_RCC_APB2RSTR_DFSDMRST_MASK         0x00000001
  #define STM32_RCC_APB2RSTR_DFSDMRST              0x01000000
  #define STM32_RCC_APB2RSTR_DFSDMRST_SET(x, v)    do { (x) = (((x) & ~0x1000000) | ((v) << 24)); } while(0)
  #define STM32_RCC_APB2RSTR_DFSDMRST_GET(x)       (((x) >> 24) & 0x1)

/** AHB1 peripheral clock enable register @multiple */
#define STM32_RCC_AHB1ENR_ADDR                       0x00000048
/** DMA1 clock enable @multiple */
  #define STM32_RCC_AHB1ENR_DMA1EN_MASK            0x00000001
  #define STM32_RCC_AHB1ENR_DMA1EN                 0x00000001
  #define STM32_RCC_AHB1ENR_DMA1EN_SET(x, v)       do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_AHB1ENR_DMA1EN_GET(x)          (((x) >> 0) & 0x1)
/** DMA2 clock enable @multiple */
  #define STM32_RCC_AHB1ENR_DMA2EN_MASK            0x00000001
  #define STM32_RCC_AHB1ENR_DMA2EN                 0x00000002
  #define STM32_RCC_AHB1ENR_DMA2EN_SET(x, v)       do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_AHB1ENR_DMA2EN_GET(x)          (((x) >> 1) & 0x1)
/** Flash memory interface clock enable @multiple */
  #define STM32_RCC_AHB1ENR_FLASHEN_MASK           0x00000001
  #define STM32_RCC_AHB1ENR_FLASHEN                0x00000100
  #define STM32_RCC_AHB1ENR_FLASHEN_SET(x, v)      do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define STM32_RCC_AHB1ENR_FLASHEN_GET(x)         (((x) >> 8) & 0x1)
/** Reserved @multiple */
  #define STM32_RCC_AHB1ENR_CRCEN_MASK             0x00000001
  #define STM32_RCC_AHB1ENR_CRCEN                  0x00000800
  #define STM32_RCC_AHB1ENR_CRCEN_SET(x, v)        do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
  #define STM32_RCC_AHB1ENR_CRCEN_GET(x)           (((x) >> 11) & 0x1)
/** Touch Sensing Controller clock enable @multiple */
  #define STM32_RCC_AHB1ENR_TSCEN_MASK             0x00000001
  #define STM32_RCC_AHB1ENR_TSCEN                  0x00010000
  #define STM32_RCC_AHB1ENR_TSCEN_SET(x, v)        do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define STM32_RCC_AHB1ENR_TSCEN_GET(x)           (((x) >> 16) & 0x1)

/** AHB2 peripheral clock enable register @multiple */
#define STM32_RCC_AHB2ENR_ADDR                       0x0000004c
/** IO port A clock enable @multiple */
  #define STM32_RCC_AHB2ENR_GPIOAEN_MASK           0x00000001
  #define STM32_RCC_AHB2ENR_GPIOAEN                0x00000001
  #define STM32_RCC_AHB2ENR_GPIOAEN_SET(x, v)      do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_AHB2ENR_GPIOAEN_GET(x)         (((x) >> 0) & 0x1)
/** IO port B clock enable @multiple */
  #define STM32_RCC_AHB2ENR_GPIOBEN_MASK           0x00000001
  #define STM32_RCC_AHB2ENR_GPIOBEN                0x00000002
  #define STM32_RCC_AHB2ENR_GPIOBEN_SET(x, v)      do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_AHB2ENR_GPIOBEN_GET(x)         (((x) >> 1) & 0x1)
/** IO port C clock enable @multiple */
  #define STM32_RCC_AHB2ENR_GPIOCEN_MASK           0x00000001
  #define STM32_RCC_AHB2ENR_GPIOCEN                0x00000004
  #define STM32_RCC_AHB2ENR_GPIOCEN_SET(x, v)      do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define STM32_RCC_AHB2ENR_GPIOCEN_GET(x)         (((x) >> 2) & 0x1)
/** IO port D clock enable @multiple */
  #define STM32_RCC_AHB2ENR_GPIODEN_MASK           0x00000001
  #define STM32_RCC_AHB2ENR_GPIODEN                0x00000008
  #define STM32_RCC_AHB2ENR_GPIODEN_SET(x, v)      do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define STM32_RCC_AHB2ENR_GPIODEN_GET(x)         (((x) >> 3) & 0x1)
/** IO port E clock enable @multiple */
  #define STM32_RCC_AHB2ENR_GPIOEEN_MASK           0x00000001
  #define STM32_RCC_AHB2ENR_GPIOEEN                0x00000010
  #define STM32_RCC_AHB2ENR_GPIOEEN_SET(x, v)      do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define STM32_RCC_AHB2ENR_GPIOEEN_GET(x)         (((x) >> 4) & 0x1)
/** IO port F clock enable @multiple */
  #define STM32_RCC_AHB2ENR_GPIOFEN_MASK           0x00000001
  #define STM32_RCC_AHB2ENR_GPIOFEN                0x00000020
  #define STM32_RCC_AHB2ENR_GPIOFEN_SET(x, v)      do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define STM32_RCC_AHB2ENR_GPIOFEN_GET(x)         (((x) >> 5) & 0x1)
/** IO port G clock enable @multiple */
  #define STM32_RCC_AHB2ENR_GPIOGEN_MASK           0x00000001
  #define STM32_RCC_AHB2ENR_GPIOGEN                0x00000040
  #define STM32_RCC_AHB2ENR_GPIOGEN_SET(x, v)      do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
  #define STM32_RCC_AHB2ENR_GPIOGEN_GET(x)         (((x) >> 6) & 0x1)
/** IO port H clock enable @multiple */
  #define STM32_RCC_AHB2ENR_GPIOHEN_MASK           0x00000001
  #define STM32_RCC_AHB2ENR_GPIOHEN                0x00000080
  #define STM32_RCC_AHB2ENR_GPIOHEN_SET(x, v)      do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
  #define STM32_RCC_AHB2ENR_GPIOHEN_GET(x)         (((x) >> 7) & 0x1)
/** OTG full speed clock enable @multiple */
  #define STM32_RCC_AHB2ENR_OTGFSEN_MASK           0x00000001
  #define STM32_RCC_AHB2ENR_OTGFSEN                0x00001000
  #define STM32_RCC_AHB2ENR_OTGFSEN_SET(x, v)      do { (x) = (((x) & ~0x1000) | ((v) << 12)); } while(0)
  #define STM32_RCC_AHB2ENR_OTGFSEN_GET(x)         (((x) >> 12) & 0x1)
/** ADC clock enable @multiple */
  #define STM32_RCC_AHB2ENR_ADCEN_MASK             0x00000001
  #define STM32_RCC_AHB2ENR_ADCEN                  0x00002000
  #define STM32_RCC_AHB2ENR_ADCEN_SET(x, v)        do { (x) = (((x) & ~0x2000) | ((v) << 13)); } while(0)
  #define STM32_RCC_AHB2ENR_ADCEN_GET(x)           (((x) >> 13) & 0x1)
/** AES accelerator clock enable @multiple */
  #define STM32_RCC_AHB2ENR_AESEN_MASK             0x00000001
  #define STM32_RCC_AHB2ENR_AESEN                  0x00010000
  #define STM32_RCC_AHB2ENR_AESEN_SET(x, v)        do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define STM32_RCC_AHB2ENR_AESEN_GET(x)           (((x) >> 16) & 0x1)
/** Random Number Generator clock enable @multiple */
  #define STM32_RCC_AHB2ENR_RNGEN_MASK             0x00000001
  #define STM32_RCC_AHB2ENR_RNGEN                  0x00040000
  #define STM32_RCC_AHB2ENR_RNGEN_SET(x, v)        do { (x) = (((x) & ~0x40000) | ((v) << 18)); } while(0)
  #define STM32_RCC_AHB2ENR_RNGEN_GET(x)           (((x) >> 18) & 0x1)

/** AHB3 peripheral clock enable register @multiple */
#define STM32_RCC_AHB3ENR_ADDR                       0x00000050
/** Flexible memory controller clock enable @multiple */
  #define STM32_RCC_AHB3ENR_FMCEN_MASK             0x00000001
  #define STM32_RCC_AHB3ENR_FMCEN                  0x00000001
  #define STM32_RCC_AHB3ENR_FMCEN_SET(x, v)        do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_AHB3ENR_FMCEN_GET(x)           (((x) >> 0) & 0x1)
/** QSPIEN @multiple */
  #define STM32_RCC_AHB3ENR_QSPIEN_MASK            0x00000001
  #define STM32_RCC_AHB3ENR_QSPIEN                 0x00000100
  #define STM32_RCC_AHB3ENR_QSPIEN_SET(x, v)       do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define STM32_RCC_AHB3ENR_QSPIEN_GET(x)          (((x) >> 8) & 0x1)

/** APB1ENR1 @multiple */
#define STM32_RCC_APB1ENR1_ADDR                      0x00000058
/** TIM2 timer clock enable @multiple */
  #define STM32_RCC_APB1ENR1_TIM2EN_MASK           0x00000001
  #define STM32_RCC_APB1ENR1_TIM2EN                0x00000001
  #define STM32_RCC_APB1ENR1_TIM2EN_SET(x, v)      do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_APB1ENR1_TIM2EN_GET(x)         (((x) >> 0) & 0x1)
/** TIM3 timer clock enable @multiple */
  #define STM32_RCC_APB1ENR1_TIM3EN_MASK           0x00000001
  #define STM32_RCC_APB1ENR1_TIM3EN                0x00000002
  #define STM32_RCC_APB1ENR1_TIM3EN_SET(x, v)      do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_APB1ENR1_TIM3EN_GET(x)         (((x) >> 1) & 0x1)
/** TIM4 timer clock enable @multiple */
  #define STM32_RCC_APB1ENR1_TIM4EN_MASK           0x00000001
  #define STM32_RCC_APB1ENR1_TIM4EN                0x00000004
  #define STM32_RCC_APB1ENR1_TIM4EN_SET(x, v)      do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define STM32_RCC_APB1ENR1_TIM4EN_GET(x)         (((x) >> 2) & 0x1)
/** Reserved @multiple */
  #define STM32_RCC_APB1ENR1_TIM5EN_MASK           0x00000001
  #define STM32_RCC_APB1ENR1_TIM5EN                0x00000008
  #define STM32_RCC_APB1ENR1_TIM5EN_SET(x, v)      do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define STM32_RCC_APB1ENR1_TIM5EN_GET(x)         (((x) >> 3) & 0x1)
/** TIM6 timer clock enable @multiple */
  #define STM32_RCC_APB1ENR1_TIM6EN_MASK           0x00000001
  #define STM32_RCC_APB1ENR1_TIM6EN                0x00000010
  #define STM32_RCC_APB1ENR1_TIM6EN_SET(x, v)      do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define STM32_RCC_APB1ENR1_TIM6EN_GET(x)         (((x) >> 4) & 0x1)
/** TIM7 timer clock enable @multiple */
  #define STM32_RCC_APB1ENR1_TIM7EN_MASK           0x00000001
  #define STM32_RCC_APB1ENR1_TIM7EN                0x00000020
  #define STM32_RCC_APB1ENR1_TIM7EN_SET(x, v)      do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define STM32_RCC_APB1ENR1_TIM7EN_GET(x)         (((x) >> 5) & 0x1)
/** LCD clock enable @multiple */
  #define STM32_RCC_APB1ENR1_LCDEN_MASK            0x00000001
  #define STM32_RCC_APB1ENR1_LCDEN                 0x00000200
  #define STM32_RCC_APB1ENR1_LCDEN_SET(x, v)       do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
  #define STM32_RCC_APB1ENR1_LCDEN_GET(x)          (((x) >> 9) & 0x1)
/** Window watchdog clock enable @multiple */
  #define STM32_RCC_APB1ENR1_WWDGEN_MASK           0x00000001
  #define STM32_RCC_APB1ENR1_WWDGEN                0x00000800
  #define STM32_RCC_APB1ENR1_WWDGEN_SET(x, v)      do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
  #define STM32_RCC_APB1ENR1_WWDGEN_GET(x)         (((x) >> 11) & 0x1)
/** SPI2 clock enable @multiple */
  #define STM32_RCC_APB1ENR1_SPI2EN_MASK           0x00000001
  #define STM32_RCC_APB1ENR1_SPI2EN                0x00004000
  #define STM32_RCC_APB1ENR1_SPI2EN_SET(x, v)      do { (x) = (((x) & ~0x4000) | ((v) << 14)); } while(0)
  #define STM32_RCC_APB1ENR1_SPI2EN_GET(x)         (((x) >> 14) & 0x1)
/** SPI3 clock enable @multiple */
  #define STM32_RCC_APB1ENR1_SP3EN_MASK            0x00000001
  #define STM32_RCC_APB1ENR1_SP3EN                 0x00008000
  #define STM32_RCC_APB1ENR1_SP3EN_SET(x, v)       do { (x) = (((x) & ~0x8000) | ((v) << 15)); } while(0)
  #define STM32_RCC_APB1ENR1_SP3EN_GET(x)          (((x) >> 15) & 0x1)
/** USART2 clock enable @multiple */
  #define STM32_RCC_APB1ENR1_USART2EN_MASK         0x00000001
  #define STM32_RCC_APB1ENR1_USART2EN              0x00020000
  #define STM32_RCC_APB1ENR1_USART2EN_SET(x, v)    do { (x) = (((x) & ~0x20000) | ((v) << 17)); } while(0)
  #define STM32_RCC_APB1ENR1_USART2EN_GET(x)       (((x) >> 17) & 0x1)
/** USART3 clock enable @multiple */
  #define STM32_RCC_APB1ENR1_USART3EN_MASK         0x00000001
  #define STM32_RCC_APB1ENR1_USART3EN              0x00040000
  #define STM32_RCC_APB1ENR1_USART3EN_SET(x, v)    do { (x) = (((x) & ~0x40000) | ((v) << 18)); } while(0)
  #define STM32_RCC_APB1ENR1_USART3EN_GET(x)       (((x) >> 18) & 0x1)
/** UART4 clock enable @multiple */
  #define STM32_RCC_APB1ENR1_UART4EN_MASK          0x00000001
  #define STM32_RCC_APB1ENR1_UART4EN               0x00080000
  #define STM32_RCC_APB1ENR1_UART4EN_SET(x, v)     do { (x) = (((x) & ~0x80000) | ((v) << 19)); } while(0)
  #define STM32_RCC_APB1ENR1_UART4EN_GET(x)        (((x) >> 19) & 0x1)
/** UART5 clock enable @multiple */
  #define STM32_RCC_APB1ENR1_UART5EN_MASK          0x00000001
  #define STM32_RCC_APB1ENR1_UART5EN               0x00100000
  #define STM32_RCC_APB1ENR1_UART5EN_SET(x, v)     do { (x) = (((x) & ~0x100000) | ((v) << 20)); } while(0)
  #define STM32_RCC_APB1ENR1_UART5EN_GET(x)        (((x) >> 20) & 0x1)
/** I2C1 clock enable @multiple */
  #define STM32_RCC_APB1ENR1_I2C1EN_MASK           0x00000001
  #define STM32_RCC_APB1ENR1_I2C1EN                0x00200000
  #define STM32_RCC_APB1ENR1_I2C1EN_SET(x, v)      do { (x) = (((x) & ~0x200000) | ((v) << 21)); } while(0)
  #define STM32_RCC_APB1ENR1_I2C1EN_GET(x)         (((x) >> 21) & 0x1)
/** I2C2 clock enable @multiple */
  #define STM32_RCC_APB1ENR1_I2C2EN_MASK           0x00000001
  #define STM32_RCC_APB1ENR1_I2C2EN                0x00400000
  #define STM32_RCC_APB1ENR1_I2C2EN_SET(x, v)      do { (x) = (((x) & ~0x400000) | ((v) << 22)); } while(0)
  #define STM32_RCC_APB1ENR1_I2C2EN_GET(x)         (((x) >> 22) & 0x1)
/** I2C3 clock enable @multiple */
  #define STM32_RCC_APB1ENR1_I2C3EN_MASK           0x00000001
  #define STM32_RCC_APB1ENR1_I2C3EN                0x00800000
  #define STM32_RCC_APB1ENR1_I2C3EN_SET(x, v)      do { (x) = (((x) & ~0x800000) | ((v) << 23)); } while(0)
  #define STM32_RCC_APB1ENR1_I2C3EN_GET(x)         (((x) >> 23) & 0x1)
/** CAN1 clock enable @multiple */
  #define STM32_RCC_APB1ENR1_CAN1EN_MASK           0x00000001
  #define STM32_RCC_APB1ENR1_CAN1EN                0x02000000
  #define STM32_RCC_APB1ENR1_CAN1EN_SET(x, v)      do { (x) = (((x) & ~0x2000000) | ((v) << 25)); } while(0)
  #define STM32_RCC_APB1ENR1_CAN1EN_GET(x)         (((x) >> 25) & 0x1)
/** Power interface clock enable @multiple */
  #define STM32_RCC_APB1ENR1_PWREN_MASK            0x00000001
  #define STM32_RCC_APB1ENR1_PWREN                 0x10000000
  #define STM32_RCC_APB1ENR1_PWREN_SET(x, v)       do { (x) = (((x) & ~0x10000000) | ((v) << 28)); } while(0)
  #define STM32_RCC_APB1ENR1_PWREN_GET(x)          (((x) >> 28) & 0x1)
/** DAC1 interface clock enable @multiple */
  #define STM32_RCC_APB1ENR1_DAC1EN_MASK           0x00000001
  #define STM32_RCC_APB1ENR1_DAC1EN                0x20000000
  #define STM32_RCC_APB1ENR1_DAC1EN_SET(x, v)      do { (x) = (((x) & ~0x20000000) | ((v) << 29)); } while(0)
  #define STM32_RCC_APB1ENR1_DAC1EN_GET(x)         (((x) >> 29) & 0x1)
/** OPAMP interface clock enable @multiple */
  #define STM32_RCC_APB1ENR1_OPAMPEN_MASK          0x00000001
  #define STM32_RCC_APB1ENR1_OPAMPEN               0x40000000
  #define STM32_RCC_APB1ENR1_OPAMPEN_SET(x, v)     do { (x) = (((x) & ~0x40000000) | ((v) << 30)); } while(0)
  #define STM32_RCC_APB1ENR1_OPAMPEN_GET(x)        (((x) >> 30) & 0x1)
/** Low power timer 1 clock enable @multiple */
  #define STM32_RCC_APB1ENR1_LPTIM1EN_MASK         0x00000001
  #define STM32_RCC_APB1ENR1_LPTIM1EN              0x80000000
  #define STM32_RCC_APB1ENR1_LPTIM1EN_SET(x, v)    do { (x) = (((x) & ~0x80000000) | ((v) << 31)); } while(0)
  #define STM32_RCC_APB1ENR1_LPTIM1EN_GET(x)       (((x) >> 31) & 0x1)

/** APB1 peripheral clock enable register 2 @multiple */
#define STM32_RCC_APB1ENR2_ADDR                      0x0000005c
/** Low power UART 1 clock enable @multiple */
  #define STM32_RCC_APB1ENR2_LPUART1EN_MASK        0x00000001
  #define STM32_RCC_APB1ENR2_LPUART1EN             0x00000001
  #define STM32_RCC_APB1ENR2_LPUART1EN_SET(x, v)   do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_APB1ENR2_LPUART1EN_GET(x)      (((x) >> 0) & 0x1)
/** Single wire protocol clock enable @multiple */
  #define STM32_RCC_APB1ENR2_SWPMI1EN_MASK         0x00000001
  #define STM32_RCC_APB1ENR2_SWPMI1EN              0x00000004
  #define STM32_RCC_APB1ENR2_SWPMI1EN_SET(x, v)    do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define STM32_RCC_APB1ENR2_SWPMI1EN_GET(x)       (((x) >> 2) & 0x1)
/** LPTIM2EN @multiple */
  #define STM32_RCC_APB1ENR2_LPTIM2EN_MASK         0x00000001
  #define STM32_RCC_APB1ENR2_LPTIM2EN              0x00000020
  #define STM32_RCC_APB1ENR2_LPTIM2EN_SET(x, v)    do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define STM32_RCC_APB1ENR2_LPTIM2EN_GET(x)       (((x) >> 5) & 0x1)

/** APB2ENR @multiple */
#define STM32_RCC_APB2ENR_ADDR                       0x00000060
/** SYSCFG clock enable @multiple */
  #define STM32_RCC_APB2ENR_SYSCFGEN_MASK          0x00000001
  #define STM32_RCC_APB2ENR_SYSCFGEN               0x00000001
  #define STM32_RCC_APB2ENR_SYSCFGEN_SET(x, v)     do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_APB2ENR_SYSCFGEN_GET(x)        (((x) >> 0) & 0x1)
/** Firewall clock enable @multiple */
  #define STM32_RCC_APB2ENR_FIREWALLEN_MASK        0x00000001
  #define STM32_RCC_APB2ENR_FIREWALLEN             0x00000080
  #define STM32_RCC_APB2ENR_FIREWALLEN_SET(x, v)   do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
  #define STM32_RCC_APB2ENR_FIREWALLEN_GET(x)      (((x) >> 7) & 0x1)
/** SDMMC clock enable @multiple */
  #define STM32_RCC_APB2ENR_SDMMCEN_MASK           0x00000001
  #define STM32_RCC_APB2ENR_SDMMCEN                0x00000400
  #define STM32_RCC_APB2ENR_SDMMCEN_SET(x, v)      do { (x) = (((x) & ~0x400) | ((v) << 10)); } while(0)
  #define STM32_RCC_APB2ENR_SDMMCEN_GET(x)         (((x) >> 10) & 0x1)
/** TIM1 timer clock enable @multiple */
  #define STM32_RCC_APB2ENR_TIM1EN_MASK            0x00000001
  #define STM32_RCC_APB2ENR_TIM1EN                 0x00000800
  #define STM32_RCC_APB2ENR_TIM1EN_SET(x, v)       do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
  #define STM32_RCC_APB2ENR_TIM1EN_GET(x)          (((x) >> 11) & 0x1)
/** SPI1 clock enable @multiple */
  #define STM32_RCC_APB2ENR_SPI1EN_MASK            0x00000001
  #define STM32_RCC_APB2ENR_SPI1EN                 0x00001000
  #define STM32_RCC_APB2ENR_SPI1EN_SET(x, v)       do { (x) = (((x) & ~0x1000) | ((v) << 12)); } while(0)
  #define STM32_RCC_APB2ENR_SPI1EN_GET(x)          (((x) >> 12) & 0x1)
/** TIM8 timer clock enable @multiple */
  #define STM32_RCC_APB2ENR_TIM8EN_MASK            0x00000001
  #define STM32_RCC_APB2ENR_TIM8EN                 0x00002000
  #define STM32_RCC_APB2ENR_TIM8EN_SET(x, v)       do { (x) = (((x) & ~0x2000) | ((v) << 13)); } while(0)
  #define STM32_RCC_APB2ENR_TIM8EN_GET(x)          (((x) >> 13) & 0x1)
/** USART1clock enable @multiple */
  #define STM32_RCC_APB2ENR_USART1EN_MASK          0x00000001
  #define STM32_RCC_APB2ENR_USART1EN               0x00004000
  #define STM32_RCC_APB2ENR_USART1EN_SET(x, v)     do { (x) = (((x) & ~0x4000) | ((v) << 14)); } while(0)
  #define STM32_RCC_APB2ENR_USART1EN_GET(x)        (((x) >> 14) & 0x1)
/** TIM15 timer clock enable @multiple */
  #define STM32_RCC_APB2ENR_TIM15EN_MASK           0x00000001
  #define STM32_RCC_APB2ENR_TIM15EN                0x00010000
  #define STM32_RCC_APB2ENR_TIM15EN_SET(x, v)      do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define STM32_RCC_APB2ENR_TIM15EN_GET(x)         (((x) >> 16) & 0x1)
/** TIM16 timer clock enable @multiple */
  #define STM32_RCC_APB2ENR_TIM16EN_MASK           0x00000001
  #define STM32_RCC_APB2ENR_TIM16EN                0x00020000
  #define STM32_RCC_APB2ENR_TIM16EN_SET(x, v)      do { (x) = (((x) & ~0x20000) | ((v) << 17)); } while(0)
  #define STM32_RCC_APB2ENR_TIM16EN_GET(x)         (((x) >> 17) & 0x1)
/** TIM17 timer clock enable @multiple */
  #define STM32_RCC_APB2ENR_TIM17EN_MASK           0x00000001
  #define STM32_RCC_APB2ENR_TIM17EN                0x00040000
  #define STM32_RCC_APB2ENR_TIM17EN_SET(x, v)      do { (x) = (((x) & ~0x40000) | ((v) << 18)); } while(0)
  #define STM32_RCC_APB2ENR_TIM17EN_GET(x)         (((x) >> 18) & 0x1)
/** SAI1 clock enable @multiple */
  #define STM32_RCC_APB2ENR_SAI1EN_MASK            0x00000001
  #define STM32_RCC_APB2ENR_SAI1EN                 0x00200000
  #define STM32_RCC_APB2ENR_SAI1EN_SET(x, v)       do { (x) = (((x) & ~0x200000) | ((v) << 21)); } while(0)
  #define STM32_RCC_APB2ENR_SAI1EN_GET(x)          (((x) >> 21) & 0x1)
/** SAI2 clock enable @multiple */
  #define STM32_RCC_APB2ENR_SAI2EN_MASK            0x00000001
  #define STM32_RCC_APB2ENR_SAI2EN                 0x00400000
  #define STM32_RCC_APB2ENR_SAI2EN_SET(x, v)       do { (x) = (((x) & ~0x400000) | ((v) << 22)); } while(0)
  #define STM32_RCC_APB2ENR_SAI2EN_GET(x)          (((x) >> 22) & 0x1)
/** DFSDM timer clock enable @multiple */
  #define STM32_RCC_APB2ENR_DFSDMEN_MASK           0x00000001
  #define STM32_RCC_APB2ENR_DFSDMEN                0x01000000
  #define STM32_RCC_APB2ENR_DFSDMEN_SET(x, v)      do { (x) = (((x) & ~0x1000000) | ((v) << 24)); } while(0)
  #define STM32_RCC_APB2ENR_DFSDMEN_GET(x)         (((x) >> 24) & 0x1)

/** AHB1 peripheral clocks enable in Sleep and Stop modes register @multiple */
#define STM32_RCC_AHB1SMENR_ADDR                     0x00000068
/** DMA1 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB1SMENR_DMA1SMEN_MASK        0x00000001
  #define STM32_RCC_AHB1SMENR_DMA1SMEN             0x00000001
  #define STM32_RCC_AHB1SMENR_DMA1SMEN_SET(x, v)   do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_AHB1SMENR_DMA1SMEN_GET(x)      (((x) >> 0) & 0x1)
/** DMA2 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB1SMENR_DMA2SMEN_MASK        0x00000001
  #define STM32_RCC_AHB1SMENR_DMA2SMEN             0x00000002
  #define STM32_RCC_AHB1SMENR_DMA2SMEN_SET(x, v)   do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_AHB1SMENR_DMA2SMEN_GET(x)      (((x) >> 1) & 0x1)
/** Flash memory interface clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB1SMENR_FLASHSMEN_MASK       0x00000001
  #define STM32_RCC_AHB1SMENR_FLASHSMEN            0x00000100
  #define STM32_RCC_AHB1SMENR_FLASHSMEN_SET(x, v)  do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define STM32_RCC_AHB1SMENR_FLASHSMEN_GET(x)     (((x) >> 8) & 0x1)
/** SRAM1 interface clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB1SMENR_SRAM1SMEN_MASK       0x00000001
  #define STM32_RCC_AHB1SMENR_SRAM1SMEN            0x00000200
  #define STM32_RCC_AHB1SMENR_SRAM1SMEN_SET(x, v)  do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
  #define STM32_RCC_AHB1SMENR_SRAM1SMEN_GET(x)     (((x) >> 9) & 0x1)
/** CRCSMEN @multiple */
  #define STM32_RCC_AHB1SMENR_CRCSMEN_MASK         0x00000001
  #define STM32_RCC_AHB1SMENR_CRCSMEN              0x00000800
  #define STM32_RCC_AHB1SMENR_CRCSMEN_SET(x, v)    do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
  #define STM32_RCC_AHB1SMENR_CRCSMEN_GET(x)       (((x) >> 11) & 0x1)
/** Touch Sensing Controller clocks enable during Sleep and Stop modes @multiple
   */
  #define STM32_RCC_AHB1SMENR_TSCSMEN_MASK         0x00000001
  #define STM32_RCC_AHB1SMENR_TSCSMEN              0x00010000
  #define STM32_RCC_AHB1SMENR_TSCSMEN_SET(x, v)    do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define STM32_RCC_AHB1SMENR_TSCSMEN_GET(x)       (((x) >> 16) & 0x1)

/** AHB2 peripheral clocks enable in Sleep and Stop modes register @multiple */
#define STM32_RCC_AHB2SMENR_ADDR                     0x0000006c
/** IO port A clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB2SMENR_GPIOASMEN_MASK       0x00000001
  #define STM32_RCC_AHB2SMENR_GPIOASMEN            0x00000001
  #define STM32_RCC_AHB2SMENR_GPIOASMEN_SET(x, v)  do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_AHB2SMENR_GPIOASMEN_GET(x)     (((x) >> 0) & 0x1)
/** IO port B clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB2SMENR_GPIOBSMEN_MASK       0x00000001
  #define STM32_RCC_AHB2SMENR_GPIOBSMEN            0x00000002
  #define STM32_RCC_AHB2SMENR_GPIOBSMEN_SET(x, v)  do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_AHB2SMENR_GPIOBSMEN_GET(x)     (((x) >> 1) & 0x1)
/** IO port C clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB2SMENR_GPIOCSMEN_MASK       0x00000001
  #define STM32_RCC_AHB2SMENR_GPIOCSMEN            0x00000004
  #define STM32_RCC_AHB2SMENR_GPIOCSMEN_SET(x, v)  do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define STM32_RCC_AHB2SMENR_GPIOCSMEN_GET(x)     (((x) >> 2) & 0x1)
/** IO port D clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB2SMENR_GPIODSMEN_MASK       0x00000001
  #define STM32_RCC_AHB2SMENR_GPIODSMEN            0x00000008
  #define STM32_RCC_AHB2SMENR_GPIODSMEN_SET(x, v)  do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define STM32_RCC_AHB2SMENR_GPIODSMEN_GET(x)     (((x) >> 3) & 0x1)
/** IO port E clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB2SMENR_GPIOESMEN_MASK       0x00000001
  #define STM32_RCC_AHB2SMENR_GPIOESMEN            0x00000010
  #define STM32_RCC_AHB2SMENR_GPIOESMEN_SET(x, v)  do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define STM32_RCC_AHB2SMENR_GPIOESMEN_GET(x)     (((x) >> 4) & 0x1)
/** IO port F clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB2SMENR_GPIOFSMEN_MASK       0x00000001
  #define STM32_RCC_AHB2SMENR_GPIOFSMEN            0x00000020
  #define STM32_RCC_AHB2SMENR_GPIOFSMEN_SET(x, v)  do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define STM32_RCC_AHB2SMENR_GPIOFSMEN_GET(x)     (((x) >> 5) & 0x1)
/** IO port G clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB2SMENR_GPIOGSMEN_MASK       0x00000001
  #define STM32_RCC_AHB2SMENR_GPIOGSMEN            0x00000040
  #define STM32_RCC_AHB2SMENR_GPIOGSMEN_SET(x, v)  do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
  #define STM32_RCC_AHB2SMENR_GPIOGSMEN_GET(x)     (((x) >> 6) & 0x1)
/** IO port H clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB2SMENR_GPIOHSMEN_MASK       0x00000001
  #define STM32_RCC_AHB2SMENR_GPIOHSMEN            0x00000080
  #define STM32_RCC_AHB2SMENR_GPIOHSMEN_SET(x, v)  do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
  #define STM32_RCC_AHB2SMENR_GPIOHSMEN_GET(x)     (((x) >> 7) & 0x1)
/** SRAM2 interface clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB2SMENR_SRAM2SMEN_MASK       0x00000001
  #define STM32_RCC_AHB2SMENR_SRAM2SMEN            0x00000200
  #define STM32_RCC_AHB2SMENR_SRAM2SMEN_SET(x, v)  do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
  #define STM32_RCC_AHB2SMENR_SRAM2SMEN_GET(x)     (((x) >> 9) & 0x1)
/** OTG full speed clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB2SMENR_OTGFSSMEN_MASK       0x00000001
  #define STM32_RCC_AHB2SMENR_OTGFSSMEN            0x00001000
  #define STM32_RCC_AHB2SMENR_OTGFSSMEN_SET(x, v)  do { (x) = (((x) & ~0x1000) | ((v) << 12)); } while(0)
  #define STM32_RCC_AHB2SMENR_OTGFSSMEN_GET(x)     (((x) >> 12) & 0x1)
/** ADC clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB2SMENR_ADCFSSMEN_MASK       0x00000001
  #define STM32_RCC_AHB2SMENR_ADCFSSMEN            0x00002000
  #define STM32_RCC_AHB2SMENR_ADCFSSMEN_SET(x, v)  do { (x) = (((x) & ~0x2000) | ((v) << 13)); } while(0)
  #define STM32_RCC_AHB2SMENR_ADCFSSMEN_GET(x)     (((x) >> 13) & 0x1)
/** AES accelerator clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_AHB2SMENR_AESSMEN_MASK         0x00000001
  #define STM32_RCC_AHB2SMENR_AESSMEN              0x00010000
  #define STM32_RCC_AHB2SMENR_AESSMEN_SET(x, v)    do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define STM32_RCC_AHB2SMENR_AESSMEN_GET(x)       (((x) >> 16) & 0x1)
/** Random Number Generator clocks enable during Sleep and Stop modes @multiple
   */
  #define STM32_RCC_AHB2SMENR_RNGSMEN_MASK         0x00000001
  #define STM32_RCC_AHB2SMENR_RNGSMEN              0x00040000
  #define STM32_RCC_AHB2SMENR_RNGSMEN_SET(x, v)    do { (x) = (((x) & ~0x40000) | ((v) << 18)); } while(0)
  #define STM32_RCC_AHB2SMENR_RNGSMEN_GET(x)       (((x) >> 18) & 0x1)

/** AHB3 peripheral clocks enable in Sleep and Stop modes register @multiple */
#define STM32_RCC_AHB3SMENR_ADDR                     0x00000070
/** Flexible memory controller clocks enable during Sleep and Stop modes
   @multiple */
  #define STM32_RCC_AHB3SMENR_FMCSMEN_MASK         0x00000001
  #define STM32_RCC_AHB3SMENR_FMCSMEN              0x00000001
  #define STM32_RCC_AHB3SMENR_FMCSMEN_SET(x, v)    do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_AHB3SMENR_FMCSMEN_GET(x)       (((x) >> 0) & 0x1)
/** QSPISMEN @multiple */
  #define STM32_RCC_AHB3SMENR_QSPISMEN_MASK        0x00000001
  #define STM32_RCC_AHB3SMENR_QSPISMEN             0x00000100
  #define STM32_RCC_AHB3SMENR_QSPISMEN_SET(x, v)   do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define STM32_RCC_AHB3SMENR_QSPISMEN_GET(x)      (((x) >> 8) & 0x1)

/** APB1SMENR1 @multiple */
#define STM32_RCC_APB1SMENR1_ADDR                    0x00000078
/** TIM2 timer clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_TIM2SMEN_MASK       0x00000001
  #define STM32_RCC_APB1SMENR1_TIM2SMEN            0x00000001
  #define STM32_RCC_APB1SMENR1_TIM2SMEN_SET(x, v)  do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_APB1SMENR1_TIM2SMEN_GET(x)     (((x) >> 0) & 0x1)
/** TIM3 timer clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_TIM3SMEN_MASK       0x00000001
  #define STM32_RCC_APB1SMENR1_TIM3SMEN            0x00000002
  #define STM32_RCC_APB1SMENR1_TIM3SMEN_SET(x, v)  do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_APB1SMENR1_TIM3SMEN_GET(x)     (((x) >> 1) & 0x1)
/** TIM4 timer clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_TIM4SMEN_MASK       0x00000001
  #define STM32_RCC_APB1SMENR1_TIM4SMEN            0x00000004
  #define STM32_RCC_APB1SMENR1_TIM4SMEN_SET(x, v)  do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define STM32_RCC_APB1SMENR1_TIM4SMEN_GET(x)     (((x) >> 2) & 0x1)
/** Reserved @multiple */
  #define STM32_RCC_APB1SMENR1_TIM5SMEN_MASK       0x00000001
  #define STM32_RCC_APB1SMENR1_TIM5SMEN            0x00000008
  #define STM32_RCC_APB1SMENR1_TIM5SMEN_SET(x, v)  do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define STM32_RCC_APB1SMENR1_TIM5SMEN_GET(x)     (((x) >> 3) & 0x1)
/** TIM6 timer clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_TIM6SMEN_MASK       0x00000001
  #define STM32_RCC_APB1SMENR1_TIM6SMEN            0x00000010
  #define STM32_RCC_APB1SMENR1_TIM6SMEN_SET(x, v)  do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define STM32_RCC_APB1SMENR1_TIM6SMEN_GET(x)     (((x) >> 4) & 0x1)
/** TIM7 timer clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_TIM7SMEN_MASK       0x00000001
  #define STM32_RCC_APB1SMENR1_TIM7SMEN            0x00000020
  #define STM32_RCC_APB1SMENR1_TIM7SMEN_SET(x, v)  do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define STM32_RCC_APB1SMENR1_TIM7SMEN_GET(x)     (((x) >> 5) & 0x1)
/** LCD clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_LCDSMEN_MASK        0x00000001
  #define STM32_RCC_APB1SMENR1_LCDSMEN             0x00000200
  #define STM32_RCC_APB1SMENR1_LCDSMEN_SET(x, v)   do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
  #define STM32_RCC_APB1SMENR1_LCDSMEN_GET(x)      (((x) >> 9) & 0x1)
/** Window watchdog clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_WWDGSMEN_MASK       0x00000001
  #define STM32_RCC_APB1SMENR1_WWDGSMEN            0x00000800
  #define STM32_RCC_APB1SMENR1_WWDGSMEN_SET(x, v)  do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
  #define STM32_RCC_APB1SMENR1_WWDGSMEN_GET(x)     (((x) >> 11) & 0x1)
/** SPI2 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_SPI2SMEN_MASK       0x00000001
  #define STM32_RCC_APB1SMENR1_SPI2SMEN            0x00004000
  #define STM32_RCC_APB1SMENR1_SPI2SMEN_SET(x, v)  do { (x) = (((x) & ~0x4000) | ((v) << 14)); } while(0)
  #define STM32_RCC_APB1SMENR1_SPI2SMEN_GET(x)     (((x) >> 14) & 0x1)
/** SPI3 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_SP3SMEN_MASK        0x00000001
  #define STM32_RCC_APB1SMENR1_SP3SMEN             0x00008000
  #define STM32_RCC_APB1SMENR1_SP3SMEN_SET(x, v)   do { (x) = (((x) & ~0x8000) | ((v) << 15)); } while(0)
  #define STM32_RCC_APB1SMENR1_SP3SMEN_GET(x)      (((x) >> 15) & 0x1)
/** USART2 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_USART2SMEN_MASK     0x00000001
  #define STM32_RCC_APB1SMENR1_USART2SMEN          0x00020000
  #define STM32_RCC_APB1SMENR1_USART2SMEN_SET(x, v) do { (x) = (((x) & ~0x20000) | ((v) << 17)); } while(0)
  #define STM32_RCC_APB1SMENR1_USART2SMEN_GET(x)   (((x) >> 17) & 0x1)
/** USART3 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_USART3SMEN_MASK     0x00000001
  #define STM32_RCC_APB1SMENR1_USART3SMEN          0x00040000
  #define STM32_RCC_APB1SMENR1_USART3SMEN_SET(x, v) do { (x) = (((x) & ~0x40000) | ((v) << 18)); } while(0)
  #define STM32_RCC_APB1SMENR1_USART3SMEN_GET(x)   (((x) >> 18) & 0x1)
/** UART4 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_UART4SMEN_MASK      0x00000001
  #define STM32_RCC_APB1SMENR1_UART4SMEN           0x00080000
  #define STM32_RCC_APB1SMENR1_UART4SMEN_SET(x, v) do { (x) = (((x) & ~0x80000) | ((v) << 19)); } while(0)
  #define STM32_RCC_APB1SMENR1_UART4SMEN_GET(x)    (((x) >> 19) & 0x1)
/** UART5 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_UART5SMEN_MASK      0x00000001
  #define STM32_RCC_APB1SMENR1_UART5SMEN           0x00100000
  #define STM32_RCC_APB1SMENR1_UART5SMEN_SET(x, v) do { (x) = (((x) & ~0x100000) | ((v) << 20)); } while(0)
  #define STM32_RCC_APB1SMENR1_UART5SMEN_GET(x)    (((x) >> 20) & 0x1)
/** I2C1 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_I2C1SMEN_MASK       0x00000001
  #define STM32_RCC_APB1SMENR1_I2C1SMEN            0x00200000
  #define STM32_RCC_APB1SMENR1_I2C1SMEN_SET(x, v)  do { (x) = (((x) & ~0x200000) | ((v) << 21)); } while(0)
  #define STM32_RCC_APB1SMENR1_I2C1SMEN_GET(x)     (((x) >> 21) & 0x1)
/** I2C2 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_I2C2SMEN_MASK       0x00000001
  #define STM32_RCC_APB1SMENR1_I2C2SMEN            0x00400000
  #define STM32_RCC_APB1SMENR1_I2C2SMEN_SET(x, v)  do { (x) = (((x) & ~0x400000) | ((v) << 22)); } while(0)
  #define STM32_RCC_APB1SMENR1_I2C2SMEN_GET(x)     (((x) >> 22) & 0x1)
/** I2C3 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_I2C3SMEN_MASK       0x00000001
  #define STM32_RCC_APB1SMENR1_I2C3SMEN            0x00800000
  #define STM32_RCC_APB1SMENR1_I2C3SMEN_SET(x, v)  do { (x) = (((x) & ~0x800000) | ((v) << 23)); } while(0)
  #define STM32_RCC_APB1SMENR1_I2C3SMEN_GET(x)     (((x) >> 23) & 0x1)
/** CAN1 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_CAN1SMEN_MASK       0x00000001
  #define STM32_RCC_APB1SMENR1_CAN1SMEN            0x02000000
  #define STM32_RCC_APB1SMENR1_CAN1SMEN_SET(x, v)  do { (x) = (((x) & ~0x2000000) | ((v) << 25)); } while(0)
  #define STM32_RCC_APB1SMENR1_CAN1SMEN_GET(x)     (((x) >> 25) & 0x1)
/** Power interface clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_PWRSMEN_MASK        0x00000001
  #define STM32_RCC_APB1SMENR1_PWRSMEN             0x10000000
  #define STM32_RCC_APB1SMENR1_PWRSMEN_SET(x, v)   do { (x) = (((x) & ~0x10000000) | ((v) << 28)); } while(0)
  #define STM32_RCC_APB1SMENR1_PWRSMEN_GET(x)      (((x) >> 28) & 0x1)
/** DAC1 interface clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_DAC1SMEN_MASK       0x00000001
  #define STM32_RCC_APB1SMENR1_DAC1SMEN            0x20000000
  #define STM32_RCC_APB1SMENR1_DAC1SMEN_SET(x, v)  do { (x) = (((x) & ~0x20000000) | ((v) << 29)); } while(0)
  #define STM32_RCC_APB1SMENR1_DAC1SMEN_GET(x)     (((x) >> 29) & 0x1)
/** OPAMP interface clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_OPAMPSMEN_MASK      0x00000001
  #define STM32_RCC_APB1SMENR1_OPAMPSMEN           0x40000000
  #define STM32_RCC_APB1SMENR1_OPAMPSMEN_SET(x, v) do { (x) = (((x) & ~0x40000000) | ((v) << 30)); } while(0)
  #define STM32_RCC_APB1SMENR1_OPAMPSMEN_GET(x)    (((x) >> 30) & 0x1)
/** Low power timer 1 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR1_LPTIM1SMEN_MASK     0x00000001
  #define STM32_RCC_APB1SMENR1_LPTIM1SMEN          0x80000000
  #define STM32_RCC_APB1SMENR1_LPTIM1SMEN_SET(x, v) do { (x) = (((x) & ~0x80000000) | ((v) << 31)); } while(0)
  #define STM32_RCC_APB1SMENR1_LPTIM1SMEN_GET(x)   (((x) >> 31) & 0x1)

/** APB1 peripheral clocks enable in Sleep and Stop modes register 2 @multiple */
#define STM32_RCC_APB1SMENR2_ADDR                    0x0000007c
/** Low power UART 1 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR2_LPUART1SMEN_MASK    0x00000001
  #define STM32_RCC_APB1SMENR2_LPUART1SMEN         0x00000001
  #define STM32_RCC_APB1SMENR2_LPUART1SMEN_SET(x, v) do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_APB1SMENR2_LPUART1SMEN_GET(x)  (((x) >> 0) & 0x1)
/** Single wire protocol clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB1SMENR2_SWPMI1SMEN_MASK     0x00000001
  #define STM32_RCC_APB1SMENR2_SWPMI1SMEN          0x00000004
  #define STM32_RCC_APB1SMENR2_SWPMI1SMEN_SET(x, v) do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define STM32_RCC_APB1SMENR2_SWPMI1SMEN_GET(x)   (((x) >> 2) & 0x1)
/** LPTIM2SMEN @multiple */
  #define STM32_RCC_APB1SMENR2_LPTIM2SMEN_MASK     0x00000001
  #define STM32_RCC_APB1SMENR2_LPTIM2SMEN          0x00000020
  #define STM32_RCC_APB1SMENR2_LPTIM2SMEN_SET(x, v) do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define STM32_RCC_APB1SMENR2_LPTIM2SMEN_GET(x)   (((x) >> 5) & 0x1)

/** APB2SMENR @multiple */
#define STM32_RCC_APB2SMENR_ADDR                     0x00000080
/** SYSCFG clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB2SMENR_SYSCFGSMEN_MASK      0x00000001
  #define STM32_RCC_APB2SMENR_SYSCFGSMEN           0x00000001
  #define STM32_RCC_APB2SMENR_SYSCFGSMEN_SET(x, v) do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_APB2SMENR_SYSCFGSMEN_GET(x)    (((x) >> 0) & 0x1)
/** SDMMC clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB2SMENR_SDMMCSMEN_MASK       0x00000001
  #define STM32_RCC_APB2SMENR_SDMMCSMEN            0x00000400
  #define STM32_RCC_APB2SMENR_SDMMCSMEN_SET(x, v)  do { (x) = (((x) & ~0x400) | ((v) << 10)); } while(0)
  #define STM32_RCC_APB2SMENR_SDMMCSMEN_GET(x)     (((x) >> 10) & 0x1)
/** TIM1 timer clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB2SMENR_TIM1SMEN_MASK        0x00000001
  #define STM32_RCC_APB2SMENR_TIM1SMEN             0x00000800
  #define STM32_RCC_APB2SMENR_TIM1SMEN_SET(x, v)   do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
  #define STM32_RCC_APB2SMENR_TIM1SMEN_GET(x)      (((x) >> 11) & 0x1)
/** SPI1 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB2SMENR_SPI1SMEN_MASK        0x00000001
  #define STM32_RCC_APB2SMENR_SPI1SMEN             0x00001000
  #define STM32_RCC_APB2SMENR_SPI1SMEN_SET(x, v)   do { (x) = (((x) & ~0x1000) | ((v) << 12)); } while(0)
  #define STM32_RCC_APB2SMENR_SPI1SMEN_GET(x)      (((x) >> 12) & 0x1)
/** TIM8 timer clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB2SMENR_TIM8SMEN_MASK        0x00000001
  #define STM32_RCC_APB2SMENR_TIM8SMEN             0x00002000
  #define STM32_RCC_APB2SMENR_TIM8SMEN_SET(x, v)   do { (x) = (((x) & ~0x2000) | ((v) << 13)); } while(0)
  #define STM32_RCC_APB2SMENR_TIM8SMEN_GET(x)      (((x) >> 13) & 0x1)
/** USART1clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB2SMENR_USART1SMEN_MASK      0x00000001
  #define STM32_RCC_APB2SMENR_USART1SMEN           0x00004000
  #define STM32_RCC_APB2SMENR_USART1SMEN_SET(x, v) do { (x) = (((x) & ~0x4000) | ((v) << 14)); } while(0)
  #define STM32_RCC_APB2SMENR_USART1SMEN_GET(x)    (((x) >> 14) & 0x1)
/** TIM15 timer clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB2SMENR_TIM15SMEN_MASK       0x00000001
  #define STM32_RCC_APB2SMENR_TIM15SMEN            0x00010000
  #define STM32_RCC_APB2SMENR_TIM15SMEN_SET(x, v)  do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define STM32_RCC_APB2SMENR_TIM15SMEN_GET(x)     (((x) >> 16) & 0x1)
/** TIM16 timer clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB2SMENR_TIM16SMEN_MASK       0x00000001
  #define STM32_RCC_APB2SMENR_TIM16SMEN            0x00020000
  #define STM32_RCC_APB2SMENR_TIM16SMEN_SET(x, v)  do { (x) = (((x) & ~0x20000) | ((v) << 17)); } while(0)
  #define STM32_RCC_APB2SMENR_TIM16SMEN_GET(x)     (((x) >> 17) & 0x1)
/** TIM17 timer clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB2SMENR_TIM17SMEN_MASK       0x00000001
  #define STM32_RCC_APB2SMENR_TIM17SMEN            0x00040000
  #define STM32_RCC_APB2SMENR_TIM17SMEN_SET(x, v)  do { (x) = (((x) & ~0x40000) | ((v) << 18)); } while(0)
  #define STM32_RCC_APB2SMENR_TIM17SMEN_GET(x)     (((x) >> 18) & 0x1)
/** SAI1 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB2SMENR_SAI1SMEN_MASK        0x00000001
  #define STM32_RCC_APB2SMENR_SAI1SMEN             0x00200000
  #define STM32_RCC_APB2SMENR_SAI1SMEN_SET(x, v)   do { (x) = (((x) & ~0x200000) | ((v) << 21)); } while(0)
  #define STM32_RCC_APB2SMENR_SAI1SMEN_GET(x)      (((x) >> 21) & 0x1)
/** SAI2 clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB2SMENR_SAI2SMEN_MASK        0x00000001
  #define STM32_RCC_APB2SMENR_SAI2SMEN             0x00400000
  #define STM32_RCC_APB2SMENR_SAI2SMEN_SET(x, v)   do { (x) = (((x) & ~0x400000) | ((v) << 22)); } while(0)
  #define STM32_RCC_APB2SMENR_SAI2SMEN_GET(x)      (((x) >> 22) & 0x1)
/** DFSDM timer clocks enable during Sleep and Stop modes @multiple */
  #define STM32_RCC_APB2SMENR_DFSDMSMEN_MASK       0x00000001
  #define STM32_RCC_APB2SMENR_DFSDMSMEN            0x01000000
  #define STM32_RCC_APB2SMENR_DFSDMSMEN_SET(x, v)  do { (x) = (((x) & ~0x1000000) | ((v) << 24)); } while(0)
  #define STM32_RCC_APB2SMENR_DFSDMSMEN_GET(x)     (((x) >> 24) & 0x1)

/** CCIPR @multiple */
#define STM32_RCC_CCIPR_ADDR                         0x00000088
/** USART1 clock source selection @multiple */
  #define STM32_RCC_CCIPR_USART1SEL_MASK           0x00000003
  #define STM32_RCC_CCIPR_USART1SEL(v)             ((v) << 0)
  #define STM32_RCC_CCIPR_USART1SEL_SET(x, v)      do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define STM32_RCC_CCIPR_USART1SEL_GET(x)         (((x) >> 0) & 0x3)
/** USART2 clock source selection @multiple */
  #define STM32_RCC_CCIPR_USART2SEL_MASK           0x00000003
  #define STM32_RCC_CCIPR_USART2SEL(v)             ((v) << 2)
  #define STM32_RCC_CCIPR_USART2SEL_SET(x, v)      do { (x) = (((x) & ~0xc) | ((v) << 2)); } while(0)
  #define STM32_RCC_CCIPR_USART2SEL_GET(x)         (((x) >> 2) & 0x3)
/** USART3 clock source selection @multiple */
  #define STM32_RCC_CCIPR_USART3SEL_MASK           0x00000003
  #define STM32_RCC_CCIPR_USART3SEL(v)             ((v) << 4)
  #define STM32_RCC_CCIPR_USART3SEL_SET(x, v)      do { (x) = (((x) & ~0x30) | ((v) << 4)); } while(0)
  #define STM32_RCC_CCIPR_USART3SEL_GET(x)         (((x) >> 4) & 0x3)
/** UART4 clock source selection @multiple */
  #define STM32_RCC_CCIPR_UART4SEL_MASK            0x00000003
  #define STM32_RCC_CCIPR_UART4SEL(v)              ((v) << 6)
  #define STM32_RCC_CCIPR_UART4SEL_SET(x, v)       do { (x) = (((x) & ~0xc0) | ((v) << 6)); } while(0)
  #define STM32_RCC_CCIPR_UART4SEL_GET(x)          (((x) >> 6) & 0x3)
/** UART5 clock source selection @multiple */
  #define STM32_RCC_CCIPR_UART5SEL_MASK            0x00000003
  #define STM32_RCC_CCIPR_UART5SEL(v)              ((v) << 8)
  #define STM32_RCC_CCIPR_UART5SEL_SET(x, v)       do { (x) = (((x) & ~0x300) | ((v) << 8)); } while(0)
  #define STM32_RCC_CCIPR_UART5SEL_GET(x)          (((x) >> 8) & 0x3)
/** LPUART1 clock source selection @multiple */
  #define STM32_RCC_CCIPR_LPUART1SEL_MASK          0x00000003
  #define STM32_RCC_CCIPR_LPUART1SEL(v)            ((v) << 10)
  #define STM32_RCC_CCIPR_LPUART1SEL_SET(x, v)     do { (x) = (((x) & ~0xc00) | ((v) << 10)); } while(0)
  #define STM32_RCC_CCIPR_LPUART1SEL_GET(x)        (((x) >> 10) & 0x3)
/** I2C1 clock source selection @multiple */
  #define STM32_RCC_CCIPR_I2C1SEL_MASK             0x00000003
  #define STM32_RCC_CCIPR_I2C1SEL(v)               ((v) << 12)
  #define STM32_RCC_CCIPR_I2C1SEL_SET(x, v)        do { (x) = (((x) & ~0x3000) | ((v) << 12)); } while(0)
  #define STM32_RCC_CCIPR_I2C1SEL_GET(x)           (((x) >> 12) & 0x3)
/** I2C2 clock source selection @multiple */
  #define STM32_RCC_CCIPR_I2C2SEL_MASK             0x00000003
  #define STM32_RCC_CCIPR_I2C2SEL(v)               ((v) << 14)
  #define STM32_RCC_CCIPR_I2C2SEL_SET(x, v)        do { (x) = (((x) & ~0xc000) | ((v) << 14)); } while(0)
  #define STM32_RCC_CCIPR_I2C2SEL_GET(x)           (((x) >> 14) & 0x3)
/** I2C3 clock source selection @multiple */
  #define STM32_RCC_CCIPR_I2C3SEL_MASK             0x00000003
  #define STM32_RCC_CCIPR_I2C3SEL(v)               ((v) << 16)
  #define STM32_RCC_CCIPR_I2C3SEL_SET(x, v)        do { (x) = (((x) & ~0x30000) | ((v) << 16)); } while(0)
  #define STM32_RCC_CCIPR_I2C3SEL_GET(x)           (((x) >> 16) & 0x3)
/** Low power timer 1 clock source selection @multiple */
  #define STM32_RCC_CCIPR_LPTIM1SEL_MASK           0x00000003
  #define STM32_RCC_CCIPR_LPTIM1SEL(v)             ((v) << 18)
  #define STM32_RCC_CCIPR_LPTIM1SEL_SET(x, v)      do { (x) = (((x) & ~0xc0000) | ((v) << 18)); } while(0)
  #define STM32_RCC_CCIPR_LPTIM1SEL_GET(x)         (((x) >> 18) & 0x3)
/** Low power timer 2 clock source selection @multiple */
  #define STM32_RCC_CCIPR_LPTIM2SEL_MASK           0x00000003
  #define STM32_RCC_CCIPR_LPTIM2SEL(v)             ((v) << 20)
  #define STM32_RCC_CCIPR_LPTIM2SEL_SET(x, v)      do { (x) = (((x) & ~0x300000) | ((v) << 20)); } while(0)
  #define STM32_RCC_CCIPR_LPTIM2SEL_GET(x)         (((x) >> 20) & 0x3)
/** SAI1 clock source selection @multiple */
  #define STM32_RCC_CCIPR_SAI1SEL_MASK             0x00000003
  #define STM32_RCC_CCIPR_SAI1SEL(v)               ((v) << 22)
  #define STM32_RCC_CCIPR_SAI1SEL_SET(x, v)        do { (x) = (((x) & ~0xc00000) | ((v) << 22)); } while(0)
  #define STM32_RCC_CCIPR_SAI1SEL_GET(x)           (((x) >> 22) & 0x3)
/** SAI2 clock source selection @multiple */
  #define STM32_RCC_CCIPR_SAI2SEL_MASK             0x00000003
  #define STM32_RCC_CCIPR_SAI2SEL(v)               ((v) << 24)
  #define STM32_RCC_CCIPR_SAI2SEL_SET(x, v)        do { (x) = (((x) & ~0x3000000) | ((v) << 24)); } while(0)
  #define STM32_RCC_CCIPR_SAI2SEL_GET(x)           (((x) >> 24) & 0x3)
/** 48 MHz clock source selection @multiple */
  #define STM32_RCC_CCIPR_CLK48SEL_MASK            0x00000003
  #define STM32_RCC_CCIPR_CLK48SEL(v)              ((v) << 26)
  #define STM32_RCC_CCIPR_CLK48SEL_SET(x, v)       do { (x) = (((x) & ~0xc000000) | ((v) << 26)); } while(0)
  #define STM32_RCC_CCIPR_CLK48SEL_GET(x)          (((x) >> 26) & 0x3)
/** ADCs clock source selection @multiple */
  #define STM32_RCC_CCIPR_ADCSEL_MASK              0x00000003
  #define STM32_RCC_CCIPR_ADCSEL(v)                ((v) << 28)
  #define STM32_RCC_CCIPR_ADCSEL_SET(x, v)         do { (x) = (((x) & ~0x30000000) | ((v) << 28)); } while(0)
  #define STM32_RCC_CCIPR_ADCSEL_GET(x)            (((x) >> 28) & 0x3)
/** SWPMI1 clock source selection @multiple */
  #define STM32_RCC_CCIPR_SWPMI1SEL_MASK           0x00000001
  #define STM32_RCC_CCIPR_SWPMI1SEL                0x40000000
  #define STM32_RCC_CCIPR_SWPMI1SEL_SET(x, v)      do { (x) = (((x) & ~0x40000000) | ((v) << 30)); } while(0)
  #define STM32_RCC_CCIPR_SWPMI1SEL_GET(x)         (((x) >> 30) & 0x1)
/** DFSDM clock source selection @multiple */
  #define STM32_RCC_CCIPR_DFSDMSEL_MASK            0x00000001
  #define STM32_RCC_CCIPR_DFSDMSEL                 0x80000000
  #define STM32_RCC_CCIPR_DFSDMSEL_SET(x, v)       do { (x) = (((x) & ~0x80000000) | ((v) << 31)); } while(0)
  #define STM32_RCC_CCIPR_DFSDMSEL_GET(x)          (((x) >> 31) & 0x1)

/** BDCR @multiple */
#define STM32_RCC_BDCR_ADDR                          0x00000090
/** LSE oscillator enable @multiple */
  #define STM32_RCC_BDCR_LSEON_MASK                0x00000001
  #define STM32_RCC_BDCR_LSEON                     0x00000001
  #define STM32_RCC_BDCR_LSEON_SET(x, v)           do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_BDCR_LSEON_GET(x)              (((x) >> 0) & 0x1)
/** LSE oscillator ready @multiple */
  #define STM32_RCC_BDCR_LSERDY_MASK               0x00000001
  #define STM32_RCC_BDCR_LSERDY                    0x00000002
  #define STM32_RCC_BDCR_LSERDY_SET(x, v)          do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_BDCR_LSERDY_GET(x)             (((x) >> 1) & 0x1)
/** LSE oscillator bypass @multiple */
  #define STM32_RCC_BDCR_LSEBYP_MASK               0x00000001
  #define STM32_RCC_BDCR_LSEBYP                    0x00000004
  #define STM32_RCC_BDCR_LSEBYP_SET(x, v)          do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define STM32_RCC_BDCR_LSEBYP_GET(x)             (((x) >> 2) & 0x1)
/** SE oscillator drive capability @multiple */
  #define STM32_RCC_BDCR_LSEDRV_MASK               0x00000003
  #define STM32_RCC_BDCR_LSEDRV(v)                 ((v) << 3)
  #define STM32_RCC_BDCR_LSEDRV_SET(x, v)          do { (x) = (((x) & ~0x18) | ((v) << 3)); } while(0)
  #define STM32_RCC_BDCR_LSEDRV_GET(x)             (((x) >> 3) & 0x3)
/** LSECSSON @multiple */
  #define STM32_RCC_BDCR_LSECSSON_MASK             0x00000001
  #define STM32_RCC_BDCR_LSECSSON                  0x00000020
  #define STM32_RCC_BDCR_LSECSSON_SET(x, v)        do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define STM32_RCC_BDCR_LSECSSON_GET(x)           (((x) >> 5) & 0x1)
/** LSECSSD @multiple */
  #define STM32_RCC_BDCR_LSECSSD_MASK              0x00000001
  #define STM32_RCC_BDCR_LSECSSD                   0x00000040
  #define STM32_RCC_BDCR_LSECSSD_SET(x, v)         do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
  #define STM32_RCC_BDCR_LSECSSD_GET(x)            (((x) >> 6) & 0x1)
/** RTC clock source selection @multiple */
  #define STM32_RCC_BDCR_RTCSEL_MASK               0x00000003
  #define STM32_RCC_BDCR_RTCSEL(v)                 ((v) << 8)
  #define STM32_RCC_BDCR_RTCSEL_SET(x, v)          do { (x) = (((x) & ~0x300) | ((v) << 8)); } while(0)
  #define STM32_RCC_BDCR_RTCSEL_GET(x)             (((x) >> 8) & 0x3)
/** RTC clock enable @multiple */
  #define STM32_RCC_BDCR_RTCEN_MASK                0x00000001
  #define STM32_RCC_BDCR_RTCEN                     0x00008000
  #define STM32_RCC_BDCR_RTCEN_SET(x, v)           do { (x) = (((x) & ~0x8000) | ((v) << 15)); } while(0)
  #define STM32_RCC_BDCR_RTCEN_GET(x)              (((x) >> 15) & 0x1)
/** Backup domain software reset @multiple */
  #define STM32_RCC_BDCR_BDRST_MASK                0x00000001
  #define STM32_RCC_BDCR_BDRST                     0x00010000
  #define STM32_RCC_BDCR_BDRST_SET(x, v)           do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define STM32_RCC_BDCR_BDRST_GET(x)              (((x) >> 16) & 0x1)
/** Low speed clock output enable @multiple */
  #define STM32_RCC_BDCR_LSCOEN_MASK               0x00000001
  #define STM32_RCC_BDCR_LSCOEN                    0x01000000
  #define STM32_RCC_BDCR_LSCOEN_SET(x, v)          do { (x) = (((x) & ~0x1000000) | ((v) << 24)); } while(0)
  #define STM32_RCC_BDCR_LSCOEN_GET(x)             (((x) >> 24) & 0x1)
/** Low speed clock output selection @multiple */
  #define STM32_RCC_BDCR_LSCOSEL_MASK              0x00000001
  #define STM32_RCC_BDCR_LSCOSEL                   0x02000000
  #define STM32_RCC_BDCR_LSCOSEL_SET(x, v)         do { (x) = (((x) & ~0x2000000) | ((v) << 25)); } while(0)
  #define STM32_RCC_BDCR_LSCOSEL_GET(x)            (((x) >> 25) & 0x1)

/** CSR @multiple */
#define STM32_RCC_CSR_ADDR                           0x00000094
/** LSI oscillator enable @multiple */
  #define STM32_RCC_CSR_LSION_MASK                 0x00000001
  #define STM32_RCC_CSR_LSION                      0x00000001
  #define STM32_RCC_CSR_LSION_SET(x, v)            do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define STM32_RCC_CSR_LSION_GET(x)               (((x) >> 0) & 0x1)
/** LSI oscillator ready @multiple */
  #define STM32_RCC_CSR_LSIRDY_MASK                0x00000001
  #define STM32_RCC_CSR_LSIRDY                     0x00000002
  #define STM32_RCC_CSR_LSIRDY_SET(x, v)           do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define STM32_RCC_CSR_LSIRDY_GET(x)              (((x) >> 1) & 0x1)
/** SI range after Standby mode @multiple */
  #define STM32_RCC_CSR_MSISRANGE_MASK             0x0000000f
  #define STM32_RCC_CSR_MSISRANGE(v)               ((v) << 8)
  #define STM32_RCC_CSR_MSISRANGE_SET(x, v)        do { (x) = (((x) & ~0xf00) | ((v) << 8)); } while(0)
  #define STM32_RCC_CSR_MSISRANGE_GET(x)           (((x) >> 8) & 0xf)
/** Remove reset flag @multiple */
  #define STM32_RCC_CSR_RMVF_MASK                  0x00000001
  #define STM32_RCC_CSR_RMVF                       0x00800000
  #define STM32_RCC_CSR_RMVF_SET(x, v)             do { (x) = (((x) & ~0x800000) | ((v) << 23)); } while(0)
  #define STM32_RCC_CSR_RMVF_GET(x)                (((x) >> 23) & 0x1)
/** Firewall reset flag @multiple */
  #define STM32_RCC_CSR_FIREWALLRSTF_MASK          0x00000001
  #define STM32_RCC_CSR_FIREWALLRSTF               0x01000000
  #define STM32_RCC_CSR_FIREWALLRSTF_SET(x, v)     do { (x) = (((x) & ~0x1000000) | ((v) << 24)); } while(0)
  #define STM32_RCC_CSR_FIREWALLRSTF_GET(x)        (((x) >> 24) & 0x1)
/** Option byte loader reset flag @multiple */
  #define STM32_RCC_CSR_OBLRSTF_MASK               0x00000001
  #define STM32_RCC_CSR_OBLRSTF                    0x02000000
  #define STM32_RCC_CSR_OBLRSTF_SET(x, v)          do { (x) = (((x) & ~0x2000000) | ((v) << 25)); } while(0)
  #define STM32_RCC_CSR_OBLRSTF_GET(x)             (((x) >> 25) & 0x1)
/** Pin reset flag @multiple */
  #define STM32_RCC_CSR_PINRSTF_MASK               0x00000001
  #define STM32_RCC_CSR_PINRSTF                    0x04000000
  #define STM32_RCC_CSR_PINRSTF_SET(x, v)          do { (x) = (((x) & ~0x4000000) | ((v) << 26)); } while(0)
  #define STM32_RCC_CSR_PINRSTF_GET(x)             (((x) >> 26) & 0x1)
/** BOR flag @multiple */
  #define STM32_RCC_CSR_BORRSTF_MASK               0x00000001
  #define STM32_RCC_CSR_BORRSTF                    0x08000000
  #define STM32_RCC_CSR_BORRSTF_SET(x, v)          do { (x) = (((x) & ~0x8000000) | ((v) << 27)); } while(0)
  #define STM32_RCC_CSR_BORRSTF_GET(x)             (((x) >> 27) & 0x1)
/** Software reset flag @multiple */
  #define STM32_RCC_CSR_SFTRSTF_MASK               0x00000001
  #define STM32_RCC_CSR_SFTRSTF                    0x10000000
  #define STM32_RCC_CSR_SFTRSTF_SET(x, v)          do { (x) = (((x) & ~0x10000000) | ((v) << 28)); } while(0)
  #define STM32_RCC_CSR_SFTRSTF_GET(x)             (((x) >> 28) & 0x1)
/** Independent window watchdog reset flag @multiple */
  #define STM32_RCC_CSR_IWDGRSTF_MASK              0x00000001
  #define STM32_RCC_CSR_IWDGRSTF                   0x20000000
  #define STM32_RCC_CSR_IWDGRSTF_SET(x, v)         do { (x) = (((x) & ~0x20000000) | ((v) << 29)); } while(0)
  #define STM32_RCC_CSR_IWDGRSTF_GET(x)            (((x) >> 29) & 0x1)
/** Window watchdog reset flag @multiple */
  #define STM32_RCC_CSR_WWDGRSTF_MASK              0x00000001
  #define STM32_RCC_CSR_WWDGRSTF                   0x40000000
  #define STM32_RCC_CSR_WWDGRSTF_SET(x, v)         do { (x) = (((x) & ~0x40000000) | ((v) << 30)); } while(0)
  #define STM32_RCC_CSR_WWDGRSTF_GET(x)            (((x) >> 30) & 0x1)
/** Low-power reset flag @multiple */
  #define STM32_RCC_CSR_LPWRSTF_MASK               0x00000001
  #define STM32_RCC_CSR_LPWRSTF                    0x80000000
  #define STM32_RCC_CSR_LPWRSTF_SET(x, v)          do { (x) = (((x) & ~0x80000000) | ((v) << 31)); } while(0)
  #define STM32_RCC_CSR_LPWRSTF_GET(x)             (((x) >> 31) & 0x1)

#endif

