/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -o cdefs cdefs_use_reg_mask=1 cdefs_use_field_setval=1 -O core.h      \
     -I core.bf
*/

#ifndef _CORE_BFGEN_DEFS_
#define _CORE_BFGEN_DEFS_

#define CORE_PWR_CONTROL_ADDR                        0x400b0000
#define CORE_PWR_CONTROL_MASK                        0xbb80003f
/** Current power mode of the device. Note that this field cannot be read in all
   power modes on actual silicon @multiple */
  #define CORE_PWR_CONTROL_POWER_MODE(v)           ((CORE_PWR_CONTROL_POWER_MODE_##v) << 0)
  #define CORE_PWR_CONTROL_POWER_MODE_SET(x, v)    do { (x) = (((x) & ~0xf) | ((CORE_PWR_CONTROL_POWER_MODE_##v) << 0)); } while(0)
  #define CORE_PWR_CONTROL_POWER_MODE_SETVAL(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define CORE_PWR_CONTROL_POWER_MODE_GET(x)       (((x) >> 0) & 0xf)
    #define CORE_PWR_CONTROL_POWER_MODE_RESET        0x00000000
    #define CORE_PWR_CONTROL_POWER_MODE_ACTIVE       0x00000001
    #define CORE_PWR_CONTROL_POWER_MODE_SLEEP        0x00000002
    #define CORE_PWR_CONTROL_POWER_MODE_DEEP_SLEEP   0x00000003
    #define CORE_PWR_CONTROL_POWER_MODE_HIBERNATE    0x00000004
/** Indicates whether a debug session is active @multiple */
  #define CORE_PWR_CONTROL_DEBUG_SESSION           0x00000010
/** Indicates whether the low power mode regulators are ready to enter DEEPSLEEP
   or HIBERNATE mode @multiple */
  #define CORE_PWR_CONTROL_LPM_READY(v)            ((CORE_PWR_CONTROL_LPM_READY_##v) << 5)
  #define CORE_PWR_CONTROL_LPM_READY_SET(x, v)     do { (x) = (((x) & ~0x20) | ((CORE_PWR_CONTROL_LPM_READY_##v) << 5)); } while(0)
  #define CORE_PWR_CONTROL_LPM_READY_SETVAL(x, v)  do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define CORE_PWR_CONTROL_LPM_READY_GET(x)        (((x) >> 5) & 0x1)
/** If DEEPSLEEP or HIBERNATE mode is requested, device will enter SLEEP mode. When low power regulators are ready, device will automatically enter the originally requested mode */
    #define CORE_PWR_CONTROL_LPM_READY_AUTO          0x00000000
/** Normal operation. DEEPSLEEP and HIBERNATE work as described */
    #define CORE_PWR_CONTROL_LPM_READY_NORMAL        0x00000001
/** Should be set by firmware if Vccd is provided externally (on Vccd pin).
   Setting this bit turns off the active regulator and will lead to system reset
   (PBOD) unless both Vddd and Vccd pins are supplied externally @multiple */
  #define CORE_PWR_CONTROL_EXT_VCCD                0x00800000
  #define CORE_PWR_CONTROL_HVMON_ENABLE            0x01000000
/** Firmware writes 1 to reload HV State in hibernate shadow copy. Hardware
   clears this bit after reload was successful. Wait at least 9 cycles after
   writing/recalling NVL before reloading the HVMON. @multiple */
  #define CORE_PWR_CONTROL_HVMON_RELOAD            0x02000000
/** Force IMO to operate at 12MHz, ignore its frequency and trim settings and
   operate independent on its external references @multiple */
  #define CORE_PWR_CONTROL_FIMO_DISABLE            0x08000000
/** Disable interpretation of hibernate field. This bit is a write-once bit until
   the next reset @multiple */
  #define CORE_PWR_CONTROL_HIBERNATE_DISABLE       0x10000000
/** Short Vcclfclk and Vccdpslp power rails in DeepSleep power mode @multiple */
  #define CORE_PWR_CONTROL_LFCLK_SHORT             0x20000000
/** Selects between HIBERNATE/DEEPSLEEP modes when Cortex-M0 enters low power
   mode @multiple */
  #define CORE_PWR_CONTROL_HIBERNATE(v)            ((CORE_PWR_CONTROL_HIBERNATE_##v) << 31)
  #define CORE_PWR_CONTROL_HIBERNATE_SET(x, v)     do { (x) = (((x) & ~0x80000000) | ((CORE_PWR_CONTROL_HIBERNATE_##v) << 31)); } while(0)
  #define CORE_PWR_CONTROL_HIBERNATE_SETVAL(x, v)  do { (x) = (((x) & ~0x80000000) | ((v) << 31)); } while(0)
  #define CORE_PWR_CONTROL_HIBERNATE_GET(x)        (((x) >> 31) & 0x1)
/** Enter DeepSleep mode when CPU asserts SLEEPDEEP signal */
    #define CORE_PWR_CONTROL_HIBERNATE_DEEP_SLEEP    0x00000000
/** Enter Hibernate mode when CPU asserts SLEEPDEEP signal */
    #define CORE_PWR_CONTROL_HIBERNATE_HIBERNATE     0x00000001

#define CORE_PWR_INTR_ADDR                           0x400b0004
#define CORE_PWR_INTR_MASK                           0x00000002
/** Indicates an Low Voltage Detect interrupt @multiple */
  #define CORE_PWR_INTR_LVD                        0x00000002

#define CORE_PWR_INTR_MASK_ADDR                      0x400b0008
#define CORE_PWR_INTR_MASK_MASK                      0x00000002
/** Propagate Low Voltage Detect interrupt @multiple */
  #define CORE_PWR_INTR_MASK_LVD                   0x00000002

#define CORE_PWR_KEY_DELAY_ADDR                      0x400b000c
#define CORE_PWR_KEY_DELAY_MASK                      0x000003ff
/** Delay (in 12MHz IMO clock cycles) to wait for references to settle on wakeup
   from hibernate/deepsleep @multiple */
  #define CORE_PWR_KEY_DELAY_WAKEUP_HOLDOFF(v)     ((v) << 0)
  #define CORE_PWR_KEY_DELAY_WAKEUP_HOLDOFF_SET(x, v) do { (x) = (((x) & ~0x3ff) | ((v) << 0)); } while(0)
  #define CORE_PWR_KEY_DELAY_WAKEUP_HOLDOFF_GET(x) (((x) >> 0) & 0x3ff)

#define CORE_PWR_BG_CONFIG_ADDR                      0x400b0014
#define CORE_PWR_BG_CONFIG_MASK                      0x000701ff
/** Enables DFT capability for Bandgap @multiple */
  #define CORE_PWR_BG_CONFIG_BG_DFT_EN             0x00000001
/** ADFT mux select for Reference System characterization. Select a voltage
   reference to output on adft_bg_ref @multiple */
  #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL(v)    ((CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_##v) << 1)
  #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_SET(x, v) do { (x) = (((x) & ~0x1e) | ((CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_##v) << 1)); } while(0)
  #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x1e) | ((v) << 1)); } while(0)
  #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_GET(x) (((x) >> 1) & 0xf)
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VGND  0x00000000
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST_0_ 0x00000001
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST_1_ 0x00000002
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST_2_ 0x00000003
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST_3_ 0x00000004
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST_4_ 0x00000005
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST_5_ 0x00000006
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST_6_ 0x00000007
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST_7_ 0x00000008
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_0_ 0x00000009
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_1_ 0x0000000a
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_2_ 0x0000000b
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VCTAT 0x0000000c
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_IREF_DFT_SEE_BG_DFT_ICORE_SEL_ 0x0000000d
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_IMO_IREF_CURRENT_ 0x0000000e
    #define CORE_PWR_BG_CONFIG_BG_DFT_VREF_SEL_INL_IMOREF_VOLTAGE_ 0x0000000f
/** ADFT mux select for Bandgap characterization. Selects which BG core signal to
   output on adft_bg_core @multiple */
  #define CORE_PWR_BG_CONFIG_BG_DFT_CORE_SEL(v)    ((CORE_PWR_BG_CONFIG_BG_DFT_CORE_SEL_##v) << 5)
  #define CORE_PWR_BG_CONFIG_BG_DFT_CORE_SEL_SET(x, v) do { (x) = (((x) & ~0x20) | ((CORE_PWR_BG_CONFIG_BG_DFT_CORE_SEL_##v) << 5)); } while(0)
  #define CORE_PWR_BG_CONFIG_BG_DFT_CORE_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define CORE_PWR_BG_CONFIG_BG_DFT_CORE_SEL_GET(x) (((x) >> 5) & 0x1)
/** BG core voltage selected by BG_DFT_VCORE_SEL (mux2out) */
    #define CORE_PWR_BG_CONFIG_BG_DFT_CORE_SEL_VCORE 0x00000000
/** BG core current selected by BG_DFT_ICORE_SEL (mux1out) */
    #define CORE_PWR_BG_CONFIG_BG_DFT_CORE_SEL_ICORE 0x00000001
/** ADFT mux select for Bandgap characterization. Selects a BG core current to
   output on mux1out @multiple */
  #define CORE_PWR_BG_CONFIG_BG_DFT_ICORE_SEL(v)   ((CORE_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_##v) << 6)
  #define CORE_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_SET(x, v) do { (x) = (((x) & ~0xc0) | ((CORE_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_##v) << 6)); } while(0)
  #define CORE_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_SETVAL(x, v) do { (x) = (((x) & ~0xc0) | ((v) << 6)); } while(0)
  #define CORE_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_GET(x) (((x) >> 6) & 0x3)
    #define CORE_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_IPTAT 0x00000000
    #define CORE_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_ICTAT 0x00000001
    #define CORE_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_INL_CROSS_OVER_DETECT 0x00000002
    #define CORE_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_IREF9P6U_DFT 0x00000003
/** ADFT mux select for Bandgap characterization. Selects a BG core voltage to
   output on mux2out @multiple */
  #define CORE_PWR_BG_CONFIG_BG_DFT_VCORE_SEL(v)   ((CORE_PWR_BG_CONFIG_BG_DFT_VCORE_SEL_##v) << 8)
  #define CORE_PWR_BG_CONFIG_BG_DFT_VCORE_SEL_SET(x, v) do { (x) = (((x) & ~0x100) | ((CORE_PWR_BG_CONFIG_BG_DFT_VCORE_SEL_##v) << 8)); } while(0)
  #define CORE_PWR_BG_CONFIG_BG_DFT_VCORE_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define CORE_PWR_BG_CONFIG_BG_DFT_VCORE_SEL_GET(x) (((x) >> 8) & 0x1)
    #define CORE_PWR_BG_CONFIG_BG_DFT_VCORE_SEL_VOUT 0x00000000
    #define CORE_PWR_BG_CONFIG_BG_DFT_VCORE_SEL_VGND 0x00000001
/** Reference voltage enable. Each bit enables a reference voltage used by a
   peripheral. vref[0] enables SRSS.VREF[0] to 1.024V. vref[1] enables
   SRSS.VREF[1] to 1.024V. vref[2] enables SRSS.VREF[2] to 1.2V @multiple */
  #define CORE_PWR_BG_CONFIG_VREF_EN(v)            ((v) << 16)
  #define CORE_PWR_BG_CONFIG_VREF_EN_SET(x, v)     do { (x) = (((x) & ~0x70000) | ((v) << 16)); } while(0)
  #define CORE_PWR_BG_CONFIG_VREF_EN_GET(x)        (((x) >> 16) & 0x7)

#define CORE_PWR_VMON_CONFIG_ADDR                    0x400b0018
#define CORE_PWR_VMON_CONFIG_MASK                    0x000003ff
/** Enable Low Voltage Detect circuit @multiple */
  #define CORE_PWR_VMON_CONFIG_LVD_EN              0x00000001
/** Threshold selection for Low Voltage Detect circuit @multiple */
  #define CORE_PWR_VMON_CONFIG_LVD_SEL(v)          ((CORE_PWR_VMON_CONFIG_LVD_SEL_##v) << 1)
  #define CORE_PWR_VMON_CONFIG_LVD_SEL_SET(x, v)   do { (x) = (((x) & ~0x1e) | ((CORE_PWR_VMON_CONFIG_LVD_SEL_##v) << 1)); } while(0)
  #define CORE_PWR_VMON_CONFIG_LVD_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x1e) | ((v) << 1)); } while(0)
  #define CORE_PWR_VMON_CONFIG_LVD_SEL_GET(x)      (((x) >> 1) & 0xf)
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_1_75_V      0x00000000
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_1_80_V      0x00000001
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_1_90_V      0x00000002
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_2_00_V      0x00000003
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_2_10_V      0x00000004
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_2_20_V      0x00000005
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_2_30_V      0x00000006
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_2_40_V      0x00000007
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_2_50_V      0x00000008
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_2_60_V      0x00000009
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_2_70_V      0x0000000a
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_2_80_V      0x0000000b
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_2_90_V      0x0000000c
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_3_00_V      0x0000000d
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_3_20_V      0x0000000e
    #define CORE_PWR_VMON_CONFIG_LVD_SEL_4_50_V      0x0000000f
/** DDFT mux select for HVPOR, PBOD, and LVD circuits @multiple */
  #define CORE_PWR_VMON_CONFIG_VMON_DDFT_SEL(v)    ((CORE_PWR_VMON_CONFIG_VMON_DDFT_SEL_##v) << 5)
  #define CORE_PWR_VMON_CONFIG_VMON_DDFT_SEL_SET(x, v) do { (x) = (((x) & ~0xe0) | ((CORE_PWR_VMON_CONFIG_VMON_DDFT_SEL_##v) << 5)); } while(0)
  #define CORE_PWR_VMON_CONFIG_VMON_DDFT_SEL_SETVAL(x, v) do { (x) = (((x) & ~0xe0) | ((v) << 5)); } while(0)
  #define CORE_PWR_VMON_CONFIG_VMON_DDFT_SEL_GET(x) (((x) >> 5) & 0x7)
    #define CORE_PWR_VMON_CONFIG_VMON_DDFT_SEL_0     0x00000000
    #define CORE_PWR_VMON_CONFIG_VMON_DDFT_SEL_PBOD_OUT 0x00000001
    #define CORE_PWR_VMON_CONFIG_VMON_DDFT_SEL_PULSE_STRECHER_OUTPUT_OF_PBOD_MONITOR 0x00000002
    #define CORE_PWR_VMON_CONFIG_VMON_DDFT_SEL_HVPBOD_OUT 0x00000003
    #define CORE_PWR_VMON_CONFIG_VMON_DDFT_SEL_PULSE_STRECHER_OUTPUT_OF_HVPBOD_MONITOR 0x00000004
    #define CORE_PWR_VMON_CONFIG_VMON_DDFT_SEL_LVI_OUT 0x00000005
    #define CORE_PWR_VMON_CONFIG_VMON_DDFT_SEL_PULSE_STRECHER_OUTPUT_OF_LVI_MONITOR 0x00000006
    #define CORE_PWR_VMON_CONFIG_VMON_DDFT_SEL_0     0x00000007
/** ADFT mux select for HVPOR, PBOD, and LVD circuits @multiple */
  #define CORE_PWR_VMON_CONFIG_VMON_ADFT_SEL(v)    ((CORE_PWR_VMON_CONFIG_VMON_ADFT_SEL_##v) << 8)
  #define CORE_PWR_VMON_CONFIG_VMON_ADFT_SEL_SET(x, v) do { (x) = (((x) & ~0x300) | ((CORE_PWR_VMON_CONFIG_VMON_ADFT_SEL_##v) << 8)); } while(0)
  #define CORE_PWR_VMON_CONFIG_VMON_ADFT_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x300) | ((v) << 8)); } while(0)
  #define CORE_PWR_VMON_CONFIG_VMON_ADFT_SEL_GET(x) (((x) >> 8) & 0x3)
    #define CORE_PWR_VMON_CONFIG_VMON_ADFT_SEL_HI_Z  0x00000000
    #define CORE_PWR_VMON_CONFIG_VMON_ADFT_SEL_COMPARATOR_INPUT_OF_PBOD_MONITOR 0x00000001
    #define CORE_PWR_VMON_CONFIG_VMON_ADFT_SEL_COMPARATOR_INPUT_OF_HVPBOD_MONITOR 0x00000002
    #define CORE_PWR_VMON_CONFIG_VMON_ADFT_SEL_COMPARATOR_INPUT_OF_LVI_MONITOR 0x00000003

#define CORE_PWR_DDFT_SELECT_ADDR                    0x400b0020
#define CORE_PWR_DDFT_SELECT_MASK                    0x000000ff
/** Signal select for ddft1 output @multiple */
  #define CORE_PWR_DDFT_SELECT_DDFT1_SEL(v)        ((CORE_PWR_DDFT_SELECT_DDFT1_SEL_##v) << 0)
  #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_SET(x, v) do { (x) = (((x) & ~0xf) | ((CORE_PWR_DDFT_SELECT_DDFT1_SEL_##v) << 0)); } while(0)
  #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_SETVAL(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_GET(x)    (((x) >> 0) & 0xf)
    #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_WAKEUP_A  0x00000000
    #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_IPOR_RESET 0x00000001
    #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_HBOD_RESET_RAW_N 0x00000002
    #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_LPCOMP_DIS 0x00000003
    #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_POWER_UP_DELAYED 0x00000004
    #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_AWAKE     0x00000005
    #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_HVMON_OUT_OF_SYNC 0x00000006
    #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_PBOD_RESET 0x00000007
    #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_HVBOD_RESET 0x00000008
    #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_LPM_READY 0x00000009
    #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_IO_DISABLE_REQ_LV 0x0000000a
    #define CORE_PWR_DDFT_SELECT_DDFT1_SEL_BOOTREF_EN 0x0000000b
/** Signal select for ddft2 output @multiple */
  #define CORE_PWR_DDFT_SELECT_DDFT2_SEL(v)        ((CORE_PWR_DDFT_SELECT_DDFT2_SEL_##v) << 4)
  #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_SET(x, v) do { (x) = (((x) & ~0xf0) | ((CORE_PWR_DDFT_SELECT_DDFT2_SEL_##v) << 4)); } while(0)
  #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_SETVAL(x, v) do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_GET(x)    (((x) >> 4) & 0xf)
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_ACT_POWER_EN_A 0x00000000
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_POWER_UP_RAW 0x00000001
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_ACT_POWER_GOOD_A 0x00000002
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_FASTREFS_VALID 0x00000003
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_VMON      0x00000004
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_BOOTREF_OUTEN 0x00000005
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_BOOTREF_REFSW 0x00000006
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_ACTIVE_INRUSH_DIS 0x00000007
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_AWAKE     0x00000008
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_HVPOR_RESET_N 0x00000009
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_LPCOMP_DIS 0x0000000a
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_WAKEUP_A  0x0000000b
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_VMON_VALID 0x0000000c
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_BLOCK_RST_AWAKE 0x0000000d
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_SLPHOLDREQ_N 0x0000000e
    #define CORE_PWR_DDFT_SELECT_DDFT2_SEL_IO_DISABLE_DELAYED 0x0000000f

#define CORE_PWR_DFT_KEY_ADDR                        0x400b0024
#define CORE_PWR_DFT_KEY_MASK                        0x001fffff
/** This field must be set to 0xe4c5 to unlock other fields in this @multiple */
  #define CORE_PWR_DFT_KEY_KEY16(v)                ((CORE_PWR_DFT_KEY_KEY16_##v) << 0)
  #define CORE_PWR_DFT_KEY_KEY16_SET(x, v)         do { (x) = (((x) & ~0xffff) | ((CORE_PWR_DFT_KEY_KEY16_##v) << 0)); } while(0)
  #define CORE_PWR_DFT_KEY_KEY16_SETVAL(x, v)      do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define CORE_PWR_DFT_KEY_KEY16_GET(x)            (((x) >> 0) & 0xffff)
    #define CORE_PWR_DFT_KEY_KEY16_KEY               0x0000e4c5
/** Forces the output of the HBOD to be blocked (ignored) while in Active or
   Sleep mode @multiple */
  #define CORE_PWR_DFT_KEY_HBOD_OFF_AWAKE          0x00010000
/** Forces all outputs of BOD detectors to be ignored, effectively disabling all
   brown-out detection @multiple */
  #define CORE_PWR_DFT_KEY_BODS_OFF                0x00020000
/** Enable DfT modes other than the above @multiple */
  #define CORE_PWR_DFT_KEY_DFT_MODE                0x00040000
/** Bypasses the IO disable logic for testing the delay-line that is part of the
   glitch-free IO reset circuitry @multiple */
  #define CORE_PWR_DFT_KEY_IO_DISABLE_BYPASS       0x00080000
/** Disables the VMON block, which includes PBOD, HVBOD, and LVD circuits. Set
   BODS_OFF=1 before to prevent an unintended reset @multiple */
  #define CORE_PWR_DFT_KEY_VMON_PD                 0x00100000

#define CORE_PWR_BOD_KEY_ADDR                        0x400b0028
#define CORE_PWR_BOD_KEY_MASK                        0x0001ffff
  #define CORE_PWR_BOD_KEY_KEY16(v)                ((CORE_PWR_BOD_KEY_KEY16_##v) << 0)
  #define CORE_PWR_BOD_KEY_KEY16_SET(x, v)         do { (x) = (((x) & ~0x1ffff) | ((CORE_PWR_BOD_KEY_KEY16_##v) << 0)); } while(0)
  #define CORE_PWR_BOD_KEY_KEY16_SETVAL(x, v)      do { (x) = (((x) & ~0x1ffff) | ((v) << 0)); } while(0)
  #define CORE_PWR_BOD_KEY_KEY16_GET(x)            (((x) >> 0) & 0x1ffff)
    #define CORE_PWR_BOD_KEY_KEY16_BROWN_OUT         0x00003a71

#define CORE_PWR_STOP_ADDR                           0x400b002c
#define CORE_PWR_STOP_MASK                           0x8003ffff
/** Firmware-specific token that can be read/written to distinguish between
   wakeup and reset. 0 on reset. @multiple */
  #define CORE_PWR_STOP_TOKEN(v)                   ((v) << 0)
  #define CORE_PWR_STOP_TOKEN_SET(x, v)            do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define CORE_PWR_STOP_TOKEN_GET(x)               (((x) >> 0) & 0xff)
/** Locking value for FREEZE and STOP @multiple */
  #define CORE_PWR_STOP_UNLOCK(v)                  ((CORE_PWR_STOP_UNLOCK_##v) << 8)
  #define CORE_PWR_STOP_UNLOCK_SET(x, v)           do { (x) = (((x) & ~0xff00) | ((CORE_PWR_STOP_UNLOCK_##v) << 8)); } while(0)
  #define CORE_PWR_STOP_UNLOCK_SETVAL(x, v)        do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define CORE_PWR_STOP_UNLOCK_GET(x)              (((x) >> 8) & 0xff)
    #define CORE_PWR_STOP_UNLOCK_KEY                 0x0000003a
/** Polarity for WAKEUP signal. WAKEUP must match this bit to wakeup the chip
   @multiple */
  #define CORE_PWR_STOP_POLARITY                   0x00010000
/** Freeze the configuration when set. Must be written twice @multiple */
  #define CORE_PWR_STOP_FREEZE                     0x00020000
/** Enter STOP mode on set. Both UNLOCK and FREEZE must have been set before
   @multiple */
  #define CORE_PWR_STOP_STOP                       0x80000000

#define CORE_CLK_SELECT_ADDR                         0x400b0100
#define CORE_CLK_SELECT_MASK                         0x003fffff
/** Source for HFCLK when HFCLK_SEL=DIRECT_SEL @multiple */
  #define CORE_CLK_SELECT_DIRECT_SEL(v)            ((CORE_CLK_SELECT_DIRECT_SEL_##v) << 0)
  #define CORE_CLK_SELECT_DIRECT_SEL_SET(x, v)     do { (x) = (((x) & ~0x7) | ((CORE_CLK_SELECT_DIRECT_SEL_##v) << 0)); } while(0)
  #define CORE_CLK_SELECT_DIRECT_SEL_SETVAL(x, v)  do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define CORE_CLK_SELECT_DIRECT_SEL_GET(x)        (((x) >> 0) & 0x7)
/** Internal R/C Oscillator */
    #define CORE_CLK_SELECT_DIRECT_SEL_IMO           0x00000000
/** External Clock Pin */
    #define CORE_CLK_SELECT_DIRECT_SEL_EXTCLK        0x00000001
/** Internal Crystal Oscillator */
    #define CORE_CLK_SELECT_DIRECT_SEL_ECO           0x00000002
  #define CORE_CLK_SELECT_DBL_SEL(v)               ((v) << 3)
  #define CORE_CLK_SELECT_DBL_SEL_SET(x, v)        do { (x) = (((x) & ~0x38) | ((v) << 3)); } while(0)
  #define CORE_CLK_SELECT_DBL_SEL_GET(x)           (((x) >> 3) & 0x7)
  #define CORE_CLK_SELECT_PLL_SEL(v)               ((v) << 6)
  #define CORE_CLK_SELECT_PLL_SEL_SET(x, v)        do { (x) = (((x) & ~0x1c0) | ((v) << 6)); } while(0)
  #define CORE_CLK_SELECT_PLL_SEL_GET(x)           (((x) >> 6) & 0x7)
  #define CORE_CLK_SELECT_DPLLIN_SEL(v)            ((v) << 9)
  #define CORE_CLK_SELECT_DPLLIN_SEL_SET(x, v)     do { (x) = (((x) & ~0xe00) | ((v) << 9)); } while(0)
  #define CORE_CLK_SELECT_DPLLIN_SEL_GET(x)        (((x) >> 9) & 0x7)
  #define CORE_CLK_SELECT_DPLLREF_SEL(v)           ((v) << 12)
  #define CORE_CLK_SELECT_DPLLREF_SEL_SET(x, v)    do { (x) = (((x) & ~0x3000) | ((v) << 12)); } while(0)
  #define CORE_CLK_SELECT_DPLLREF_SEL_GET(x)       (((x) >> 12) & 0x3)
/** Prohibits writing to WDT_* registers and CLK_ILO register when not 0.
   Requires at least two different writes to unlock @multiple */
  #define CORE_CLK_SELECT_WDT_LOCK(v)              ((CORE_CLK_SELECT_WDT_LOCK_##v) << 14)
  #define CORE_CLK_SELECT_WDT_LOCK_SET(x, v)       do { (x) = (((x) & ~0xc000) | ((CORE_CLK_SELECT_WDT_LOCK_##v) << 14)); } while(0)
  #define CORE_CLK_SELECT_WDT_LOCK_SETVAL(x, v)    do { (x) = (((x) & ~0xc000) | ((v) << 14)); } while(0)
  #define CORE_CLK_SELECT_WDT_LOCK_GET(x)          (((x) >> 14) & 0x3)
/** No effect */
    #define CORE_CLK_SELECT_WDT_LOCK_NO_CHG          0x00000000
/** Clears bit 0 */
    #define CORE_CLK_SELECT_WDT_LOCK_CLR0            0x00000001
/** Clears bit 1 */
    #define CORE_CLK_SELECT_WDT_LOCK_CLR1            0x00000002
/** Sets both bits 0 and 1 */
    #define CORE_CLK_SELECT_WDT_LOCK_SET01           0x00000003
  #define CORE_CLK_SELECT_HFCLK_SEL(v)             ((CORE_CLK_SELECT_HFCLK_SEL_##v) << 16)
  #define CORE_CLK_SELECT_HFCLK_SEL_SET(x, v)      do { (x) = (((x) & ~0x30000) | ((CORE_CLK_SELECT_HFCLK_SEL_##v) << 16)); } while(0)
  #define CORE_CLK_SELECT_HFCLK_SEL_SETVAL(x, v)   do { (x) = (((x) & ~0x30000) | ((v) << 16)); } while(0)
  #define CORE_CLK_SELECT_HFCLK_SEL_GET(x)         (((x) >> 16) & 0x3)
/** Selected by direct_sel */
    #define CORE_CLK_SELECT_HFCLK_SEL_DIRECT_SEL     0x00000000
/** Output of doubler */
    #define CORE_CLK_SELECT_HFCLK_SEL_DBL            0x00000001
/** Output of PLL */
    #define CORE_CLK_SELECT_HFCLK_SEL_PLL            0x00000002
/** CPUSSv1 only. Must be set when HFCLK > 24 MHz @multiple */
  #define CORE_CLK_SELECT_HALF_EN                  0x00040000
/** SYSCLK = HFCLK / 2^(sysclk_div + 1) @multiple */
  #define CORE_CLK_SELECT_SYSCLK_DIV(v)            ((v) << 19)
  #define CORE_CLK_SELECT_SYSCLK_DIV_SET(x, v)     do { (x) = (((x) & ~0x380000) | ((v) << 19)); } while(0)
  #define CORE_CLK_SELECT_SYSCLK_DIV_GET(x)        (((x) >> 19) & 0x7)

#define CORE_CLK_ILO_CONFIG_ADDR                     0x400b0104
#define CORE_CLK_ILO_CONFIG_MASK                     0x80000007
  #define CORE_CLK_ILO_CONFIG_PD_MODE(v)           ((CORE_CLK_ILO_CONFIG_PD_MODE_##v) << 0)
  #define CORE_CLK_ILO_CONFIG_PD_MODE_SET(x, v)    do { (x) = (((x) & ~0x1) | ((CORE_CLK_ILO_CONFIG_PD_MODE_##v) << 0)); } while(0)
  #define CORE_CLK_ILO_CONFIG_PD_MODE_SETVAL(x, v) do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define CORE_CLK_ILO_CONFIG_PD_MODE_GET(x)       (((x) >> 0) & 0x1)
    #define CORE_CLK_ILO_CONFIG_PD_MODE_SLEEP        0x00000000
    #define CORE_CLK_ILO_CONFIG_PD_MODE_COMA         0x00000001
/** For faster startup from coma power down @multiple */
  #define CORE_CLK_ILO_CONFIG_TURBO                0x00000002
  #define CORE_CLK_ILO_CONFIG_SATBIAS(v)           ((CORE_CLK_ILO_CONFIG_SATBIAS_##v) << 2)
  #define CORE_CLK_ILO_CONFIG_SATBIAS_SET(x, v)    do { (x) = (((x) & ~0x4) | ((CORE_CLK_ILO_CONFIG_SATBIAS_##v) << 2)); } while(0)
  #define CORE_CLK_ILO_CONFIG_SATBIAS_SETVAL(x, v) do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define CORE_CLK_ILO_CONFIG_SATBIAS_GET(x)       (((x) >> 2) & 0x1)
/** Enable saturated PFET bias */
    #define CORE_CLK_ILO_CONFIG_SATBIAS_SATURATED    0x00000000
/** Enable subthreshold PFET bias */
    #define CORE_CLK_ILO_CONFIG_SATBIAS_SUBTHRESHOLD 0x00000001
/** Master enable for ILO oscillator @multiple */
  #define CORE_CLK_ILO_CONFIG_ENABLE               0x80000000

#define CORE_CLK_IMO_CONFIG_ADDR                     0x400b0108
#define CORE_CLK_IMO_CONFIG_MASK                     0xffc00000
/** Selects operating source for SPCIF Timer/Flash Pump clock @multiple */
  #define CORE_CLK_IMO_CONFIG_FLASHPUMP_SEL(v)     ((CORE_CLK_IMO_CONFIG_FLASHPUMP_SEL_##v) << 22)
  #define CORE_CLK_IMO_CONFIG_FLASHPUMP_SEL_SET(x, v) do { (x) = (((x) & ~0x400000) | ((CORE_CLK_IMO_CONFIG_FLASHPUMP_SEL_##v) << 22)); } while(0)
  #define CORE_CLK_IMO_CONFIG_FLASHPUMP_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x400000) | ((v) << 22)); } while(0)
  #define CORE_CLK_IMO_CONFIG_FLASHPUMP_SEL_GET(x) (((x) >> 22) & 0x1)
/** No clock, connect to gnd */
    #define CORE_CLK_IMO_CONFIG_FLASHPUMP_SEL_GND    0x00000000
/** Use 36MHz oscillator */
    #define CORE_CLK_IMO_CONFIG_FLASHPUMP_SEL_CLK36  0x00000001
/** Forces the FIMO's fast bias circuits to remain powered @multiple */
  #define CORE_CLK_IMO_CONFIG_EN_FASTBIAS          0x00800000
/** Forces the IMO into FIMO mode @multiple */
  #define CORE_CLK_IMO_CONFIG_TEST_FASTBIAS        0x01000000
/** Selects operating source for Pump clock @multiple */
  #define CORE_CLK_IMO_CONFIG_PUMP_SEL(v)          ((CORE_CLK_IMO_CONFIG_PUMP_SEL_##v) << 25)
  #define CORE_CLK_IMO_CONFIG_PUMP_SEL_SET(x, v)   do { (x) = (((x) & ~0xe000000) | ((CORE_CLK_IMO_CONFIG_PUMP_SEL_##v) << 25)); } while(0)
  #define CORE_CLK_IMO_CONFIG_PUMP_SEL_SETVAL(x, v) do { (x) = (((x) & ~0xe000000) | ((v) << 25)); } while(0)
  #define CORE_CLK_IMO_CONFIG_PUMP_SEL_GET(x)      (((x) >> 25) & 0x7)
/** No clock, connect to gnd */
    #define CORE_CLK_IMO_CONFIG_PUMP_SEL_GND         0x00000000
/** Use main IMO output */
    #define CORE_CLK_IMO_CONFIG_PUMP_SEL_IMO         0x00000001
/** Use doubler output */
    #define CORE_CLK_IMO_CONFIG_PUMP_SEL_DBL         0x00000002
/** Use 36MHz oscillator */
    #define CORE_CLK_IMO_CONFIG_PUMP_SEL_CLK36       0x00000003
/** Use divided clock FF1 */
    #define CORE_CLK_IMO_CONFIG_PUMP_SEL_FF1         0x00000004
/** Forces IMO into USB mode @multiple */
  #define CORE_CLK_IMO_CONFIG_TEST_USB_MODE        0x10000000
/** Enables 36MHz secondary oscillator that can be used for Pump or Flash Pump
   @multiple */
  #define CORE_CLK_IMO_CONFIG_EN_CLK36             0x20000000
/** Enables main oscillator doubler circuit that can be used for TSS Charge Pumps
   @multiple */
  #define CORE_CLK_IMO_CONFIG_EN_CLK2X             0x40000000
/** Master enable for IMO oscillator @multiple */
  #define CORE_CLK_IMO_CONFIG_ENABLE               0x80000000

#define CORE_CLK_IMO_SPREAD_ADDR                     0x400b010c
#define CORE_CLK_IMO_SPREAD_MASK                     0xf0001f1f
/** Current offset value for spread spectrum modulation @multiple */
  #define CORE_CLK_IMO_SPREAD_SS_VALUE(v)          ((v) << 0)
  #define CORE_CLK_IMO_SPREAD_SS_VALUE_SET(x, v)   do { (x) = (((x) & ~0x1f) | ((v) << 0)); } while(0)
  #define CORE_CLK_IMO_SPREAD_SS_VALUE_GET(x)      (((x) >> 0) & 0x1f)
/** Maximum counter value for spread spectrum @multiple */
  #define CORE_CLK_IMO_SPREAD_SS_MAX(v)            ((v) << 8)
  #define CORE_CLK_IMO_SPREAD_SS_MAX_SET(x, v)     do { (x) = (((x) & ~0x1f00) | ((v) << 8)); } while(0)
  #define CORE_CLK_IMO_SPREAD_SS_MAX_GET(x)        (((x) >> 8) & 0x1f)
/** Spread spectrum range @multiple */
  #define CORE_CLK_IMO_SPREAD_SS_RANGE(v)          ((CORE_CLK_IMO_SPREAD_SS_RANGE_##v) << 28)
  #define CORE_CLK_IMO_SPREAD_SS_RANGE_SET(x, v)   do { (x) = (((x) & ~0x30000000) | ((CORE_CLK_IMO_SPREAD_SS_RANGE_##v) << 28)); } while(0)
  #define CORE_CLK_IMO_SPREAD_SS_RANGE_SETVAL(x, v) do { (x) = (((x) & ~0x30000000) | ((v) << 28)); } while(0)
  #define CORE_CLK_IMO_SPREAD_SS_RANGE_GET(x)      (((x) >> 28) & 0x3)
    #define CORE_CLK_IMO_SPREAD_SS_RANGE_0_1_        0x00000000
    #define CORE_CLK_IMO_SPREAD_SS_RANGE_0_2_        0x00000001
    #define CORE_CLK_IMO_SPREAD_SS_RANGE_0_4_        0x00000002
/** Spread Spectrum Mode @multiple */
  #define CORE_CLK_IMO_SPREAD_SS_MODE(v)           ((CORE_CLK_IMO_SPREAD_SS_MODE_##v) << 30)
  #define CORE_CLK_IMO_SPREAD_SS_MODE_SET(x, v)    do { (x) = (((x) & ~0xc0000000) | ((CORE_CLK_IMO_SPREAD_SS_MODE_##v) << 30)); } while(0)
  #define CORE_CLK_IMO_SPREAD_SS_MODE_SETVAL(x, v) do { (x) = (((x) & ~0xc0000000) | ((v) << 30)); } while(0)
  #define CORE_CLK_IMO_SPREAD_SS_MODE_GET(x)       (((x) >> 30) & 0x3)
/** Off, do not change SS_VALUE */
    #define CORE_CLK_IMO_SPREAD_SS_MODE_OFF          0x00000000
/** Modulate using triangle wave (see SS_MAX) */
    #define CORE_CLK_IMO_SPREAD_SS_MODE_TRIANGLE     0x00000001
/** Modulate using pseudo random sequence (using LFSR) */
    #define CORE_CLK_IMO_SPREAD_SS_MODE_LFSR         0x00000002

#define CORE_CLK_DFT_SELECT_ADDR                     0x400b0110
#define CORE_CLK_DFT_SELECT_MASK                     0x00003f3f
/** Select signal for DFT output #1 @multiple */
  #define CORE_CLK_DFT_SELECT_DFT_SEL1(v)          ((CORE_CLK_DFT_SELECT_DFT_SEL1_##v) << 0)
  #define CORE_CLK_DFT_SELECT_DFT_SEL1_SET(x, v)   do { (x) = (((x) & ~0xf) | ((CORE_CLK_DFT_SELECT_DFT_SEL1_##v) << 0)); } while(0)
  #define CORE_CLK_DFT_SELECT_DFT_SEL1_SETVAL(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define CORE_CLK_DFT_SELECT_DFT_SEL1_GET(x)      (((x) >> 0) & 0xf)
/** Disabled - output is not connected */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_NC          0x00000000
/** ILO output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_ILO         0x00000001
/** WCO output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_WCO         0x00000002
/** IMO primary output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_IMO         0x00000003
/** ECO output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_ECO         0x00000004
/** PLL output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_PLL         0x00000005
/** DPLL output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_DPLL_OUT    0x00000006
/** DPLL reference input */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_DPLL_REF    0x00000007
/** DBL output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_DBL         0x00000008
/** IMO 2x Clock Output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_IMO2X       0x00000009
/** IMO 36MHz Clock Output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_IMO36       0x0000000a
/** HFCLK */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_HFCLK       0x0000000b
/** LFCLK */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_LFCLK       0x0000000c
/** SYSCLK */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_SYSCLK      0x0000000d
/** EXTCLK */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_EXTCLK      0x0000000e
/** 0 - removed */
    #define CORE_CLK_DFT_SELECT_DFT_SEL1_HALFSYSCLK  0x0000000f
/** DFT Output Divide Down for DFT output #1 @multiple */
  #define CORE_CLK_DFT_SELECT_DFT_DIV1(v)          ((CORE_CLK_DFT_SELECT_DFT_DIV1_##v) << 4)
  #define CORE_CLK_DFT_SELECT_DFT_DIV1_SET(x, v)   do { (x) = (((x) & ~0x30) | ((CORE_CLK_DFT_SELECT_DFT_DIV1_##v) << 4)); } while(0)
  #define CORE_CLK_DFT_SELECT_DFT_DIV1_SETVAL(x, v) do { (x) = (((x) & ~0x30) | ((v) << 4)); } while(0)
  #define CORE_CLK_DFT_SELECT_DFT_DIV1_GET(x)      (((x) >> 4) & 0x3)
/** Direct Output */
    #define CORE_CLK_DFT_SELECT_DFT_DIV1_NO_DIV      0x00000000
/** Divide by 2 */
    #define CORE_CLK_DFT_SELECT_DFT_DIV1_DIV_BY_2    0x00000001
/** Divide by 4 */
    #define CORE_CLK_DFT_SELECT_DFT_DIV1_DIV_BY_4    0x00000002
/** Divide by 8 */
    #define CORE_CLK_DFT_SELECT_DFT_DIV1_DIV_BY_8    0x00000003
/** Select signal for DFT output #2 @multiple */
  #define CORE_CLK_DFT_SELECT_DFT_SEL2(v)          ((CORE_CLK_DFT_SELECT_DFT_SEL2_##v) << 8)
  #define CORE_CLK_DFT_SELECT_DFT_SEL2_SET(x, v)   do { (x) = (((x) & ~0xf00) | ((CORE_CLK_DFT_SELECT_DFT_SEL2_##v) << 8)); } while(0)
  #define CORE_CLK_DFT_SELECT_DFT_SEL2_SETVAL(x, v) do { (x) = (((x) & ~0xf00) | ((v) << 8)); } while(0)
  #define CORE_CLK_DFT_SELECT_DFT_SEL2_GET(x)      (((x) >> 8) & 0xf)
/** Disabled - output is not connected */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_NC          0x00000000
/** ILO output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_ILO         0x00000001
/** WCO output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_WCO         0x00000002
/** IMO primary output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_IMO         0x00000003
/** ECO output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_ECO         0x00000004
/** PLL output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_PLL         0x00000005
/** DPLL output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_DPLL_OUT    0x00000006
/** DPLL reference input */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_DPLL_REF    0x00000007
/** DBL output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_DBL         0x00000008
/** IMO 2x Clock Output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_IMO2X       0x00000009
/** IMO 36MHz Clock Output */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_IMO36       0x0000000a
/** HFCLK */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_HFCLK       0x0000000b
/** LFCLK */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_LFCLK       0x0000000c
/** SYSCLK */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_SYSCLK      0x0000000d
/** EXTCLK */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_EXTCLK      0x0000000e
/** 0 - removed */
    #define CORE_CLK_DFT_SELECT_DFT_SEL2_HALFSYSCLK  0x0000000f
/** DFT Output Divide Down for DFT output #2 @multiple */
  #define CORE_CLK_DFT_SELECT_DFT_DIV2(v)          ((CORE_CLK_DFT_SELECT_DFT_DIV2_##v) << 12)
  #define CORE_CLK_DFT_SELECT_DFT_DIV2_SET(x, v)   do { (x) = (((x) & ~0x3000) | ((CORE_CLK_DFT_SELECT_DFT_DIV2_##v) << 12)); } while(0)
  #define CORE_CLK_DFT_SELECT_DFT_DIV2_SETVAL(x, v) do { (x) = (((x) & ~0x3000) | ((v) << 12)); } while(0)
  #define CORE_CLK_DFT_SELECT_DFT_DIV2_GET(x)      (((x) >> 12) & 0x3)
/** Direct Output */
    #define CORE_CLK_DFT_SELECT_DFT_DIV2_NO_DIV      0x00000000
/** Divide by 2 */
    #define CORE_CLK_DFT_SELECT_DFT_DIV2_DIV_BY_2    0x00000001
/** Divide by 4 */
    #define CORE_CLK_DFT_SELECT_DFT_DIV2_DIV_BY_4    0x00000002
/** Divide by 8 */
    #define CORE_CLK_DFT_SELECT_DFT_DIV2_DIV_BY_8    0x00000003

#define CORE_WDT_CTRLOW_ADDR                         0x400b0200
#define CORE_WDT_CTRLOW_MASK                         0xffffffff
/** Current value of WDT Counter 0 @multiple */
  #define CORE_WDT_CTRLOW_WDT_CTR0(v)              ((v) << 0)
  #define CORE_WDT_CTRLOW_WDT_CTR0_SET(x, v)       do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define CORE_WDT_CTRLOW_WDT_CTR0_GET(x)          (((x) >> 0) & 0xffff)
/** Current value of WDT Counter 1 @multiple */
  #define CORE_WDT_CTRLOW_WDT_CTR1(v)              ((v) << 16)
  #define CORE_WDT_CTRLOW_WDT_CTR1_SET(x, v)       do { (x) = (((x) & ~0xffff0000) | ((v) << 16)); } while(0)
  #define CORE_WDT_CTRLOW_WDT_CTR1_GET(x)          (((x) >> 16) & 0xffff)

#define CORE_WDT_CTRHIGH_ADDR                        0x400b0204
#define CORE_WDT_CTRHIGH_MASK                        0xffffffff
/** Current value of WDT Counter 2 @multiple */
  #define CORE_WDT_CTRHIGH_WDT_CTR2(v)             ((v) << 0)
  #define CORE_WDT_CTRHIGH_WDT_CTR2_SET(x, v)      do { (x) = (((x) & ~0xffffffff) | ((v) << 0)); } while(0)
  #define CORE_WDT_CTRHIGH_WDT_CTR2_GET(x)         (((x) >> 0) & 0xffffffff)

#define CORE_WDT_MATCH_ADDR                          0x400b0208
#define CORE_WDT_MATCH_MASK                          0xffffffff
/** Match value of WDT Counter 0 @multiple */
  #define CORE_WDT_MATCH_WDT_MATCH0(v)             ((v) << 0)
  #define CORE_WDT_MATCH_WDT_MATCH0_SET(x, v)      do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define CORE_WDT_MATCH_WDT_MATCH0_GET(x)         (((x) >> 0) & 0xffff)
/** Match value of WDT Counter 1 @multiple */
  #define CORE_WDT_MATCH_WDT_MATCH1(v)             ((v) << 16)
  #define CORE_WDT_MATCH_WDT_MATCH1_SET(x, v)      do { (x) = (((x) & ~0xffff0000) | ((v) << 16)); } while(0)
  #define CORE_WDT_MATCH_WDT_MATCH1_GET(x)         (((x) >> 16) & 0xffff)

#define CORE_WDT_CONFIG_ADDR                         0x400b020c
#define CORE_WDT_CONFIG_MASK                         0xdf010f0f
/** Watchdog Counter Action on Match (WDT_CTR0=WDT_MATCH0) @multiple */
  #define CORE_WDT_CONFIG_WDT_MODE0(v)             ((CORE_WDT_CONFIG_WDT_MODE0_##v) << 0)
  #define CORE_WDT_CONFIG_WDT_MODE0_SET(x, v)      do { (x) = (((x) & ~0x3) | ((CORE_WDT_CONFIG_WDT_MODE0_##v) << 0)); } while(0)
  #define CORE_WDT_CONFIG_WDT_MODE0_SETVAL(x, v)   do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define CORE_WDT_CONFIG_WDT_MODE0_GET(x)         (((x) >> 0) & 0x3)
/** Do nothing */
    #define CORE_WDT_CONFIG_WDT_MODE0_NOTHING        0x00000000
/** Assert WDT_INTx */
    #define CORE_WDT_CONFIG_WDT_MODE0_INT            0x00000001
/** Assert WDT Reset */
    #define CORE_WDT_CONFIG_WDT_MODE0_RESET          0x00000002
/** Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt */
    #define CORE_WDT_CONFIG_WDT_MODE0_INT_THEN_RESET 0x00000003
/** Clear Watchdog Counter when WDT_CTR0=WDT_MATCH0 @multiple */
  #define CORE_WDT_CONFIG_WDT_CLEAR0               0x00000004
/** Cascade Watchdog Counters 0 and 1 @multiple */
  #define CORE_WDT_CONFIG_WDT_CASCADE0_1           0x00000008
/** Watchdog Counter Action on Match (WDT_CTR1=WDT_MATCH1) @multiple */
  #define CORE_WDT_CONFIG_WDT_MODE1(v)             ((CORE_WDT_CONFIG_WDT_MODE1_##v) << 8)
  #define CORE_WDT_CONFIG_WDT_MODE1_SET(x, v)      do { (x) = (((x) & ~0x300) | ((CORE_WDT_CONFIG_WDT_MODE1_##v) << 8)); } while(0)
  #define CORE_WDT_CONFIG_WDT_MODE1_SETVAL(x, v)   do { (x) = (((x) & ~0x300) | ((v) << 8)); } while(0)
  #define CORE_WDT_CONFIG_WDT_MODE1_GET(x)         (((x) >> 8) & 0x3)
/** Do nothing */
    #define CORE_WDT_CONFIG_WDT_MODE1_NOTHING        0x00000000
/** Assert WDT_INTx */
    #define CORE_WDT_CONFIG_WDT_MODE1_INT            0x00000001
/** Assert WDT Reset */
    #define CORE_WDT_CONFIG_WDT_MODE1_RESET          0x00000002
/** Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt */
    #define CORE_WDT_CONFIG_WDT_MODE1_INT_THEN_RESET 0x00000003
/** Clear Watchdog Counter when WDT_CTR1=WDT_MATCH1 @multiple */
  #define CORE_WDT_CONFIG_WDT_CLEAR1               0x00000400
/** Cascade Watchdog Counters 1 and 2. Counter 2 increments the cycle after
   WDT_CTR1=WDT_MATCH1 @multiple */
  #define CORE_WDT_CONFIG_WDT_CASCADE1_2           0x00000800
/** Watchdog Counter 2 Mode @multiple */
  #define CORE_WDT_CONFIG_WDT_MODE2(v)             ((CORE_WDT_CONFIG_WDT_MODE2_##v) << 16)
  #define CORE_WDT_CONFIG_WDT_MODE2_SET(x, v)      do { (x) = (((x) & ~0x10000) | ((CORE_WDT_CONFIG_WDT_MODE2_##v) << 16)); } while(0)
  #define CORE_WDT_CONFIG_WDT_MODE2_SETVAL(x, v)   do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define CORE_WDT_CONFIG_WDT_MODE2_GET(x)         (((x) >> 16) & 0x1)
/** Free running counter with no interrupt requests */
    #define CORE_WDT_CONFIG_WDT_MODE2_NOTHING        0x00000000
/** Free running counter with interrupt request when a specified bit in CTR2 toggles (see WDT_BITS2) */
    #define CORE_WDT_CONFIG_WDT_MODE2_INT            0x00000001
/** Bit to observe for WDT_INT2, assert WDT_INT2 when bit N toggles @multiple */
  #define CORE_WDT_CONFIG_WDT_BITS2(v)             ((v) << 24)
  #define CORE_WDT_CONFIG_WDT_BITS2_SET(x, v)      do { (x) = (((x) & ~0x1f000000) | ((v) << 24)); } while(0)
  #define CORE_WDT_CONFIG_WDT_BITS2_GET(x)         (((x) >> 24) & 0x1f)
/** Select source for LFCLK: @multiple */
  #define CORE_WDT_CONFIG_LFCLK_SEL(v)             ((CORE_WDT_CONFIG_LFCLK_SEL_##v) << 30)
  #define CORE_WDT_CONFIG_LFCLK_SEL_SET(x, v)      do { (x) = (((x) & ~0xc0000000) | ((CORE_WDT_CONFIG_LFCLK_SEL_##v) << 30)); } while(0)
  #define CORE_WDT_CONFIG_LFCLK_SEL_SETVAL(x, v)   do { (x) = (((x) & ~0xc0000000) | ((v) << 30)); } while(0)
  #define CORE_WDT_CONFIG_LFCLK_SEL_GET(x)         (((x) >> 30) & 0x3)
/** Internal R/C Oscillator */
    #define CORE_WDT_CONFIG_LFCLK_SEL_ILO            0x00000000
/** Internal Crystal Oscillator */
    #define CORE_WDT_CONFIG_LFCLK_SEL_WCO            0x00000001

#define CORE_WDT_CONTROL_ADDR                        0x400b0210
#define CORE_WDT_CONTROL_MASK                        0x000f0f0f
/** Enable Counter @multiple */
  #define CORE_WDT_CONTROL_WDT_ENABLE_COUNT        3
  #define CORE_WDT_CONTROL_WDT_ENABLE(fidx)        (0x00000001 << ((fidx) * 8))
/** Indicates actual state of counter @multiple */
  #define CORE_WDT_CONTROL_WDT_ENABLED_COUNT       3
  #define CORE_WDT_CONTROL_WDT_ENABLED(fidx)       (0x00000002 << ((fidx) * 8))
/** WDT Interrupt Request @multiple */
  #define CORE_WDT_CONTROL_WDT_INT_COUNT           3
  #define CORE_WDT_CONTROL_WDT_INT(fidx)           (0x00000004 << ((fidx) * 8))
/** Reset counter back to 0 @multiple */
  #define CORE_WDT_CONTROL_WDT_RESET_COUNT         3
  #define CORE_WDT_CONTROL_WDT_RESET(fidx)         (0x00000008 << ((fidx) * 8))

#define CORE_RES_CAUSE_ADDR                          0x400b0300
#define CORE_RES_CAUSE_MASK                          0x00000019
/** A WatchDog Timer reset has occurred since last power cycle @multiple */
  #define CORE_RES_CAUSE_RESET_WDT                 0x00000001
/** A protection violation occurred that requires a RESET @multiple */
  #define CORE_RES_CAUSE_RESET_PROT_FAULT          0x00000008
/** CPU requested a system reset through it's SYSRESETREQ @multiple */
  #define CORE_RES_CAUSE_RESET_SOFT                0x00000010

#define CORE_PWR_BG_TRIM3_ADDR                       0x400bff18
#define CORE_PWR_BG_TRIM3_MASK                       0x0000007f
/** IMO Irefgen nonlinear current trim for curvature correction @multiple */
  #define CORE_PWR_BG_TRIM3_INL_TRIM_IMO(v)        ((v) << 0)
  #define CORE_PWR_BG_TRIM3_INL_TRIM_IMO_SET(x, v) do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define CORE_PWR_BG_TRIM3_INL_TRIM_IMO_GET(x)    (((x) >> 0) & 0x7)
/** IMO Irefgen INL cross-over point control for centering curve at 30C @multiple
   */
  #define CORE_PWR_BG_TRIM3_INL_CROSS_IMO(v)       ((v) << 3)
  #define CORE_PWR_BG_TRIM3_INL_CROSS_IMO_SET(x, v) do { (x) = (((x) & ~0x78) | ((v) << 3)); } while(0)
  #define CORE_PWR_BG_TRIM3_INL_CROSS_IMO_GET(x)   (((x) >> 3) & 0xf)

#define CORE_PWR_BG_TRIM4_ADDR                       0x400bff1c
#define CORE_PWR_BG_TRIM4_MASK                       0x0000003f
/** IMO-irefgen output current magnitude trim @multiple */
  #define CORE_PWR_BG_TRIM4_ABS_TRIM_IMO(v)        ((v) << 0)
  #define CORE_PWR_BG_TRIM4_ABS_TRIM_IMO_SET(x, v) do { (x) = (((x) & ~0x3f) | ((v) << 0)); } while(0)
  #define CORE_PWR_BG_TRIM4_ABS_TRIM_IMO_GET(x)    (((x) >> 0) & 0x3f)

#define CORE_PWR_BG_TRIM5_ADDR                       0x400bff20
#define CORE_PWR_BG_TRIM5_MASK                       0x0000003f
/** IMO-irefgen output current temperature coefficient trim @multiple */
  #define CORE_PWR_BG_TRIM5_TMPCO_TRIM_IMO(v)      ((v) << 0)
  #define CORE_PWR_BG_TRIM5_TMPCO_TRIM_IMO_SET(x, v) do { (x) = (((x) & ~0x3f) | ((v) << 0)); } while(0)
  #define CORE_PWR_BG_TRIM5_TMPCO_TRIM_IMO_GET(x)  (((x) >> 0) & 0x3f)

#define CORE_CLK_ILO_TRIM_ADDR                       0x400bff24
#define CORE_CLK_ILO_TRIM_MASK                       0x000000ff
/** Trim bits to control frequency @multiple */
  #define CORE_CLK_ILO_TRIM_TRIM(v)                ((v) << 0)
  #define CORE_CLK_ILO_TRIM_TRIM_SET(x, v)         do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define CORE_CLK_ILO_TRIM_TRIM_GET(x)            (((x) >> 0) & 0xf)
/** Adjusts the ILO bias @multiple */
  #define CORE_CLK_ILO_TRIM_COARSE_TRIM(v)         ((v) << 4)
  #define CORE_CLK_ILO_TRIM_COARSE_TRIM_SET(x, v)  do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define CORE_CLK_ILO_TRIM_COARSE_TRIM_GET(x)     (((x) >> 4) & 0xf)

#define CORE_CLK_IMO_TRIM1_ADDR                      0x400bff28
#define CORE_CLK_IMO_TRIM1_MASK                      0x000000ff
/** Frequency trim bits @multiple */
  #define CORE_CLK_IMO_TRIM1_OFFSET(v)             ((v) << 0)
  #define CORE_CLK_IMO_TRIM1_OFFSET_SET(x, v)      do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define CORE_CLK_IMO_TRIM1_OFFSET_GET(x)         (((x) >> 0) & 0xff)

#define CORE_CLK_IMO_TRIM2_ADDR                      0x400bff2c
#define CORE_CLK_IMO_TRIM2_MASK                      0x0000003f
/** Frequency to be selected [3-12] => [3MHz-12MHz], [14-25] => [13MHz-24MHz],
   [27-35] => [25MHz-33MHz], [37-43] => [34MHz-40MHz], [46-53] => [41MHz-48MHz]
   @multiple */
  #define CORE_CLK_IMO_TRIM2_FREQ(v)               ((v) << 0)
  #define CORE_CLK_IMO_TRIM2_FREQ_SET(x, v)        do { (x) = (((x) & ~0x3f) | ((v) << 0)); } while(0)
  #define CORE_CLK_IMO_TRIM2_FREQ_GET(x)           (((x) >> 0) & 0x3f)

#define CORE_CLK_IMO_TRIM4_ADDR                      0x400bff34
#define CORE_CLK_IMO_TRIM4_MASK                      0x000000ff
/** Gain for IMO @multiple */
  #define CORE_CLK_IMO_TRIM4_GAIN(v)               ((v) << 0)
  #define CORE_CLK_IMO_TRIM4_GAIN_SET(x, v)        do { (x) = (((x) & ~0x1f) | ((v) << 0)); } while(0)
  #define CORE_CLK_IMO_TRIM4_GAIN_GET(x)           (((x) >> 0) & 0x1f)
/** Full-speed USB offset @multiple */
  #define CORE_CLK_IMO_TRIM4_FSOFFSET(v)           ((v) << 5)
  #define CORE_CLK_IMO_TRIM4_FSOFFSET_SET(x, v)    do { (x) = (((x) & ~0xe0) | ((v) << 5)); } while(0)
  #define CORE_CLK_IMO_TRIM4_FSOFFSET_GET(x)       (((x) >> 5) & 0x7)

#define CORE_PWR_RSVD_TRIM_ADDR                      0x400bff38
#define CORE_PWR_RSVD_TRIM_MASK                      0x0000000f
/** Reserved, unused @multiple */
  #define CORE_PWR_RSVD_TRIM_RSVD_TRIM(v)          ((v) << 0)
  #define CORE_PWR_RSVD_TRIM_RSVD_TRIM_SET(x, v)   do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define CORE_PWR_RSVD_TRIM_RSVD_TRIM_GET(x)      (((x) >> 0) & 0xf)

#endif

