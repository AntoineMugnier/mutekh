/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -o cdefs cdefs_use_reg_mask=1 cdefs_use_field_setval=1 -O scb.h       \
     -I scb.bf
*/

#ifndef _SCB_BFGEN_DEFS_
#define _SCB_BFGEN_DEFS_

#define SCB_CTRL_ADDR                                0x00000000
#define SCB_CTRL_MASK                                0x83030f0f
/** Oversampling lasts (AVS + 1) SCB clock. @multiple */
  #define SCB_CTRL_OVS(v)                          ((v) << 0)
  #define SCB_CTRL_OVS_SET(x, v)                   do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SCB_CTRL_OVS_GET(x)                      (((x) >> 0) & 0xf)
  #define SCB_CTRL_EC_AM_MODE(v)                   ((SCB_CTRL_EC_AM_MODE_##v) << 8)
  #define SCB_CTRL_EC_AM_MODE_SET(x, v)            do { (x) = (((x) & ~0x100) | ((SCB_CTRL_EC_AM_MODE_##v) << 8)); } while(0)
  #define SCB_CTRL_EC_AM_MODE_SETVAL(x, v)         do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define SCB_CTRL_EC_AM_MODE_GET(x)               (((x) >> 8) & 0x1)
    #define SCB_CTRL_EC_AM_MODE_INTERNAL             0x00000000
    #define SCB_CTRL_EC_AM_MODE_EXTERNAL             0x00000001
  #define SCB_CTRL_EC_OP_MODE(v)                   ((SCB_CTRL_EC_OP_MODE_##v) << 9)
  #define SCB_CTRL_EC_OP_MODE_SET(x, v)            do { (x) = (((x) & ~0x200) | ((SCB_CTRL_EC_OP_MODE_##v) << 9)); } while(0)
  #define SCB_CTRL_EC_OP_MODE_SETVAL(x, v)         do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
  #define SCB_CTRL_EC_OP_MODE_GET(x)               (((x) >> 9) & 0x1)
    #define SCB_CTRL_EC_OP_MODE_INTERNAL             0x00000000
    #define SCB_CTRL_EC_OP_MODE_EXTERNAL             0x00000001
  #define SCB_CTRL_EZ_MODE                         0x00000400
  #define SCB_CTRL_BYTE_MODE(v)                    ((SCB_CTRL_BYTE_MODE_##v) << 11)
  #define SCB_CTRL_BYTE_MODE_SET(x, v)             do { (x) = (((x) & ~0x800) | ((SCB_CTRL_BYTE_MODE_##v) << 11)); } while(0)
  #define SCB_CTRL_BYTE_MODE_SETVAL(x, v)          do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
  #define SCB_CTRL_BYTE_MODE_GET(x)                (((x) >> 11) & 0x1)
    #define SCB_CTRL_BYTE_MODE_8_BIT_ELEMENTS        0x00000000
    #define SCB_CTRL_BYTE_MODE_16_BIT_ELEMENTS       0x00000001
/** Determines whether a received matching address is accepted in the RX FIFO
   @multiple */
  #define SCB_CTRL_ADDR_ACCEPT                     0x00010000
/** Order EZ accesses @multiple */
  #define SCB_CTRL_BLOCK                           0x00020000
/** Mode of operation @multiple */
  #define SCB_CTRL_MODE(v)                         ((SCB_CTRL_MODE_##v) << 24)
  #define SCB_CTRL_MODE_SET(x, v)                  do { (x) = (((x) & ~0x3000000) | ((SCB_CTRL_MODE_##v) << 24)); } while(0)
  #define SCB_CTRL_MODE_SETVAL(x, v)               do { (x) = (((x) & ~0x3000000) | ((v) << 24)); } while(0)
  #define SCB_CTRL_MODE_GET(x)                     (((x) >> 24) & 0x3)
    #define SCB_CTRL_MODE_I2C                        0x00000000
    #define SCB_CTRL_MODE_SPI                        0x00000001
    #define SCB_CTRL_MODE_UART                       0x00000002
  #define SCB_CTRL_ENABLED                         0x80000000

#define SCB_STATUS_ADDR                              0x00000004
#define SCB_STATUS_MASK                              0x00000001
/** Inidicates whether the externally clocked logic is potentially accessing the
   EZ memory @multiple */
  #define SCB_STATUS_EC_BUSY                       0x00000001

#define SCB_SPI_CTRL_ADDR                            0x00000020
#define SCB_SPI_CTRL_MASK                            0x8f010f3f
/** Continuous or separated SPI data transfers @multiple */
  #define SCB_SPI_CTRL_CONTINUOUS                  0x00000001
/** In Ti mode, whether strobe precedes or is concurrent with first byte
   @multiple */
  #define SCB_SPI_CTRL_SELECT_PRECEDE              0x00000002
/** Clock phase @multiple */
  #define SCB_SPI_CTRL_CPHA                        0x00000004
/** Clock polarity @multiple */
  #define SCB_SPI_CTRL_CPOL                        0x00000008
/** Whether to invert MISO sampling wrt default of current mode. @multiple */
  #define SCB_SPI_CTRL_LAST_MISO_SAMPLE            0x00000010
/** Whether to generate clock cycles even if no slave is selected. @multiple */
  #define SCB_SPI_CTRL_SCLK_CONTINUOUS             0x00000020
/** Polarity of SSEL0 @multiple */
  #define SCB_SPI_CTRL_SSEL_POLARITY0              0x00000100
/** Polarity of SSEL1 @multiple */
  #define SCB_SPI_CTRL_SSEL_POLARITY1              0x00000200
/** Polarity of SSEL2 @multiple */
  #define SCB_SPI_CTRL_SSEL_POLARITY2              0x00000400
/** Polarity of SSEL3 @multiple */
  #define SCB_SPI_CTRL_SSEL_POLARITY3              0x00000800
/** Whether to loopback MISO and MOSI lines. @multiple */
  #define SCB_SPI_CTRL_LOOPBACK                    0x00010000
  #define SCB_SPI_CTRL_MODE(v)                     ((SCB_SPI_CTRL_MODE_##v) << 24)
  #define SCB_SPI_CTRL_MODE_SET(x, v)              do { (x) = (((x) & ~0x3000000) | ((SCB_SPI_CTRL_MODE_##v) << 24)); } while(0)
  #define SCB_SPI_CTRL_MODE_SETVAL(x, v)           do { (x) = (((x) & ~0x3000000) | ((v) << 24)); } while(0)
  #define SCB_SPI_CTRL_MODE_GET(x)                 (((x) >> 24) & 0x3)
    #define SCB_SPI_CTRL_MODE_MOTOROLA               0x00000000
    #define SCB_SPI_CTRL_MODE_TI                     0x00000001
    #define SCB_SPI_CTRL_MODE_NS                     0x00000002
/** For master mode, select relevant SSEL line, SCB block must be disabled while
   changes are made to this register. @multiple */
  #define SCB_SPI_CTRL_SLAVE_SELECT(v)             ((v) << 26)
  #define SCB_SPI_CTRL_SLAVE_SELECT_SET(x, v)      do { (x) = (((x) & ~0xc000000) | ((v) << 26)); } while(0)
  #define SCB_SPI_CTRL_SLAVE_SELECT_GET(x)         (((x) >> 26) & 0x3)
/** Whether we are SPI master @multiple */
  #define SCB_SPI_CTRL_MASTER_MODE                 0x80000000

#define SCB_SPI_STATUS_ADDR                          0x00000024
#define SCB_SPI_STATUS_MASK                          0x00ffff03
/** SPI bus is busy @multiple */
  #define SCB_SPI_STATUS_BUS_BUSY                  0x00000001
/** Inidicates whether the externally clocked logic is potentially accessing the
   EZ memory @multiple */
  #define SCB_SPI_STATUS_EC_BUSY                   0x00000002
/** SPI current EZ address @multiple */
  #define SCB_SPI_STATUS_CURR_EZ_BUSY(v)           ((v) << 8)
  #define SCB_SPI_STATUS_CURR_EZ_BUSY_SET(x, v)    do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define SCB_SPI_STATUS_CURR_EZ_BUSY_GET(x)       (((x) >> 8) & 0xff)
/** SPI base EZ address @multiple */
  #define SCB_SPI_STATUS_BASE_EZ_ADDRESS(v)        ((v) << 16)
  #define SCB_SPI_STATUS_BASE_EZ_ADDRESS_SET(x, v) do { (x) = (((x) & ~0xff0000) | ((v) << 16)); } while(0)
  #define SCB_SPI_STATUS_BASE_EZ_ADDRESS_GET(x)    (((x) >> 16) & 0xff)

#define SCB_UART_CTRL_ADDR                           0x00000040
#define SCB_UART_CTRL_MASK                           0x03010000
/** Whether to loopback RX and TX lines. @multiple */
  #define SCB_UART_CTRL_LOOPBACK                   0x00010000
  #define SCB_UART_CTRL_MODE(v)                    ((SCB_UART_CTRL_MODE_##v) << 24)
  #define SCB_UART_CTRL_MODE_SET(x, v)             do { (x) = (((x) & ~0x3000000) | ((SCB_UART_CTRL_MODE_##v) << 24)); } while(0)
  #define SCB_UART_CTRL_MODE_SETVAL(x, v)          do { (x) = (((x) & ~0x3000000) | ((v) << 24)); } while(0)
  #define SCB_UART_CTRL_MODE_GET(x)                (((x) >> 24) & 0x3)
    #define SCB_UART_CTRL_MODE_STD                   0x00000000
    #define SCB_UART_CTRL_MODE_SMARTCARD             0x00000001
    #define SCB_UART_CTRL_MODE_IRDA                  0x00000002

#define SCB_UART_TX_CTRL_ADDR                        0x00000044
#define SCB_UART_TX_CTRL_MASK                        0x00000137
/** Count of stop bits - 1 @multiple */
  #define SCB_UART_TX_CTRL_STOP_BITS(v)            ((v) << 0)
  #define SCB_UART_TX_CTRL_STOP_BITS_SET(x, v)     do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define SCB_UART_TX_CTRL_STOP_BITS_GET(x)        (((x) >> 0) & 0x7)
/** Parity mode @multiple */
  #define SCB_UART_TX_CTRL_PARITY(v)               ((SCB_UART_TX_CTRL_PARITY_##v) << 4)
  #define SCB_UART_TX_CTRL_PARITY_SET(x, v)        do { (x) = (((x) & ~0x10) | ((SCB_UART_TX_CTRL_PARITY_##v) << 4)); } while(0)
  #define SCB_UART_TX_CTRL_PARITY_SETVAL(x, v)     do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define SCB_UART_TX_CTRL_PARITY_GET(x)           (((x) >> 4) & 0x1)
    #define SCB_UART_TX_CTRL_PARITY_EVEN             0x00000000
    #define SCB_UART_TX_CTRL_PARITY_ODD              0x00000001
/** Whether to include a parity bit @multiple */
  #define SCB_UART_TX_CTRL_PARITY_ENABLED          0x00000020
/** In smartcard mode, retry byte if a NACK is received @multiple */
  #define SCB_UART_TX_CTRL_RETRY_ON_NACK           0x00000100

#define SCB_UART_RX_CTRL_ADDR                        0x00000048
#define SCB_UART_RX_CTRL_MASK                        0x000f3777
/** Count of stop bits - 1 @multiple */
  #define SCB_UART_RX_CTRL_STOP_BITS(v)            ((v) << 0)
  #define SCB_UART_RX_CTRL_STOP_BITS_SET(x, v)     do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define SCB_UART_RX_CTRL_STOP_BITS_GET(x)        (((x) >> 0) & 0x7)
/** Parity mode @multiple */
  #define SCB_UART_RX_CTRL_PARITY(v)               ((SCB_UART_RX_CTRL_PARITY_##v) << 4)
  #define SCB_UART_RX_CTRL_PARITY_SET(x, v)        do { (x) = (((x) & ~0x10) | ((SCB_UART_RX_CTRL_PARITY_##v) << 4)); } while(0)
  #define SCB_UART_RX_CTRL_PARITY_SETVAL(x, v)     do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define SCB_UART_RX_CTRL_PARITY_GET(x)           (((x) >> 4) & 0x1)
    #define SCB_UART_RX_CTRL_PARITY_EVEN             0x00000000
    #define SCB_UART_RX_CTRL_PARITY_ODD              0x00000001
/** Whether to expect a parity bit @multiple */
  #define SCB_UART_RX_CTRL_PARITY_ENABLED          0x00000020
/** Whether to invert line @multiple */
  #define SCB_UART_RX_CTRL_POLARITY                0x00000040
/** Whether to discard incoming data when parity check fails @multiple */
  #define SCB_UART_RX_CTRL_DROP_ON_PARITY_ERROR    0x00000100
/** Whether to discard incoming data when handshaking fails @multiple */
  #define SCB_UART_RX_CTRL_DROP_ON_FRAME_ERROR     0x00000200
/** Multiprocessor mode, should be enabled with a 9-bit frame size @multiple */
  #define SCB_UART_RX_CTRL_MP_MODE                 0x00000400
/** perform break detection and baud rate detection on the incoming data
   @multiple */
  #define SCB_UART_RX_CTRL_LIN_MODE                0x00001000
/** Receiver skips start bit detection for the first received data frame
   @multiple */
  #define SCB_UART_RX_CTRL_SKIP_START              0x00002000
/** Count of clock period - 1 data line must be 0 to deteck a Break condition
   @multiple */
  #define SCB_UART_RX_CTRL_BREAK_WIDTH(v)          ((v) << 16)
  #define SCB_UART_RX_CTRL_BREAK_WIDTH_SET(x, v)   do { (x) = (((x) & ~0xf0000) | ((v) << 16)); } while(0)
  #define SCB_UART_RX_CTRL_BREAK_WIDTH_GET(x)      (((x) >> 16) & 0xf)

#define SCB_UART_RX_STATUS_ADDR                      0x0000004c
#define SCB_UART_RX_STATUS_MASK                      0x00000fff
/** UART baudrate detection counter. Bit clock is br_counter / 8. @multiple */
  #define SCB_UART_RX_STATUS_BR_COUNTER(v)         ((v) << 0)
  #define SCB_UART_RX_STATUS_BR_COUNTER_SET(x, v)  do { (x) = (((x) & ~0xfff) | ((v) << 0)); } while(0)
  #define SCB_UART_RX_STATUS_BR_COUNTER_GET(x)     (((x) >> 0) & 0xfff)

#define SCB_UART_FLOW_CTRL_ADDR                      0x00000050
#define SCB_UART_FLOW_CTRL_MASK                      0x0301000f
/** Assert RTS when FIFO contains less entries than this field @multiple */
  #define SCB_UART_FLOW_CTRL_TRIGGER_LEVEL(v)      ((v) << 0)
  #define SCB_UART_FLOW_CTRL_TRIGGER_LEVEL_SET(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SCB_UART_FLOW_CTRL_TRIGGER_LEVEL_GET(x)  (((x) >> 0) & 0xf)
  #define SCB_UART_FLOW_CTRL_RTS_POLARITY(v)       ((SCB_UART_FLOW_CTRL_RTS_POLARITY_##v) << 16)
  #define SCB_UART_FLOW_CTRL_RTS_POLARITY_SET(x, v) do { (x) = (((x) & ~0x10000) | ((SCB_UART_FLOW_CTRL_RTS_POLARITY_##v) << 16)); } while(0)
  #define SCB_UART_FLOW_CTRL_RTS_POLARITY_SETVAL(x, v) do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define SCB_UART_FLOW_CTRL_RTS_POLARITY_GET(x)   (((x) >> 16) & 0x1)
    #define SCB_UART_FLOW_CTRL_RTS_POLARITY_ACTIVE_LOW 0x00000000
    #define SCB_UART_FLOW_CTRL_RTS_POLARITY_ACTIVE_HIGH 0x00000001
  #define SCB_UART_FLOW_CTRL_CTS_POLARITY(v)       ((SCB_UART_FLOW_CTRL_CTS_POLARITY_##v) << 24)
  #define SCB_UART_FLOW_CTRL_CTS_POLARITY_SET(x, v) do { (x) = (((x) & ~0x1000000) | ((SCB_UART_FLOW_CTRL_CTS_POLARITY_##v) << 24)); } while(0)
  #define SCB_UART_FLOW_CTRL_CTS_POLARITY_SETVAL(x, v) do { (x) = (((x) & ~0x1000000) | ((v) << 24)); } while(0)
  #define SCB_UART_FLOW_CTRL_CTS_POLARITY_GET(x)   (((x) >> 24) & 0x1)
    #define SCB_UART_FLOW_CTRL_CTS_POLARITY_ACTIVE_LOW 0x00000000
    #define SCB_UART_FLOW_CTRL_CTS_POLARITY_ACTIVE_HIGH 0x00000001
/** Whether to stop sending when CTS line is not active @multiple */
  #define SCB_UART_FLOW_CTRL_CTS_ENABLED           0x02000000

#define SCB_TX_CTRL_ADDR                             0x00000200
#define SCB_TX_CTRL_MASK                             0x0000010f
/** Data frame bit count - 1. Should be set to 1 for I2C @multiple */
  #define SCB_TX_CTRL_DATA_WIDTH(v)                ((v) << 0)
  #define SCB_TX_CTRL_DATA_WIDTH_SET(x, v)         do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SCB_TX_CTRL_DATA_WIDTH_GET(x)            (((x) >> 0) & 0xf)
/** Whether to send MSB first. Should be set to 1 for I2C @multiple */
  #define SCB_TX_CTRL_MSB_FIRST                    0x00000100

#define SCB_TX_FIFO_CTRL_ADDR                        0x00000204
#define SCB_TX_FIFO_CTRL_MASK                        0x0003000f
/** Generate a "transmitter trigger" event when transmitter FIFO fillness count
   is less than this register @multiple */
  #define SCB_TX_FIFO_CTRL_TRIGGER_LEVEL(v)        ((v) << 0)
  #define SCB_TX_FIFO_CTRL_TRIGGER_LEVEL_SET(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SCB_TX_FIFO_CTRL_TRIGGER_LEVEL_GET(x)    (((x) >> 0) & 0xf)
/** Whether to clear the TX FIFO. This register must be reset to 0 from software.
   @multiple */
  #define SCB_TX_FIFO_CTRL_CLEAR                   0x00010000
/** Hardware reads from FIFO dont update read pointer @multiple */
  #define SCB_TX_FIFO_CTRL_FREEZE                  0x00020000

#define SCB_TX_FIFO_STATUS_ADDR                      0x00000208
#define SCB_TX_FIFO_STATUS_MASK                      0x0f0f801f
/** Count of entries in the TX FIFO @multiple */
  #define SCB_TX_FIFO_STATUS_USED(v)               ((v) << 0)
  #define SCB_TX_FIFO_STATUS_USED_SET(x, v)        do { (x) = (((x) & ~0x1f) | ((v) << 0)); } while(0)
  #define SCB_TX_FIFO_STATUS_USED_GET(x)           (((x) >> 0) & 0x1f)
/** Whether shift register currently holds a valid data frame @multiple */
  #define SCB_TX_FIFO_STATUS_SR_VALID              0x00008000
/** FIFO read pointer @multiple */
  #define SCB_TX_FIFO_STATUS_RD_PTR(v)             ((v) << 16)
  #define SCB_TX_FIFO_STATUS_RD_PTR_SET(x, v)      do { (x) = (((x) & ~0xf0000) | ((v) << 16)); } while(0)
  #define SCB_TX_FIFO_STATUS_RD_PTR_GET(x)         (((x) >> 16) & 0xf)
/** FIFO write pointer @multiple */
  #define SCB_TX_FIFO_STATUS_WR_PTR(v)             ((v) << 24)
  #define SCB_TX_FIFO_STATUS_WR_PTR_SET(x, v)      do { (x) = (((x) & ~0xf000000) | ((v) << 24)); } while(0)
  #define SCB_TX_FIFO_STATUS_WR_PTR_GET(x)         (((x) >> 24) & 0xf)

#define SCB_TX_FIFO_WR_ADDR                          0x00000240
#define SCB_TX_FIFO_WR_MASK                          0x0000ffff
  #define SCB_TX_FIFO_WR_DATA(v)                   ((v) << 0)
  #define SCB_TX_FIFO_WR_DATA_SET(x, v)            do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SCB_TX_FIFO_WR_DATA_GET(x)               (((x) >> 0) & 0xffff)

#define SCB_RX_CTRL_ADDR                             0x00000300
#define SCB_RX_CTRL_MASK                             0x0000030f
/** Data frame bit count - 1. Should be set to 1 for I2C @multiple */
  #define SCB_RX_CTRL_DATA_WIDTH(v)                ((v) << 0)
  #define SCB_RX_CTRL_DATA_WIDTH_SET(x, v)         do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SCB_RX_CTRL_DATA_WIDTH_GET(x)            (((x) >> 0) & 0xf)
/** Whether to send MSB first. Should be set to 1 for I2C @multiple */
  #define SCB_RX_CTRL_MSB_FIRST                    0x00000100
/** Whether to sample input bits 3 times and do a majority vote @multiple */
  #define SCB_RX_CTRL_MEDIAN                       0x00000200

#define SCB_RX_FIFO_CTRL_ADDR                        0x00000304
#define SCB_RX_FIFO_CTRL_MASK                        0x0003000f
/** Generate a "receiver trigger" event when receiver FIFO fillness count is more
   than this register @multiple */
  #define SCB_RX_FIFO_CTRL_TRIGGER_LEVEL(v)        ((v) << 0)
  #define SCB_RX_FIFO_CTRL_TRIGGER_LEVEL_SET(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SCB_RX_FIFO_CTRL_TRIGGER_LEVEL_GET(x)    (((x) >> 0) & 0xf)
/** Whether to clear the RX FIFO. This register must be reset to 0 from software.
   @multiple */
  #define SCB_RX_FIFO_CTRL_CLEAR                   0x00010000
/** Hardware writes to FIFO dont update read pointer @multiple */
  #define SCB_RX_FIFO_CTRL_FREEZE                  0x00020000

#define SCB_RX_FIFO_STATUS_ADDR                      0x00000308
#define SCB_RX_FIFO_STATUS_MASK                      0x0f0f801f
/** Count of entries in the RX FIFO @multiple */
  #define SCB_RX_FIFO_STATUS_USED(v)               ((v) << 0)
  #define SCB_RX_FIFO_STATUS_USED_SET(x, v)        do { (x) = (((x) & ~0x1f) | ((v) << 0)); } while(0)
  #define SCB_RX_FIFO_STATUS_USED_GET(x)           (((x) >> 0) & 0x1f)
/** Whether shift register currently holds a valid data frame @multiple */
  #define SCB_RX_FIFO_STATUS_SR_VALID              0x00008000
/** FIFO read pointer @multiple */
  #define SCB_RX_FIFO_STATUS_RD_PTR(v)             ((v) << 16)
  #define SCB_RX_FIFO_STATUS_RD_PTR_SET(x, v)      do { (x) = (((x) & ~0xf0000) | ((v) << 16)); } while(0)
  #define SCB_RX_FIFO_STATUS_RD_PTR_GET(x)         (((x) >> 16) & 0xf)
/** FIFO write pointer @multiple */
  #define SCB_RX_FIFO_STATUS_WR_PTR(v)             ((v) << 24)
  #define SCB_RX_FIFO_STATUS_WR_PTR_SET(x, v)      do { (x) = (((x) & ~0xf000000) | ((v) << 24)); } while(0)
  #define SCB_RX_FIFO_STATUS_WR_PTR_GET(x)         (((x) >> 24) & 0xf)

#define SCB_RX_MATCH_ADDR                            0x00000310
#define SCB_RX_MATCH_MASK                            0x00ff00ff
/** Slave device address @multiple */
  #define SCB_RX_MATCH_ADDR_(v)                    ((v) << 0)
  #define SCB_RX_MATCH_ADDR__SET(x, v)             do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define SCB_RX_MATCH_ADDR__GET(x)                (((x) >> 0) & 0xff)
/** Mask for device address @multiple */
  #define SCB_RX_MATCH_MASK_(v)                    ((v) << 16)
  #define SCB_RX_MATCH_MASK__SET(x, v)             do { (x) = (((x) & ~0xff0000) | ((v) << 16)); } while(0)
  #define SCB_RX_MATCH_MASK__GET(x)                (((x) >> 16) & 0xff)

#define SCB_RX_FIFO_RD_ADDR                          0x00000340
#define SCB_RX_FIFO_RD_MASK                          0x0000ffff
  #define SCB_RX_FIFO_RD_DATA(v)                   ((v) << 0)
  #define SCB_RX_FIFO_RD_DATA_SET(x, v)            do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SCB_RX_FIFO_RD_DATA_GET(x)               (((x) >> 0) & 0xffff)

/** A read operation to this register retrieves the first item of the RX fifo
   without updating FIFO pointers @multiple */
#define SCB_RX_FIFO_RD_SILENT_ADDR                   0x00000344
#define SCB_RX_FIFO_RD_SILENT_MASK                   0x0000ffff
  #define SCB_RX_FIFO_RD_SILENT_DATA(v)            ((v) << 0)
  #define SCB_RX_FIFO_RD_SILENT_DATA_SET(x, v)     do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SCB_RX_FIFO_RD_SILENT_DATA_GET(x)        (((x) >> 0) & 0xffff)

#define SCB_INTR_CAUSE_ADDR                          0x00000e00
#define SCB_INTR_CAUSE_MASK                          0x0000003f
  #define SCB_INTR_CAUSE_M                         0x00000001
  #define SCB_INTR_CAUSE_S                         0x00000002
  #define SCB_INTR_CAUSE_TX                        0x00000004
  #define SCB_INTR_CAUSE_RX                        0x00000008
  #define SCB_INTR_CAUSE_I2C_EC                    0x00000010
  #define SCB_INTR_CAUSE_SPI_EC                    0x00000020

#define SCB_INTR_TX_ADDR                             0x00000f80
#define SCB_INTR_TX_MASK                             0x000007f3
/** Less entries in the TX FIFO than the value specified by TX_FIFO_CTRL
   @multiple */
  #define SCB_INTR_TX_TRIGGER                      0x00000001
/** TX FIFO is not full @multiple */
  #define SCB_INTR_TX_NOT_FULL                     0x00000002
/** TX FIFO empty @multiple */
  #define SCB_INTR_TX_EMPTY                        0x00000010
/** Attempt to write to a full TX FIFO @multiple */
  #define SCB_INTR_TX_OVERFLOW                     0x00000020
/** Attempt to read from an empty TX FIFO @multiple */
  #define SCB_INTR_TX_UNDERFLOW                    0x00000040
/** SW cannot get access to the EZ memory @multiple */
  #define SCB_INTR_TX_BLOCKED                      0x00000080
/** UART transmitter received a negative acknowledgement in SmartCard mode
   @multiple */
  #define SCB_INTR_TX_UART_NACK                    0x00000100
/** UART transmitter done event @multiple */
  #define SCB_INTR_TX_UART_DONE                    0x00000200
/** UART lost arbitration @multiple */
  #define SCB_INTR_TX_UART_ARB_LOST                0x00000400

#define SCB_INTR_TX_SET_ADDR                         0x00000f84
#define SCB_INTR_TX_SET_MASK                         0x000007f3
/** Less entries in the TX FIFO than the value specified by TX_FIFO_CTRL
   @multiple */
  #define SCB_INTR_TX_SET_TRIGGER                  0x00000001
/** TX FIFO is not full @multiple */
  #define SCB_INTR_TX_SET_NOT_FULL                 0x00000002
/** TX FIFO empty @multiple */
  #define SCB_INTR_TX_SET_EMPTY                    0x00000010
/** Attempt to write to a full TX FIFO @multiple */
  #define SCB_INTR_TX_SET_OVERFLOW                 0x00000020
/** Attempt to read from an empty TX FIFO @multiple */
  #define SCB_INTR_TX_SET_UNDERFLOW                0x00000040
/** SW cannot get access to the EZ memory @multiple */
  #define SCB_INTR_TX_SET_BLOCKED                  0x00000080
/** UART transmitter received a negative acknowledgement in SmartCard mode
   @multiple */
  #define SCB_INTR_TX_SET_UART_NACK                0x00000100
/** UART transmitter done event @multiple */
  #define SCB_INTR_TX_SET_UART_DONE                0x00000200
/** UART lost arbitration @multiple */
  #define SCB_INTR_TX_SET_UART_ARB_LOST            0x00000400

#define SCB_INTR_TX_MASK_ADDR                        0x00000f88
#define SCB_INTR_TX_MASK_MASK                        0x000007f3
/** Less entries in the TX FIFO than the value specified by TX_FIFO_CTRL
   @multiple */
  #define SCB_INTR_TX_MASK_TRIGGER                 0x00000001
/** TX FIFO is not full @multiple */
  #define SCB_INTR_TX_MASK_NOT_FULL                0x00000002
/** TX FIFO empty @multiple */
  #define SCB_INTR_TX_MASK_EMPTY                   0x00000010
/** Attempt to write to a full TX FIFO @multiple */
  #define SCB_INTR_TX_MASK_OVERFLOW                0x00000020
/** Attempt to read from an empty TX FIFO @multiple */
  #define SCB_INTR_TX_MASK_UNDERFLOW               0x00000040
/** SW cannot get access to the EZ memory @multiple */
  #define SCB_INTR_TX_MASK_BLOCKED                 0x00000080
/** UART transmitter received a negative acknowledgement in SmartCard mode
   @multiple */
  #define SCB_INTR_TX_MASK_UART_NACK               0x00000100
/** UART transmitter done event @multiple */
  #define SCB_INTR_TX_MASK_UART_DONE               0x00000200
/** UART lost arbitration @multiple */
  #define SCB_INTR_TX_MASK_UART_ARB_LOST           0x00000400

#define SCB_INTR_TX_MASKED_ADDR                      0x00000f8c
#define SCB_INTR_TX_MASKED_MASK                      0x000007f3
/** Less entries in the TX FIFO than the value specified by TX_FIFO_CTRL
   @multiple */
  #define SCB_INTR_TX_MASKED_TRIGGER               0x00000001
/** TX FIFO is not full @multiple */
  #define SCB_INTR_TX_MASKED_NOT_FULL              0x00000002
/** TX FIFO empty @multiple */
  #define SCB_INTR_TX_MASKED_EMPTY                 0x00000010
/** Attempt to write to a full TX FIFO @multiple */
  #define SCB_INTR_TX_MASKED_OVERFLOW              0x00000020
/** Attempt to read from an empty TX FIFO @multiple */
  #define SCB_INTR_TX_MASKED_UNDERFLOW             0x00000040
/** SW cannot get access to the EZ memory @multiple */
  #define SCB_INTR_TX_MASKED_BLOCKED               0x00000080
/** UART transmitter received a negative acknowledgement in SmartCard mode
   @multiple */
  #define SCB_INTR_TX_MASKED_UART_NACK             0x00000100
/** UART transmitter done event @multiple */
  #define SCB_INTR_TX_MASKED_UART_DONE             0x00000200
/** UART lost arbitration @multiple */
  #define SCB_INTR_TX_MASKED_UART_ARB_LOST         0x00000400

#define SCB_INTR_RX_ADDR                             0x00000fc0
#define SCB_INTR_RX_MASK                             0x00000fed
/** More entries in the RX FIFO than the value specified by RX_FIFO_CTRL
   @multiple */
  #define SCB_INTR_RX_TRIGGER                      0x00000001
/** RX FIFO is not empty @multiple */
  #define SCB_INTR_RX_NOT_EMPTY                    0x00000004
/** RX FIFO full @multiple */
  #define SCB_INTR_RX_FULL                         0x00000008
/** Attempt to write to a full RX FIFO @multiple */
  #define SCB_INTR_RX_OVERFLOW                     0x00000020
/** Attempt to read from an empty RX FIFO @multiple */
  #define SCB_INTR_RX_UNDERFLOW                    0x00000040
/** SW cannot get access to the EZ memory @multiple */
  #define SCB_INTR_RX_BLOCKED                      0x00000080
/** Frame error in received data frame @multiple */
  #define SCB_INTR_RX_FRAME_ERROR                  0x00000100
/** Parity error in received data frame @multiple */
  #define SCB_INTR_RX_PARITY_ERROR                 0x00000200
/** LIN baudrate detection completed @multiple */
  #define SCB_INTR_RX_BAUD_DETECT                  0x00000400
/** Break detection is successful @multiple */
  #define SCB_INTR_RX_BREAK_DETECT                 0x00000800

#define SCB_INTR_RX_SET_ADDR                         0x00000fc4
#define SCB_INTR_RX_SET_MASK                         0x00000fed
/** Less entries in the RX FIFO than the value specified by RX_FIFO_CTRL
   @multiple */
  #define SCB_INTR_RX_SET_TRIGGER                  0x00000001
/** RX FIFO is not empty @multiple */
  #define SCB_INTR_RX_SET_NOT_EMPTY                0x00000004
/** RX FIFO full @multiple */
  #define SCB_INTR_RX_SET_FULL                     0x00000008
/** Attempt to write to a full RX FIFO @multiple */
  #define SCB_INTR_RX_SET_OVERFLOW                 0x00000020
/** Attempt to read from an empty RX FIFO @multiple */
  #define SCB_INTR_RX_SET_UNDERFLOW                0x00000040
/** SW cannot get access to the EZ memory @multiple */
  #define SCB_INTR_RX_SET_BLOCKED                  0x00000080
/** Frame error in received data frame @multiple */
  #define SCB_INTR_RX_SET_FRAME_ERROR              0x00000100
/** Parity error in received data frame @multiple */
  #define SCB_INTR_RX_SET_PARITY_ERROR             0x00000200
/** LIN baudrate detection completed @multiple */
  #define SCB_INTR_RX_SET_BAUD_DETECT              0x00000400
/** Break detection is successful @multiple */
  #define SCB_INTR_RX_SET_BREAK_DETECT             0x00000800

#define SCB_INTR_RX_MASK_ADDR                        0x00000fc8
#define SCB_INTR_RX_MASK_MASK                        0x00000fed
/** Less entries in the RX FIFO than the value specified by RX_FIFO_CTRL
   @multiple */
  #define SCB_INTR_RX_MASK_TRIGGER                 0x00000001
/** RX FIFO is not empty @multiple */
  #define SCB_INTR_RX_MASK_NOT_EMPTY               0x00000004
/** RX FIFO full @multiple */
  #define SCB_INTR_RX_MASK_FULL                    0x00000008
/** Attempt to write to a full RX FIFO @multiple */
  #define SCB_INTR_RX_MASK_OVERFLOW                0x00000020
/** Attempt to read from an empty RX FIFO @multiple */
  #define SCB_INTR_RX_MASK_UNDERFLOW               0x00000040
/** SW cannot get access to the EZ memory @multiple */
  #define SCB_INTR_RX_MASK_BLOCKED                 0x00000080
/** Frame error in received data frame @multiple */
  #define SCB_INTR_RX_MASK_FRAME_ERROR             0x00000100
/** Parity error in received data frame @multiple */
  #define SCB_INTR_RX_MASK_PARITY_ERROR            0x00000200
/** LIN baudrate detection completed @multiple */
  #define SCB_INTR_RX_MASK_BAUD_DETECT             0x00000400
/** Break detection is successful @multiple */
  #define SCB_INTR_RX_MASK_BREAK_DETECT            0x00000800

#define SCB_INTR_RX_MASKED_ADDR                      0x00000fcc
#define SCB_INTR_RX_MASKED_MASK                      0x00000fed
/** Less entries in the RX FIFO than the value specified by RX_FIFO_CTRL
   @multiple */
  #define SCB_INTR_RX_MASKED_TRIGGER               0x00000001
/** RX FIFO is not empty @multiple */
  #define SCB_INTR_RX_MASKED_NOT_EMPTY             0x00000004
/** RX FIFO full @multiple */
  #define SCB_INTR_RX_MASKED_FULL                  0x00000008
/** Attempt to write to a full RX FIFO @multiple */
  #define SCB_INTR_RX_MASKED_OVERFLOW              0x00000020
/** Attempt to read from an empty RX FIFO @multiple */
  #define SCB_INTR_RX_MASKED_UNDERFLOW             0x00000040
/** SW cannot get access to the EZ memory @multiple */
  #define SCB_INTR_RX_MASKED_BLOCKED               0x00000080
/** Frame error in received data frame @multiple */
  #define SCB_INTR_RX_MASKED_FRAME_ERROR           0x00000100
/** Parity error in received data frame @multiple */
  #define SCB_INTR_RX_MASKED_PARITY_ERROR          0x00000200
/** LIN baudrate detection completed @multiple */
  #define SCB_INTR_RX_MASKED_BAUD_DETECT           0x00000400
/** Break detection is successful @multiple */
  #define SCB_INTR_RX_MASKED_BREAK_DETECT          0x00000800

#endif

