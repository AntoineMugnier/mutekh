/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -I lcd.bf -O lcd.h -o cdefs cdefs_use_reg_mask=1                      \
     cdefs_use_field_setval=1
*/

#ifndef _LCD_BFGEN_DEFS_
#define _LCD_BFGEN_DEFS_

/** ID & Revision @multiple */
#define LCD_LCD_ID_ADDR                              0x00000000
#define LCD_LCD_ID_MASK                              0xffffffff
/** the ID of LCD controller peripheral is 0xF0F0 @multiple */
  #define LCD_LCD_ID_ID(v)                         ((v) << 0)
  #define LCD_LCD_ID_ID_SET(x, v)                  do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define LCD_LCD_ID_ID_GET(x)                     (((x) >> 0) & 0xffff)
/** the version number is 0x0001 @multiple */
  #define LCD_LCD_ID_REVISION(v)                   ((v) << 16)
  #define LCD_LCD_ID_REVISION_SET(x, v)            do { (x) = (((x) & ~0xffff0000) | ((v) << 16)); } while(0)
  #define LCD_LCD_ID_REVISION_GET(x)               (((x) >> 16) & 0xffff)

#define LCD_LCD_DIVIDER_ADDR                         0x00000004
#define LCD_LCD_DIVIDER_MASK                         0xffffffff
/** Input clock frequency divide value, to generate the 1/4 sub-frame period. The
   sub-frame period is 4 * (SUBFR_DIV + 1) cycles long. @multiple */
  #define LCD_LCD_DIVIDER_SUBFR_DIV(v)             ((v) << 0)
  #define LCD_LCD_DIVIDER_SUBFR_DIV_SET(x, v)      do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define LCD_LCD_DIVIDER_SUBFR_DIV_GET(x)         (((x) >> 0) & 0xffff)
/** Length of the dead time period in cycles. When set to zero, no dead time
   period exists. @multiple */
  #define LCD_LCD_DIVIDER_DEAD_DIV(v)              ((v) << 16)
  #define LCD_LCD_DIVIDER_DEAD_DIV_SET(x, v)       do { (x) = (((x) & ~0xffff0000) | ((v) << 16)); } while(0)
  #define LCD_LCD_DIVIDER_DEAD_DIV_GET(x)          (((x) >> 16) & 0xffff)

#define LCD_LCD_CONTROL_ADDR                         0x00000008
#define LCD_LCD_CONTROL_MASK                         0x80000f7f
/** Low speed (LS) generator enable @multiple */
  #define LCD_LCD_CONTROL_LS_EN                    0x00000001
/** High speed (HS) generator enable @multiple */
  #define LCD_LCD_CONTROL_HS_EN                    0x00000002
/** HS/LS Mode selection Default Value: 0 @multiple */
  #define LCD_LCD_CONTROL_LCD_MODE(v)              ((LCD_LCD_CONTROL_LCD_MODE_##v) << 2)
  #define LCD_LCD_CONTROL_LCD_MODE_SET(x, v)       do { (x) = (((x) & ~0x4) | ((LCD_LCD_CONTROL_LCD_MODE_##v) << 2)); } while(0)
  #define LCD_LCD_CONTROL_LCD_MODE_SETVAL(x, v)    do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define LCD_LCD_CONTROL_LCD_MODE_GET(x)          (((x) >> 2) & 0x1)
/** Select Low Speed (32kHz) Generator (Works in Active, Sleep and DeepSleep power modes). */
    #define LCD_LCD_CONTROL_LCD_MODE_LS              0x00000000
/** Select High Speed (system clock) Generator (Works in Active and Sleep power modes only). */
    #define LCD_LCD_CONTROL_LCD_MODE_HS              0x00000001
/** LCD driving waveform type configuration. Default Value: 0 @multiple */
  #define LCD_LCD_CONTROL_TYPE(v)                  ((LCD_LCD_CONTROL_TYPE_##v) << 3)
  #define LCD_LCD_CONTROL_TYPE_SET(x, v)           do { (x) = (((x) & ~0x8) | ((LCD_LCD_CONTROL_TYPE_##v) << 3)); } while(0)
  #define LCD_LCD_CONTROL_TYPE_SETVAL(x, v)        do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define LCD_LCD_CONTROL_TYPE_GET(x)              (((x) >> 3) & 0x1)
/** Each frame addresses each COM pin only once with a balanced (DC=0) waveform. */
    #define LCD_LCD_CONTROL_TYPE_A                   0x00000000
/** Each frame addresses each COM pin twice in sequence with a positive and negative waveform that together are balanced (DC=0). */
    #define LCD_LCD_CONTROL_TYPE_B                   0x00000001
/** Driving mode configuration Default Value: 0 @multiple */
  #define LCD_LCD_CONTROL_OP_MODE(v)               ((LCD_LCD_CONTROL_OP_MODE_##v) << 4)
  #define LCD_LCD_CONTROL_OP_MODE_SET(x, v)        do { (x) = (((x) & ~0x10) | ((LCD_LCD_CONTROL_OP_MODE_##v) << 4)); } while(0)
  #define LCD_LCD_CONTROL_OP_MODE_SETVAL(x, v)     do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define LCD_LCD_CONTROL_OP_MODE_GET(x)           (((x) >> 4) & 0x1)
/** PWM Mode */
    #define LCD_LCD_CONTROL_OP_MODE_PWM              0x00000000
/** Digital Correlation Mode */
    #define LCD_LCD_CONTROL_OP_MODE_CORRELATION      0x00000001
/** PWM bias selection Default Value: 0 @multiple */
  #define LCD_LCD_CONTROL_BIAS(v)                  ((LCD_LCD_CONTROL_BIAS_##v) << 5)
  #define LCD_LCD_CONTROL_BIAS_SET(x, v)           do { (x) = (((x) & ~0x60) | ((LCD_LCD_CONTROL_BIAS_##v) << 5)); } while(0)
  #define LCD_LCD_CONTROL_BIAS_SETVAL(x, v)        do { (x) = (((x) & ~0x60) | ((v) << 5)); } while(0)
  #define LCD_LCD_CONTROL_BIAS_GET(x)              (((x) >> 5) & 0x3)
/** 1/2 Bias */
    #define LCD_LCD_CONTROL_BIAS_HALF                0x00000000
/** 1/3 Bias */
    #define LCD_LCD_CONTROL_BIAS_THIRD               0x00000001
/** 1/4 Bias (not supported by LS generator) */
    #define LCD_LCD_CONTROL_BIAS_FOURTH              0x00000002
/** 1/5 Bias (not supported by LS generator) */
    #define LCD_LCD_CONTROL_BIAS_FIFTH               0x00000003
/** The number of COM connections minus 2. @multiple */
  #define LCD_LCD_CONTROL_COM_NUM_MIN_2(v)         ((v) << 8)
  #define LCD_LCD_CONTROL_COM_NUM_MIN_2_SET(x, v)  do { (x) = (((x) & ~0xf00) | ((v) << 8)); } while(0)
  #define LCD_LCD_CONTROL_COM_NUM_MIN_2_GET(x)     (((x) >> 8) & 0xf)
/** LS enable status bit. This bit is a copy of LS_EN that is synchronized to the
   low speed clock domain and back to the system clock domain. Firmware can use
   this bit to observe whether LS_EN has taken effect in the low speed clock
   domain. Firmware should never change the con- figuration for the LS generator
   without ensuring this bit is 0. The following procedure should be followed to
   disable the LS generator: 1. If LS_EN=0 we are done. Exit the procedure. 2.
   Check that LS_EN_STAT=1. If not, wait until it is. This will catch the case of
   a recent enable (LS_EN=1) that has not taken effect yet. 3. Set LS_EN=0. 4.
   Wait until LS_EN_STAT=0. @multiple */
  #define LCD_LCD_CONTROL_LS_EN_STAT               0x80000000

/** Retention: Not Retained @multiple */
#define LCD_LCD_DATA_ADDR(ridx)                      (0x00000100 + (ridx) * 4)
#define LCD_LCD_DATA_COUNT                           8
#define LCD_LCD_DATA_MASK                            0xffffffff
/** Bits [4i+3:4i] represent the pin data for pin [i] for COMS 1-4 (COM1 is lsb).
   @multiple */
  #define LCD_LCD_DATA_DATA(v)                     ((v) << 0)
  #define LCD_LCD_DATA_DATA_SET(x, v)              do { (x) = (((x) & ~0xffffffff) | ((v) << 0)); } while(0)
  #define LCD_LCD_DATA_DATA_GET(x)                 (((x) >> 0) & 0xffffffff)

#endif

