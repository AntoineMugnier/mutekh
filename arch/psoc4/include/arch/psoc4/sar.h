/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -I sar.bf -O sar.h -o cdefs cdefs_use_reg_mask=1                      \
     cdefs_use_field_setval=1
*/

#ifndef _SAR_BFGEN_DEFS_
#define _SAR_BFGEN_DEFS_

#define SAR_CTRL_ADDR                                0x00000000
#define SAR_CTRL_MASK                                0xcb1feef0
/** SARADC internal VREF selection. @multiple */
  #define SAR_CTRL_VREF_SEL(v)                     ((SAR_CTRL_VREF_SEL_##v) << 4)
  #define SAR_CTRL_VREF_SEL_SET(x, v)              do { (x) = (((x) & ~0x70) | ((SAR_CTRL_VREF_SEL_##v) << 4)); } while(0)
  #define SAR_CTRL_VREF_SEL_SETVAL(x, v)           do { (x) = (((x) & ~0x70) | ((v) << 4)); } while(0)
  #define SAR_CTRL_VREF_SEL_GET(x)                 (((x) >> 4) & 0x7)
/** VREF0 from PRB (VREF buffer on) */
    #define SAR_CTRL_VREF_SEL_VREF0                  0x00000000
/** VREF1 from PRB (VREF buffer on) */
    #define SAR_CTRL_VREF_SEL_VREF1                  0x00000001
/** VREF2 from PRB (VREF buffer on) */
    #define SAR_CTRL_VREF_SEL_VREF2                  0x00000002
/** VREF from AROUTE (VREF buffer on) */
    #define SAR_CTRL_VREF_SEL_VREF_AROUTE            0x00000003
/** 1.024V from BandGap (VREF buffer on) */
    #define SAR_CTRL_VREF_SEL_VBGR                   0x00000004
/** External precision Vref direct from a pin (low impedance path). */
    #define SAR_CTRL_VREF_SEL_VREF_EXT               0x00000005
/** Vdda/2  (VREF buffer on) */
    #define SAR_CTRL_VREF_SEL_VDDA_DIV_2             0x00000006
/** Vdda. */
    #define SAR_CTRL_VREF_SEL_VDDA                   0x00000007
/** VREF bypass cap enable for when VREF buffer is on @multiple */
  #define SAR_CTRL_VREF_BYP_CAP_EN                 0x00000080
/** SARADC internal NEG selection for Single ended conversion @multiple */
  #define SAR_CTRL_NEG_SEL(v)                      ((SAR_CTRL_NEG_SEL_##v) << 9)
  #define SAR_CTRL_NEG_SEL_SET(x, v)               do { (x) = (((x) & ~0xe00) | ((SAR_CTRL_NEG_SEL_##v) << 9)); } while(0)
  #define SAR_CTRL_NEG_SEL_SETVAL(x, v)            do { (x) = (((x) & ~0xe00) | ((v) << 9)); } while(0)
  #define SAR_CTRL_NEG_SEL_GET(x)                  (((x) >> 9) & 0x7)
/** NEG input of SARADC is connected to "vssa_kelvin", gives more precision around zero. Note this opens both SARADC internal switches, therefore use this value to insert a break-beforemake cycle on those switches when SWITCH_DISABLE is high. */
    #define SAR_CTRL_NEG_SEL_VSSA_KELVIN             0x00000000
/** NEG input of SARADC is connected to VSSA in AROUTE close to the SARADC */
    #define SAR_CTRL_NEG_SEL_ART_VSSA                0x00000001
/** NEG input of SARADC is connected to P1 pin of SARMUX */
    #define SAR_CTRL_NEG_SEL_P1                      0x00000002
/** NEG input of SARADC is connected to P3 pin of SARMUX */
    #define SAR_CTRL_NEG_SEL_P3                      0x00000003
/** NEG input of SARADC is connected to P5 pin of SARMUX */
    #define SAR_CTRL_NEG_SEL_P5                      0x00000004
/** NEG input of SARADC is connected to P7 pin of SARMUX */
    #define SAR_CTRL_NEG_SEL_P7                      0x00000005
/** NEG input of SARADC is connected to an ACORE in AROUTE */
    #define SAR_CTRL_NEG_SEL_ACORE                   0x00000006
/** NEG input of SARADC is shorted with VREF input of SARADC. */
    #define SAR_CTRL_NEG_SEL_VREF                    0x00000007
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for VREF to NEG switch. @multiple */
  #define SAR_CTRL_HW_CTRL_NEGVREF                 0x00002000
/** VREF buffer low power mode. @multiple */
  #define SAR_CTRL_PWR_CTRL_VREF(v)                ((SAR_CTRL_PWR_CTRL_VREF_##v) << 14)
  #define SAR_CTRL_PWR_CTRL_VREF_SET(x, v)         do { (x) = (((x) & ~0xc000) | ((SAR_CTRL_PWR_CTRL_VREF_##v) << 14)); } while(0)
  #define SAR_CTRL_PWR_CTRL_VREF_SETVAL(x, v)      do { (x) = (((x) & ~0xc000) | ((v) << 14)); } while(0)
  #define SAR_CTRL_PWR_CTRL_VREF_GET(x)            (((x) >> 14) & 0x3)
/** normal power (default), bypass cap, max clk_sar is 18MHz. */
    #define SAR_CTRL_PWR_CTRL_VREF_NORMAL_PWR        0x00000000
/** deprecated */
    #define SAR_CTRL_PWR_CTRL_VREF_HALF_PWR          0x00000001
/** Invalid for PRoC BLE otherwise 2X power, no bypass cap, max clk_sar is 1.8MHz */
    #define SAR_CTRL_PWR_CTRL_VREF_THIRD_PWR         0x00000002
/** deprecated */
    #define SAR_CTRL_PWR_CTRL_VREF_QUARTER_PWR       0x00000003
/** Spare controls, not yet designated, for late changes done with an ECO
   @multiple */
  #define SAR_CTRL_SPARE(v)                        ((v) << 16)
  #define SAR_CTRL_SPARE_SET(x, v)                 do { (x) = (((x) & ~0xf0000) | ((v) << 16)); } while(0)
  #define SAR_CTRL_SPARE_GET(x)                    (((x) >> 16) & 0xf)
/** SARADC internal pump: 0=disabled: pump output is VDDA, 1=enabled: pump output
   is boosted. @multiple */
  #define SAR_CTRL_BOOSTPUMP_EN                    0x00100000
/** SARADC low power mode. @multiple */
  #define SAR_CTRL_ICONT_LV(v)                     ((SAR_CTRL_ICONT_LV_##v) << 24)
  #define SAR_CTRL_ICONT_LV_SET(x, v)              do { (x) = (((x) & ~0x3000000) | ((SAR_CTRL_ICONT_LV_##v) << 24)); } while(0)
  #define SAR_CTRL_ICONT_LV_SETVAL(x, v)           do { (x) = (((x) & ~0x3000000) | ((v) << 24)); } while(0)
  #define SAR_CTRL_ICONT_LV_GET(x)                 (((x) >> 24) & 0x3)
/** normal power (default), max clk_sar is 18MHz. */
    #define SAR_CTRL_ICONT_LV_NORMAL_PWR             0x00000000
/** 1/2 power mode, max clk_sar is 9MHz. */
    #define SAR_CTRL_ICONT_LV_HALF_PWR               0x00000001
/** 1.333 power mode, max clk_sar is 18MHz. */
    #define SAR_CTRL_ICONT_LV_MORE_PWR               0x00000002
/** 1/4 power mode, max clk_sar is 4.5MHz. */
    #define SAR_CTRL_ICONT_LV_QUARTER_PWR            0x00000003
/** SARMUX IP remains enabled during DeepSleep power mode (if ENABLED) @multiple
   */
  #define SAR_CTRL_DEEPSLEEP_ON                    0x08000000
/** Disable SAR sequencer from enabling routing switches (note firmware can
   always close switch- es independent of this control) @multiple */
  #define SAR_CTRL_SWITCH_DISABLE                  0x40000000
/** Before enabling always make sure the SAR is idle (STATUS.BUSY==0) @multiple
   */
  #define SAR_CTRL_ENABLED                         0x80000000

#define SAR_SAMPLE_CTRL_ADDR                         0x00000004
#define SAR_SAMPLE_CTRL_MASK                         0x000100ff
/** Conversion resolution for channels that have sub-resolution enabled
   (RESOLUTION=1) (other- wise resolution is 12-bit). @multiple */
  #define SAR_SAMPLE_CTRL_SUB_RESOLUTION(v)        ((SAR_SAMPLE_CTRL_SUB_RESOLUTION_##v) << 0)
  #define SAR_SAMPLE_CTRL_SUB_RESOLUTION_SET(x, v) do { (x) = (((x) & ~0x1) | ((SAR_SAMPLE_CTRL_SUB_RESOLUTION_##v) << 0)); } while(0)
  #define SAR_SAMPLE_CTRL_SUB_RESOLUTION_SETVAL(x, v) do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define SAR_SAMPLE_CTRL_SUB_RESOLUTION_GET(x)    (((x) >> 0) & 0x1)
/** 8-bit. */
    #define SAR_SAMPLE_CTRL_SUB_RESOLUTION_8B        0x00000000
/** 10-bit. */
    #define SAR_SAMPLE_CTRL_SUB_RESOLUTION_10B       0x00000001
/** Left align data in data[15:0], default data is right aligned in data[11:0],
   with sign extension to 16 bits if the channel is differential. @multiple */
  #define SAR_SAMPLE_CTRL_LEFT_ALIGN               0x00000002
/** Output data from a single ended conversion as a signed value Zero or sign
   extension is done if needed. @multiple */
  #define SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED      0x00000004
/** Output data from a differential conversion as a signed value. Zero or sign
   extension is done if needed. @multiple */
  #define SAR_SAMPLE_CTRL_DIFFERENTIAL_SIGNED      0x00000008
/** Averaging Count for channels that have over sampling enabled (AVG_EN). A
   channel will be sampled back to back 2 ^ (AVG_CNT + 1) (2..256) times before
   the result is stored and the next enabled channel is sampled (1st order
   accumulate and dump filter). If shifting is not enabled (AVG_SHIFT = 0) then
   the result is forced to shift right so that is fits in 16 bits, so right shift
   is done by max(0, AVG_CNT - 3). @multiple */
  #define SAR_SAMPLE_CTRL_AVG_CNT(v)               ((v) << 4)
  #define SAR_SAMPLE_CTRL_AVG_CNT_SET(x, v)        do { (x) = (((x) & ~0x70) | ((v) << 4)); } while(0)
  #define SAR_SAMPLE_CTRL_AVG_CNT_GET(x)           (((x) >> 4) & 0x7)
/** Averaging shifting: after averaging the result is shifted right to fit in the
   sample resolution. For averaging the sample resolution is the highest
   resolution allowed by wounding. @multiple */
  #define SAR_SAMPLE_CTRL_AVG_SHIFT                0x00000080
/** Continuously scan enabled channels, ignore triggers. Else, wait for next
   FW_TRIGGER (one shot) before scanning enabled channels. @multiple */
  #define SAR_SAMPLE_CTRL_CONTINUOUS               0x00010000

/** Sample time specification ST0 and ST1 @multiple */
#define SAR_SAMPLE_TIME01_ADDR                       0x00000010
#define SAR_SAMPLE_TIME01_MASK                       0x03ff03ff
/** Sample time0 (aperture) in ADC clock cycles. Note that actual sample time is
   half a clock less than specified here. The minimum sample time is 194ns, which
   is 3.5 cycles (4 in this field) with an 18MHz clock. Minimum legal value in
   this register is 2. @multiple */
  #define SAR_SAMPLE_TIME01_SAMPLE_TIME0(v)        ((v) << 0)
  #define SAR_SAMPLE_TIME01_SAMPLE_TIME0_SET(x, v) do { (x) = (((x) & ~0x3ff) | ((v) << 0)); } while(0)
  #define SAR_SAMPLE_TIME01_SAMPLE_TIME0_GET(x)    (((x) >> 0) & 0x3ff)
/** Sample time1 @multiple */
  #define SAR_SAMPLE_TIME01_SAMPLE_TIME1(v)        ((v) << 16)
  #define SAR_SAMPLE_TIME01_SAMPLE_TIME1_SET(x, v) do { (x) = (((x) & ~0x3ff0000) | ((v) << 16)); } while(0)
  #define SAR_SAMPLE_TIME01_SAMPLE_TIME1_GET(x)    (((x) >> 16) & 0x3ff)

/** Sample time specification ST2 and ST3 @multiple */
#define SAR_SAMPLE_TIME23_ADDR                       0x00000014
#define SAR_SAMPLE_TIME23_MASK                       0x03ff03ff
/** Sample time2 @multiple */
  #define SAR_SAMPLE_TIME23_SAMPLE_TIME2(v)        ((v) << 0)
  #define SAR_SAMPLE_TIME23_SAMPLE_TIME2_SET(x, v) do { (x) = (((x) & ~0x3ff) | ((v) << 0)); } while(0)
  #define SAR_SAMPLE_TIME23_SAMPLE_TIME2_GET(x)    (((x) >> 0) & 0x3ff)
/** Sample time3 @multiple */
  #define SAR_SAMPLE_TIME23_SAMPLE_TIME3(v)        ((v) << 16)
  #define SAR_SAMPLE_TIME23_SAMPLE_TIME3_SET(x, v) do { (x) = (((x) & ~0x3ff0000) | ((v) << 16)); } while(0)
  #define SAR_SAMPLE_TIME23_SAMPLE_TIME3_GET(x)    (((x) >> 16) & 0x3ff)

#define SAR_RANGE_THRES_ADDR                         0x00000018
#define SAR_RANGE_THRES_MASK                         0xffffffff
/** Low threshold for range detect. @multiple */
  #define SAR_RANGE_THRES_RANGE_LOW(v)             ((v) << 0)
  #define SAR_RANGE_THRES_RANGE_LOW_SET(x, v)      do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SAR_RANGE_THRES_RANGE_LOW_GET(x)         (((x) >> 0) & 0xffff)
/** High threshold for range detect. @multiple */
  #define SAR_RANGE_THRES_RANGE_HIGH(v)            ((v) << 16)
  #define SAR_RANGE_THRES_RANGE_HIGH_SET(x, v)     do { (x) = (((x) & ~0xffff0000) | ((v) << 16)); } while(0)
  #define SAR_RANGE_THRES_RANGE_HIGH_GET(x)        (((x) >> 16) & 0xffff)

#define SAR_RANGE_COND_ADDR                          0x0000001c
#define SAR_RANGE_COND_MASK                          0xc0000000
/** Range condition select. @multiple */
  #define SAR_RANGE_COND_RANGE_COND(v)             ((SAR_RANGE_COND_RANGE_COND_##v) << 30)
  #define SAR_RANGE_COND_RANGE_COND_SET(x, v)      do { (x) = (((x) & ~0xc0000000) | ((SAR_RANGE_COND_RANGE_COND_##v) << 30)); } while(0)
  #define SAR_RANGE_COND_RANGE_COND_SETVAL(x, v)   do { (x) = (((x) & ~0xc0000000) | ((v) << 30)); } while(0)
  #define SAR_RANGE_COND_RANGE_COND_GET(x)         (((x) >> 30) & 0x3)
/** result < RANGE_LOW */
    #define SAR_RANGE_COND_RANGE_COND_BELOW          0x00000000
/** RANGE_LOW <= result < RANGE_HIGH */
    #define SAR_RANGE_COND_RANGE_COND_INSIDE         0x00000001
/** RANGE_HIGH <= result */
    #define SAR_RANGE_COND_RANGE_COND_ABOVE          0x00000002
/** result < RANGE_LOW || RANGE_HIGH <= result */
    #define SAR_RANGE_COND_RANGE_COND_OUTSIDE        0x00000003

/** Enable bits for the channels @multiple */
#define SAR_CHAN_EN_ADDR                             0x00000020
#define SAR_CHAN_EN_MASK                             0x0000ffff
/** Channel enable. @multiple */
  #define SAR_CHAN_EN_CHAN_EN_COUNT                16
  #define SAR_CHAN_EN_CHAN_EN(fidx)                (0x00000001 << ((fidx)))

#define SAR_START_CTRL_ADDR                          0x00000024
#define SAR_START_CTRL_MASK                          0x00000001
/** When firmware writes a 1 here it will trigger the next scan of enabled
   channels, hardware clears this bit when the scan started with this trigger is
   completed. If scanning continuously the trigger is ignored and hardware clears
   this bit after the next scan is done. This bit is also cleared when the SAR is
   disabled. @multiple */
  #define SAR_START_CTRL_FW_TRIGGER                0x00000001

#define SAR_DFT_CTRL_ADDR                            0x00000030
#define SAR_DFT_CTRL_MASK                            0xbf7f0003
/** DFT control: Control for delay circuits on sampling phase, =1 doubes the
   non-overlap delay @multiple */
  #define SAR_DFT_CTRL_DLY_INC                     0x00000001
/** DFT control for getting higher input impedance, must be 1 (0 is deprecated)
   @multiple */
  #define SAR_DFT_CTRL_HIZ                         0x00000002
/** DFT control for preamp inputs @multiple */
  #define SAR_DFT_CTRL_DFT_INC(v)                  ((v) << 16)
  #define SAR_DFT_CTRL_DFT_INC_SET(x, v)           do { (x) = (((x) & ~0xf0000) | ((v) << 16)); } while(0)
  #define SAR_DFT_CTRL_DFT_INC_GET(x)              (((x) >> 16) & 0xf)
/** DFT control for preamp outputs @multiple */
  #define SAR_DFT_CTRL_DFT_OUTC(v)                 ((v) << 20)
  #define SAR_DFT_CTRL_DFT_OUTC_SET(x, v)          do { (x) = (((x) & ~0x700000) | ((v) << 20)); } while(0)
  #define SAR_DFT_CTRL_DFT_OUTC_GET(x)             (((x) >> 20) & 0x7)
/** DFT bits for DAC array @multiple */
  #define SAR_DFT_CTRL_SEL_CSEL_DFT(v)             ((v) << 24)
  #define SAR_DFT_CTRL_SEL_CSEL_DFT_SET(x, v)      do { (x) = (((x) & ~0xf000000) | ((v) << 24)); } while(0)
  #define SAR_DFT_CTRL_SEL_CSEL_DFT_GET(x)         (((x) >> 24) & 0xf)
/** Mux select signal for DAC control @multiple */
  #define SAR_DFT_CTRL_EN_CSEL_DFT                 0x10000000
/** Delay Control Enable for latch. @multiple */
  #define SAR_DFT_CTRL_DCEN(v)                     ((SAR_DFT_CTRL_DCEN_##v) << 29)
  #define SAR_DFT_CTRL_DCEN_SET(x, v)              do { (x) = (((x) & ~0x20000000) | ((SAR_DFT_CTRL_DCEN_##v) << 29)); } while(0)
  #define SAR_DFT_CTRL_DCEN_SETVAL(x, v)           do { (x) = (((x) & ~0x20000000) | ((v) << 29)); } while(0)
  #define SAR_DFT_CTRL_DCEN_GET(x)                 (((x) >> 29) & 0x1)
/** Doubles the latch enable time. */
    #define SAR_DFT_CTRL_DCEN_DOUBLE                 0x00000000
/** Normal latch enable time (default). */
    #define SAR_DFT_CTRL_DCEN_NORMAL                 0x00000001
/** During deepsleep/ hibernate mode keep SARMUX active, i.e. do not open all
   switches (discon- nect), to be used for ADFT @multiple */
  #define SAR_DFT_CTRL_ADFT_OVERRIDE               0x80000000

#define SAR_CHAN_CONFIG_ADDR(ridx)                   (0x00000080 + (ridx) * 4)
#define SAR_CHAN_CONFIG_COUNT                        16
#define SAR_CHAN_CONFIG_MASK                         0x00003777
/** Address of the pin to be sampled by this channel. If differential is enabled
   then PIN_ADDR[0] is ignored and considered to be 0, i.e. PIN_ADDR points to
   the even pin of a pin pair. For differen- tial the even pin of the pair is
   connected to Vplus and the odd pin of the pair is connected to Vmi- nus.
   @multiple */
  #define SAR_CHAN_CONFIG_PIN_ADDR(v)              ((v) << 0)
  #define SAR_CHAN_CONFIG_PIN_ADDR_SET(x, v)       do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define SAR_CHAN_CONFIG_PIN_ADDR_GET(x)          (((x) >> 0) & 0x7)
/** Address of the port that contains the pin to be sampled by this channel.
   @multiple */
  #define SAR_CHAN_CONFIG_PORT_ADDR(v)             ((SAR_CHAN_CONFIG_PORT_ADDR_##v) << 4)
  #define SAR_CHAN_CONFIG_PORT_ADDR_SET(x, v)      do { (x) = (((x) & ~0x70) | ((SAR_CHAN_CONFIG_PORT_ADDR_##v) << 4)); } while(0)
  #define SAR_CHAN_CONFIG_PORT_ADDR_SETVAL(x, v)   do { (x) = (((x) & ~0x70) | ((v) << 4)); } while(0)
  #define SAR_CHAN_CONFIG_PORT_ADDR_GET(x)         (((x) >> 4) & 0x7)
/** SARMUX pins. */
    #define SAR_CHAN_CONFIG_PORT_ADDR_SARMUX         0x00000000
/** CTB0 */
    #define SAR_CHAN_CONFIG_PORT_ADDR_CTB0           0x00000001
/** CTB1 */
    #define SAR_CHAN_CONFIG_PORT_ADDR_CTB1           0x00000002
/** CTB2 */
    #define SAR_CHAN_CONFIG_PORT_ADDR_CTB2           0x00000003
/** CTB3 */
    #define SAR_CHAN_CONFIG_PORT_ADDR_CTB3           0x00000004
/** AROUTE virtual port2 (VPORT2) */
    #define SAR_CHAN_CONFIG_PORT_ADDR_AROUTE_VIRT2   0x00000005
/** AROUTE virtual port1 (VPORT1) */
    #define SAR_CHAN_CONFIG_PORT_ADDR_AROUTE_VIRT1   0x00000006
/** SARMUX virtual port (VPORT0) */
    #define SAR_CHAN_CONFIG_PORT_ADDR_SARMUX_VIRT    0x00000007
/** Differential enable for this channel. @multiple */
  #define SAR_CHAN_CONFIG_DIFFERENTIAL_EN          0x00000100
/** Resolution for this channel. When AVG_EN is set this bit is ignored and
   always a 12-bit resolu- tion (or highest resolution allowed by wounding) is
   used for this channel. @multiple */
  #define SAR_CHAN_CONFIG_RESOLUTION(v)            ((SAR_CHAN_CONFIG_RESOLUTION_##v) << 9)
  #define SAR_CHAN_CONFIG_RESOLUTION_SET(x, v)     do { (x) = (((x) & ~0x200) | ((SAR_CHAN_CONFIG_RESOLUTION_##v) << 9)); } while(0)
  #define SAR_CHAN_CONFIG_RESOLUTION_SETVAL(x, v)  do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
  #define SAR_CHAN_CONFIG_RESOLUTION_GET(x)        (((x) >> 9) & 0x1)
/** The maximum resolution is used for this channel (maximum resolution depends on wounding). */
    #define SAR_CHAN_CONFIG_RESOLUTION_MAXRES        0x00000000
/** The resolution specified by SUB_RESOLUTION in the SAMPLE_CTRL register is used for this channel. */
    #define SAR_CHAN_CONFIG_RESOLUTION_SUBRES        0x00000001
/** Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings
   are used for sampling the addressed pin(s) @multiple */
  #define SAR_CHAN_CONFIG_AVG_EN                   0x00000400
/** Sample time select: select which of the 4 global sample times to use for this
   channel @multiple */
  #define SAR_CHAN_CONFIG_SAMPLE_TIME_SEL(v)       ((v) << 12)
  #define SAR_CHAN_CONFIG_SAMPLE_TIME_SEL_SET(x, v) do { (x) = (((x) & ~0x3000) | ((v) << 12)); } while(0)
  #define SAR_CHAN_CONFIG_SAMPLE_TIME_SEL_GET(x)   (((x) >> 12) & 0x3)

#define SAR_CHAN_WORK_ADDR(ridx)                     (0x00000100 + (ridx) * 4)
#define SAR_CHAN_WORK_COUNT                          16
#define SAR_CHAN_WORK_MASK                           0x8000ffff
/** SAR conversion working data of the channel. The data is written here right
   after sampling this channel. @multiple */
  #define SAR_CHAN_WORK_WORK(v)                    ((v) << 0)
  #define SAR_CHAN_WORK_WORK_SET(x, v)             do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SAR_CHAN_WORK_WORK_GET(x)                (((x) >> 0) & 0xffff)
/** mirror bit of corresponding bit in CHAN_WORK_VALID register @multiple */
  #define SAR_CHAN_WORK_VALID                      0x80000000

#define SAR_CHAN_RESULT_ADDR(ridx)                   (0x00000180 + (ridx) * 4)
#define SAR_CHAN_RESULT_COUNT                        16
#define SAR_CHAN_RESULT_MASK                         0xe000ffff
/** SAR conversion result of the channel. The data is copied here from the WORK
   field after all en- abled channels in this scan have been sampled. @multiple
   */
  #define SAR_CHAN_RESULT_RESULT(v)                ((v) << 0)
  #define SAR_CHAN_RESULT_RESULT_SET(x, v)         do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SAR_CHAN_RESULT_RESULT_GET(x)            (((x) >> 0) & 0xffff)
/** mirror bit of corresponding bit in SATURATE_INTR register @multiple */
  #define SAR_CHAN_RESULT_SATURATE_INTR            0x20000000
/** mirror bit of corresponding bit in RANGE_INTR register @multiple */
  #define SAR_CHAN_RESULT_RANGE_INTR               0x40000000
/** mirror bit of corresponding bit in CHAN_RESULT_VALID register @multiple */
  #define SAR_CHAN_RESULT_VALID                    0x80000000

#define SAR_CHAN_WORK_VALID_ADDR                     0x00000200
#define SAR_CHAN_WORK_VALID_MASK                     0x0000ffff
/** If set the corresponding WORK data is valid, i.e. was already sampled during
   the current scan. @multiple */
  #define SAR_CHAN_WORK_VALID_VALID_COUNT          16
  #define SAR_CHAN_WORK_VALID_VALID(fidx)          (0x00000001 << ((fidx)))

#define SAR_CHAN_RESULT_VALID_ADDR                   0x00000204
#define SAR_CHAN_RESULT_VALID_MASK                   0x0000ffff
/** If set the corresponding RESULT data is valid, i.e. was sampled during the
   last scan. @multiple */
  #define SAR_CHAN_RESULT_VALID_VALID_COUNT        16
  #define SAR_CHAN_RESULT_VALID_VALID(fidx)        (0x00000001 << ((fidx)))

#define SAR_STATUS_ADDR                              0x00000208
#define SAR_STATUS_MASK                              0xc000001f
/** current channel being sampled (channel 16 indicates the injection channel),
   only valid if BUSY. @multiple */
  #define SAR_STATUS_CUR_CHAN(v)                   ((v) << 0)
  #define SAR_STATUS_CUR_CHAN_SET(x, v)            do { (x) = (((x) & ~0x1f) | ((v) << 0)); } while(0)
  #define SAR_STATUS_CUR_CHAN_GET(x)               (((x) >> 0) & 0x1f)
/** the current switch status, including sequencer controls, of the switch in the
   SARADC that shorts NEG with VREF input (see NEG_SEL). @multiple */
  #define SAR_STATUS_SW_VREF_NEG                   0x40000000
/** If high then the SAR is busy with a conversion. This bit is always high when
   CONTINUOUS is set. Firmware should wait for this bit to be low before putting
   the SAR in power down. @multiple */
  #define SAR_STATUS_BUSY                          0x80000000

/** Current averaging status (for debug) @multiple */
#define SAR_AVG_STAT_ADDR                            0x0000020c
#define SAR_AVG_STAT_MASK                            0xff0fffff
/** the current value of the averaging accumulator @multiple */
  #define SAR_AVG_STAT_CUR_AVG_ACCU(v)             ((v) << 0)
  #define SAR_AVG_STAT_CUR_AVG_ACCU_SET(x, v)      do { (x) = (((x) & ~0xfffff) | ((v) << 0)); } while(0)
  #define SAR_AVG_STAT_CUR_AVG_ACCU_GET(x)         (((x) >> 0) & 0xfffff)
/** the current value of the averaging counter. Note that the value shown is
   updated after the sam- pling time and therefore runs ahead of the accumulator
   update. @multiple */
  #define SAR_AVG_STAT_CUR_AVG_CNT(v)              ((v) << 24)
  #define SAR_AVG_STAT_CUR_AVG_CNT_SET(x, v)       do { (x) = (((x) & ~0xff000000) | ((v) << 24)); } while(0)
  #define SAR_AVG_STAT_CUR_AVG_CNT_GET(x)          (((x) >> 24) & 0xff)

#define SAR_INTR_ADDR                                0x00000210
#define SAR_INTR_MASK                                0x000000f7
/** End Of Scan Interrupt: hardware sets this interrupt after completing a scan
   of all the enabled channels. Write with '1' to clear bit. @multiple */
  #define SAR_INTR_EOS                             0x00000001
/** Overflow Interrupt: hardware sets this interrupt when it sets a new EOS_INTR
   while that bit was not yet cleared by the firmware. Write with '1' to clear
   bit. @multiple */
  #define SAR_INTR_OVERFLOW                        0x00000002
/** Firmware Collision Interrupt: hardware sets this interrupt when FW_TRIGGER is
   asserted while the SAR is BUSY. Raising this interrupt is delayed to when the
   scan caused by the FW_TRIGGER has been completed, i.e. not when the preceeding
   scan with which this trigger collided is completed. When this interrupt is set
   it implies that the channels were sampled later than was intended (jitter).
   Write with '1' to clear bit. @multiple */
  #define SAR_INTR_FW_COLLISION                    0x00000004
/** Injection End of Conversion Interrupt: hardware sets this interrupt after
   completing the conver- sion for the injection channel (irrespective of if
   tailgating was used). Write with '1' to clear bit. @multiple */
  #define SAR_INTR_INJ_EOC                         0x00000010
/** Injection Saturation Interrupt: hardware sets this interrupt if an injection
   conversion result (before averaging) is either 0x000 or 0xFFF (for 12-bit
   resolution), this is an indication that the ADC likely saturated. Write with
   '1' to clear bit. @multiple */
  #define SAR_INTR_INJ_SATURATE                    0x00000020
/** Injection Range detect Interrupt: hardware sets this interrupt if the
   injection conversion result (af- ter averaging) met the condition specified by
   the RANGE registers. Write with '1' to clear bit. @multiple */
  #define SAR_INTR_INJ_RANGE                       0x00000040
/** Injection Collision Interrupt: hardware sets this interrupt when the
   injection trigger signal is as- serted (INJ_START_EN==1 && INJ_TAILGATING==0)
   while the SAR is BUSY. Raising this in- terrupt is delayed to when the
   sampling of the injection channel has been completed, i.e. not when the
   preceeding scan with which this trigger collided is completed. When this
   interrupt is set it implies that the injection channel was sampled later than
   was intended. Write with '1' to clear bit. @multiple */
  #define SAR_INTR_INJ_COLLISION                   0x00000080

#define SAR_INTR_SET_ADDR                            0x00000214
#define SAR_INTR_SET_MASK                            0x000000ff
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SAR_INTR_SET_EOS                         0x00000001
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SAR_INTR_SET_OVERFLOW                    0x00000002
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SAR_INTR_SET_FW_COLLISION                0x00000004
/** Reserved @multiple */
  #define SAR_INTR_SET_RESERVED                    0x00000008
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SAR_INTR_SET_INJ_EOC                     0x00000010
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SAR_INTR_SET_INJ_SATURATE                0x00000020
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SAR_INTR_SET_INJ_RANGE                   0x00000040
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SAR_INTR_SET_INJ_COLLISION               0x00000080

#define SAR_INTR_MASK_ADDR                           0x00000218
#define SAR_INTR_MASK_MASK                           0x000000ff
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SAR_INTR_MASK_EOS                        0x00000001
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SAR_INTR_MASK_OVERFLOW                   0x00000002
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SAR_INTR_MASK_FW_COLLISION               0x00000004
/** Reserved @multiple */
  #define SAR_INTR_MASK_RESERVED                   0x00000008
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SAR_INTR_MASK_INJ_EOC                    0x00000010
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SAR_INTR_MASK_INJ_SATURATE               0x00000020
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SAR_INTR_MASK_INJ_RANGE                  0x00000040
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SAR_INTR_MASK_INJ_COLLISION              0x00000080

#define SAR_INTR_MASKED_ADDR                         0x0000021c
#define SAR_INTR_MASKED_MASK                         0x000000ff
/** Logical and of corresponding request and mask bits. @multiple */
  #define SAR_INTR_MASKED_EOS                      0x00000001
/** Logical and of corresponding request and mask bits. @multiple */
  #define SAR_INTR_MASKED_OVERFLOW                 0x00000002
/** Logical and of corresponding request and mask bits. @multiple */
  #define SAR_INTR_MASKED_FW_COLLISION             0x00000004
/** Reserved @multiple */
  #define SAR_INTR_MASKED_RESERVED                 0x00000008
/** Logical and of corresponding request and mask bits. @multiple */
  #define SAR_INTR_MASKED_INJ_EOC                  0x00000010
/** Logical and of corresponding request and mask bits. @multiple */
  #define SAR_INTR_MASKED_INJ_SATURATE             0x00000020
/** Logical and of corresponding request and mask bits. @multiple */
  #define SAR_INTR_MASKED_INJ_RANGE                0x00000040
/** Logical and of corresponding request and mask bits. @multiple */
  #define SAR_INTR_MASKED_INJ_COLLISION            0x00000080

#define SAR_SATURATE_INTR_ADDR                       0x00000220
#define SAR_SATURATE_INTR_MASK                       0x0000ffff
/** Saturate Interrupt: hardware sets this interrupt for each channel if a
   conversion result (before av- eraging) of that channel is either 0x000 or
   0xFFF (for 12-bit resolution), this is an indication that the ADC likely
   saturated. Write with '1' to clear bit. @multiple */
  #define SAR_SATURATE_INTR_SATURATE_COUNT         16
  #define SAR_SATURATE_INTR_SATURATE(fidx)         (0x00000001 << ((fidx)))

#define SAR_SATURATE_INTR_SET_ADDR                   0x00000224
#define SAR_SATURATE_INTR_SET_MASK                   0x0000ffff
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SAR_SATURATE_INTR_SET_SATURATE_COUNT     16
  #define SAR_SATURATE_INTR_SET_SATURATE(fidx)     (0x00000001 << ((fidx)))

#define SAR_SATURATE_INTR_MASK_ADDR                  0x00000228
#define SAR_SATURATE_INTR_MASK_MASK                  0x0000ffff
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SAR_SATURATE_INTR_MASK_SATURATE_COUNT    16
  #define SAR_SATURATE_INTR_MASK_SATURATE(fidx)    (0x00000001 << ((fidx)))

#define SAR_SATURATE_INTR_MASKED_ADDR                0x0000022c
#define SAR_SATURATE_INTR_MASKED_MASK                0x0000ffff
/** Logical and of corresponding request and mask bits. @multiple */
  #define SAR_SATURATE_INTR_MASKED_SATURATE_COUNT  16
  #define SAR_SATURATE_INTR_MASKED_SATURATE(fidx)  (0x00000001 << ((fidx)))

#define SAR_RANGE_INTR_ADDR                          0x00000230
#define SAR_RANGE_INTR_MASK                          0x0000ffff
/** Range detect Interrupt: hardware sets this interrupt for each channel if the
   conversion result (af- ter averaging) of that channel met the condition
   specified by the RANGE registers. Write with '1' to clear bit. @multiple */
  #define SAR_RANGE_INTR_RANGE_COUNT               16
  #define SAR_RANGE_INTR_RANGE(fidx)               (0x00000001 << ((fidx)))

#define SAR_RANGE_INTR_SET_ADDR                      0x00000234
#define SAR_RANGE_INTR_SET_MASK                      0x0000ffff
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SAR_RANGE_INTR_SET_RANGE_COUNT           16
  #define SAR_RANGE_INTR_SET_RANGE(fidx)           (0x00000001 << ((fidx)))

#define SAR_RANGE_INTR_MASK_ADDR                     0x00000238
#define SAR_RANGE_INTR_MASK_MASK                     0x0000ffff
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SAR_RANGE_INTR_MASK_RANGE_MASK_COUNT     16
  #define SAR_RANGE_INTR_MASK_RANGE_MASK(fidx)     (0x00000001 << ((fidx)))

#define SAR_RANGE_INTR_MASKED_ADDR                   0x0000023c
#define SAR_RANGE_INTR_MASKED_MASK                   0x0000ffff
/** Logical and of corresponding request and mask bits. @multiple */
  #define SAR_RANGE_INTR_MASKED_RANGE_COUNT        16
  #define SAR_RANGE_INTR_MASKED_RANGE(fidx)        (0x00000001 << ((fidx)))

#define SAR_INTR_CAUSE_ADDR                          0x00000240
#define SAR_INTR_CAUSE_MASK                          0xc00000f7
/** Mirror copy of corresponding bit in INTR_MASKED @multiple */
  #define SAR_INTR_CAUSE_EOS_MASKED_MIR            0x00000001
/** Mirror copy of corresponding bit in INTR_MASKED @multiple */
  #define SAR_INTR_CAUSE_OVERFLOW_MASKED_MIR       0x00000002
/** Mirror copy of corresponding bit in INTR_MASKED @multiple */
  #define SAR_INTR_CAUSE_FW_COLLISION_MASKED_MIR   0x00000004
/** Mirror copy of corresponding bit in INTR_MASKED @multiple */
  #define SAR_INTR_CAUSE_INJ_EOC_MASKED_MIR        0x00000010
/** Mirror copy of corresponding bit in INTR_MASKED @multiple */
  #define SAR_INTR_CAUSE_INJ_SATURATE_MASKED_MIR   0x00000020
/** Mirror copy of corresponding bit in INTR_MASKED @multiple */
  #define SAR_INTR_CAUSE_INJ_RANGE_MASKED_MIR      0x00000040
/** Mirror copy of corresponding bit in INTR_MASKED @multiple */
  #define SAR_INTR_CAUSE_INJ_COLLISION_MASKED_MIR  0x00000080
/** Reduction OR of all SATURATION_INTR_MASKED bits @multiple */
  #define SAR_INTR_CAUSE_SATURATE_MASKED_RED       0x40000000
/** Reduction OR of all RANGE_INTR_MASKED bits @multiple */
  #define SAR_INTR_CAUSE_RANGE_MASKED_RED          0x80000000

#define SAR_INJ_CHAN_CONFIG_ADDR                     0x00000280
#define SAR_INJ_CHAN_CONFIG_MASK                     0xc0003777
/** Address of the pin to be sampled by this injection channel. If differential
   is enabled then PIN_ADDR[0] is ignored and considered to be 0, i.e. PIN_ADDR
   points to the even pin of a pin pair. @multiple */
  #define SAR_INJ_CHAN_CONFIG_INJ_PIN_ADDR(v)      ((v) << 0)
  #define SAR_INJ_CHAN_CONFIG_INJ_PIN_ADDR_SET(x, v) do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define SAR_INJ_CHAN_CONFIG_INJ_PIN_ADDR_GET(x)  (((x) >> 0) & 0x7)
/** Address of the port that contains the pin to be sampled by this channel.
   @multiple */
  #define SAR_INJ_CHAN_CONFIG_INJ_PORT_ADDR(v)     ((SAR_INJ_CHAN_CONFIG_INJ_PORT_ADDR_##v) << 4)
  #define SAR_INJ_CHAN_CONFIG_INJ_PORT_ADDR_SET(x, v) do { (x) = (((x) & ~0x70) | ((SAR_INJ_CHAN_CONFIG_INJ_PORT_ADDR_##v) << 4)); } while(0)
  #define SAR_INJ_CHAN_CONFIG_INJ_PORT_ADDR_SETVAL(x, v) do { (x) = (((x) & ~0x70) | ((v) << 4)); } while(0)
  #define SAR_INJ_CHAN_CONFIG_INJ_PORT_ADDR_GET(x) (((x) >> 4) & 0x7)
/** SARMUX pins. */
    #define SAR_INJ_CHAN_CONFIG_INJ_PORT_ADDR_SARMUX 0x00000000
/** CTB0 */
    #define SAR_INJ_CHAN_CONFIG_INJ_PORT_ADDR_CTB0   0x00000001
/** CTB1 */
    #define SAR_INJ_CHAN_CONFIG_INJ_PORT_ADDR_CTB1   0x00000002
/** CTB2 */
    #define SAR_INJ_CHAN_CONFIG_INJ_PORT_ADDR_CTB2   0x00000003
/** CTB3 */
    #define SAR_INJ_CHAN_CONFIG_INJ_PORT_ADDR_CTB3   0x00000004
/** AROUTE virtual port */
    #define SAR_INJ_CHAN_CONFIG_INJ_PORT_ADDR_AROUTE_VIRT 0x00000006
/** SARMUX virtual port */
    #define SAR_INJ_CHAN_CONFIG_INJ_PORT_ADDR_SARMUX_VIRT 0x00000007
/** Differential enable for this channel. - 0: The voltage on the addressed pin
   is measured (Single-ended) and the resulting value is stored in the
   corresponding data register. - 1: The differential voltage on the addressed
   pin pair is measured and the resulting value is stored in the corresponding
   data register. (INJ_PIN_ADDR[0] is ignored). @multiple */
  #define SAR_INJ_CHAN_CONFIG_INJ_DIFFERENTIAL_EN  0x00000100
/** Resolution for this channel. @multiple */
  #define SAR_INJ_CHAN_CONFIG_INJ_RESOLUTION(v)    ((SAR_INJ_CHAN_CONFIG_INJ_RESOLUTION_##v) << 9)
  #define SAR_INJ_CHAN_CONFIG_INJ_RESOLUTION_SET(x, v) do { (x) = (((x) & ~0x200) | ((SAR_INJ_CHAN_CONFIG_INJ_RESOLUTION_##v) << 9)); } while(0)
  #define SAR_INJ_CHAN_CONFIG_INJ_RESOLUTION_SETVAL(x, v) do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
  #define SAR_INJ_CHAN_CONFIG_INJ_RESOLUTION_GET(x) (((x) >> 9) & 0x1)
/** 12-bit resolution is used for this channel. */
    #define SAR_INJ_CHAN_CONFIG_INJ_RESOLUTION_12B   0x00000000
/** The resolution specified by SUB_RESOLUTION in the SAMPLE_CTRL register is used for this channel. */
    #define SAR_INJ_CHAN_CONFIG_INJ_RESOLUTION_SUBRES 0x00000001
/** Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings
   are used for sampling the addressed pin(s) @multiple */
  #define SAR_INJ_CHAN_CONFIG_INJ_AVG_EN           0x00000400
/** Injection sample time select: select which of the 4 global sample times to
   use for this channel @multiple */
  #define SAR_INJ_CHAN_CONFIG_INJ_SAMPLE_TIME_SEL(v) ((v) << 12)
  #define SAR_INJ_CHAN_CONFIG_INJ_SAMPLE_TIME_SEL_SET(x, v) do { (x) = (((x) & ~0x3000) | ((v) << 12)); } while(0)
  #define SAR_INJ_CHAN_CONFIG_INJ_SAMPLE_TIME_SEL_GET(x) (((x) >> 12) & 0x3)
/** Injection channel tailgating. When 0, SAR is immediately triggered when the
   INJ_START_EN bit is set. When 1, the addressed pin is sampled after the next
   trigger and after all enabled channels have been scanned. @multiple */
  #define SAR_INJ_CHAN_CONFIG_INJ_TAILGATING       0x40000000
/** Set by firmware to enable the injection channel. If INJ_TAILGATING is not set
   this bit also func- tions as trigger for this channel. Cleared by hardware
   after this channel has been sampled (i.e. this channel is always one shot even
   if CONTINUOUS is set). Also cleared if the SAR is disabled. @multiple */
  #define SAR_INJ_CHAN_CONFIG_INJ_START_EN         0x80000000

#define SAR_INJ_RESULT_ADDR                          0x00000290
#define SAR_INJ_RESULT_MASK                          0xf000ffff
/** SAR conversion result of the channel. @multiple */
  #define SAR_INJ_RESULT_INJ_RESULT(v)             ((v) << 0)
  #define SAR_INJ_RESULT_INJ_RESULT_SET(x, v)      do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SAR_INJ_RESULT_INJ_RESULT_GET(x)         (((x) >> 0) & 0xffff)
/** mirror bit of corresponding bit in INTR register @multiple */
  #define SAR_INJ_RESULT_INJ_COLLISION_INTR_MIR    0x10000000
/** mirror bit of corresponding bit in INTR register @multiple */
  #define SAR_INJ_RESULT_INJ_SATURATE_INTR_MIR     0x20000000
/** mirror bit of corresponding bit in INTR register @multiple */
  #define SAR_INJ_RESULT_INJ_RANGE_INTR_MIR        0x40000000
/** mirror bit of corresponding bit in INTR register @multiple */
  #define SAR_INJ_RESULT_INJ_EOC_INTR_MIR          0x80000000

/** SARMUX Firmware switch controls @multiple */
#define SAR_MUX_SWITCH0_ADDR                         0x00000300
#define SAR_MUX_SWITCH0_MASK                         0x3fffffff
/** Firmware control: 0=open, 1=close switch between pin P0 and vplus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P0_VPLUS          0x00000001
/** Firmware control: 0=open, 1=close switch between pin P1 and vplus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P1_VPLUS          0x00000002
/** Firmware control: 0=open, 1=close switch between pin P2 and vplus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P2_VPLUS          0x00000004
/** Firmware control: 0=open, 1=close switch between pin P3 and vplus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P3_VPLUS          0x00000008
/** Firmware control: 0=open, 1=close switch between pin P4 and vplus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P4_VPLUS          0x00000010
/** Firmware control: 0=open, 1=close switch between pin P5 and vplus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P5_VPLUS          0x00000020
/** Firmware control: 0=open, 1=close switch between pin P6 and vplus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P6_VPLUS          0x00000040
/** Firmware control: 0=open, 1=close switch between pin P7 and vplus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P7_VPLUS          0x00000080
/** Firmware control: 0=open, 1=close switch between pin P0 and vminus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P0_VMINUS         0x00000100
/** Firmware control: 0=open, 1=close switch between pin P1 and vminus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P1_VMINUS         0x00000200
/** Firmware control: 0=open, 1=close switch between pin P2 and vminus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P2_VMINUS         0x00000400
/** Firmware control: 0=open, 1=close switch between pin P3 and vminus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P3_VMINUS         0x00000800
/** Firmware control: 0=open, 1=close switch between pin P4 and vminus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P4_VMINUS         0x00001000
/** Firmware control: 0=open, 1=close switch between pin P5 and vminus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P5_VMINUS         0x00002000
/** Firmware control: 0=open, 1=close switch between pin P6 and vminus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P6_VMINUS         0x00004000
/** Firmware control: 0=open, 1=close switch between pin P7 and vminus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P7_VMINUS         0x00008000
/** Firmware control: 0=open, 1=close switch between vssa_kelvin and vminus
   signal. Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_VSSA_VMINUS       0x00010000
/** Firmware control: 0=open, 1=close switch between temperature sensor and vplus
   signal, also powers on the temperature sensor. Write with '1' to set bit.
   @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_TEMP_VPLUS        0x00020000
/** Firmware control: 0=open, 1=close switch between amuxbusa and vplus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_AMUXBUSA_VPLUS    0x00040000
/** Firmware control: 0=open, 1=close switch between amuxbusb and vplus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_AMUXBUSB_VPLUS    0x00080000
/** Firmware control: 0=open, 1=close switch between amuxbusa and vminus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_AMUXBUSA_VMINUS   0x00100000
/** Firmware control: 0=open, 1=close switch between amuxbusb and vminus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_AMUXBUSB_VMINUS   0x00200000
/** Firmware control: 0=open, 1=close switch between sarbus0 and vplus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_SARBUS0_VPLUS     0x00400000
/** Firmware control: 0=open, 1=close switch between sarbus1 and vplus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_SARBUS1_VPLUS     0x00800000
/** Firmware control: 0=open, 1=close switch between sarbus0 and vminus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_SARBUS0_VMINUS    0x01000000
/** Firmware control: 0=open, 1=close switch between sarbus1 and vminus signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_SARBUS1_VMINUS    0x02000000
/** Firmware control: 0=open, 1=close switch between P4 and coreio0 signal. Write
   with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P4_COREIO0        0x04000000
/** Firmware control: 0=open, 1=close switch between P5 and coreio1 signal. Write
   with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P5_COREIO1        0x08000000
/** Firmware control: 0=open, 1=close switch between P6 and coreio2 signal. Write
   with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P6_COREIO2        0x10000000
/** Firmware control: 0=open, 1=close switch between P7 and coreio3 signal. Write
   with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH0_MUX_FW_P7_COREIO3        0x20000000

/** SARMUX Firmware switch control clear @multiple */
#define SAR_MUX_SWITCH_CLEAR0_ADDR                   0x00000304
#define SAR_MUX_SWITCH_CLEAR0_MASK                   0x3fffffff
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P0_VPLUS    0x00000001
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P1_VPLUS    0x00000002
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P2_VPLUS    0x00000004
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P3_VPLUS    0x00000008
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P4_VPLUS    0x00000010
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P5_VPLUS    0x00000020
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P6_VPLUS    0x00000040
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P7_VPLUS    0x00000080
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P0_VMINUS   0x00000100
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P1_VMINUS   0x00000200
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P2_VMINUS   0x00000400
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P3_VMINUS   0x00000800
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P4_VMINUS   0x00001000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P5_VMINUS   0x00002000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P6_VMINUS   0x00004000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P7_VMINUS   0x00008000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_VSSA_VMINUS 0x00010000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_TEMP_VPLUS  0x00020000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_AMUXBUSA_VPLUS 0x00040000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_AMUXBUSB_VPLUS 0x00080000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_AMUXBUSA_VMINUS 0x00100000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_AMUXBUSB_VMINUS 0x00200000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_SARBUS0_VPLUS 0x00400000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_SARBUS1_VPLUS 0x00800000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_SARBUS0_VMINUS 0x01000000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_SARBUS1_VMINUS 0x02000000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P4_COREIO0  0x04000000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P5_COREIO1  0x08000000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P6_COREIO2  0x10000000
/** Write '1' to clear corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_CLEAR0_MUX_FW_P7_COREIO3  0x20000000

/** SARMUX Firmware switch controls @multiple */
#define SAR_MUX_SWITCH1_ADDR                         0x00000308
#define SAR_MUX_SWITCH1_MASK                         0x0000000f
/** Firmware control: 0=open, 1=close switch between P4 pin and dft_inp signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH1_MUX_FW_P4_DFT_INP        0x00000001
/** Firmware control: 0=open, 1=close switch between P5 pin and dft_inm signal.
   Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH1_MUX_FW_P5_DFT_INM        0x00000002
/** Firmware control: 0=open, 1=close switch between adft0 signal and sarbus0
   signal. Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH1_MUX_FW_ADFT0_SARBUS0     0x00000004
/** Firmware control: 0=open, 1=close switch between adft1 signal and sarbus1
   signal. Write with '1' to set bit. @multiple */
  #define SAR_MUX_SWITCH1_MUX_FW_ADFT1_SARBUS1     0x00000008

/** SARMUX Firmware switch control clear @multiple */
#define SAR_MUX_SWITCH_CLEAR1_ADDR                   0x0000030c
#define SAR_MUX_SWITCH_CLEAR1_MASK                   0x0000000f
/** Write '1' to clear corresponding bit in MUX_SWITCH1 @multiple */
  #define SAR_MUX_SWITCH_CLEAR1_MUX_FW_P4_DFT_INP  0x00000001
/** Write '1' to clear corresponding bit in MUX_SWITCH1 @multiple */
  #define SAR_MUX_SWITCH_CLEAR1_MUX_FW_P5_DFT_INM  0x00000002
/** Write '1' to clear corresponding bit in MUX_SWITCH1 @multiple */
  #define SAR_MUX_SWITCH_CLEAR1_MUX_FW_ADFT0_SARBUS0 0x00000004
/** Write '1' to clear corresponding bit in MUX_SWITCH1 @multiple */
  #define SAR_MUX_SWITCH_CLEAR1_MUX_FW_ADFT1_SARBUS1 0x00000008

/** SARMUX switch hardware control @multiple */
#define SAR_MUX_SWITCH_HW_CTRL_ADDR                  0x00000340
#define SAR_MUX_SWITCH_HW_CTRL_MASK                  0x00cf00ff
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for pin P0 switches. @multiple */
  #define SAR_MUX_SWITCH_HW_CTRL_MUX_HW_CTRL_P0    0x00000001
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for pin P1 switches. @multiple */
  #define SAR_MUX_SWITCH_HW_CTRL_MUX_HW_CTRL_P1    0x00000002
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for pin P2 switches. @multiple */
  #define SAR_MUX_SWITCH_HW_CTRL_MUX_HW_CTRL_P2    0x00000004
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for pin P3 switches. @multiple */
  #define SAR_MUX_SWITCH_HW_CTRL_MUX_HW_CTRL_P3    0x00000008
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for pin P4 switches. @multiple */
  #define SAR_MUX_SWITCH_HW_CTRL_MUX_HW_CTRL_P4    0x00000010
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for pin P5 switches. @multiple */
  #define SAR_MUX_SWITCH_HW_CTRL_MUX_HW_CTRL_P5    0x00000020
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for pin P6 switches. @multiple */
  #define SAR_MUX_SWITCH_HW_CTRL_MUX_HW_CTRL_P6    0x00000040
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for pin P7 switches. @multiple */
  #define SAR_MUX_SWITCH_HW_CTRL_MUX_HW_CTRL_P7    0x00000080
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for vssa switch. @multiple */
  #define SAR_MUX_SWITCH_HW_CTRL_MUX_HW_CTRL_VSSA  0x00010000
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for temp switch. @multiple */
  #define SAR_MUX_SWITCH_HW_CTRL_MUX_HW_CTRL_TEMP  0x00020000
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for amuxbusa switches. @multiple */
  #define SAR_MUX_SWITCH_HW_CTRL_MUX_HW_CTRL_AMUXBUSA 0x00040000
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for amuxbusb switches. @multiple */
  #define SAR_MUX_SWITCH_HW_CTRL_MUX_HW_CTRL_AMUXBUSB 0x00080000
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for sarbus0 switches. @multiple */
  #define SAR_MUX_SWITCH_HW_CTRL_MUX_HW_CTRL_SARBUS0 0x00400000
/** Hardware control: 0=only firmware control, 1=hardware control masked by
   firmware setting for sarbus1 switches. @multiple */
  #define SAR_MUX_SWITCH_HW_CTRL_MUX_HW_CTRL_SARBUS1 0x00800000

/** SARMUX switch status @multiple */
#define SAR_MUX_SWITCH_STATUS_ADDR                   0x00000348
#define SAR_MUX_SWITCH_STATUS_MASK                   0x03ffffff
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P0_VPLUS    0x00000001
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P1_VPLUS    0x00000002
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P2_VPLUS    0x00000004
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P3_VPLUS    0x00000008
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P4_VPLUS    0x00000010
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P5_VPLUS    0x00000020
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P6_VPLUS    0x00000040
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P7_VPLUS    0x00000080
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P0_VMINUS   0x00000100
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P1_VMINUS   0x00000200
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P2_VMINUS   0x00000400
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P3_VMINUS   0x00000800
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P4_VMINUS   0x00001000
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P5_VMINUS   0x00002000
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P6_VMINUS   0x00004000
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_P7_VMINUS   0x00008000
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_VSSA_VMINUS 0x00010000
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_TEMP_VPLUS  0x00020000
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_AMUXBUSA_VPLUS 0x00040000
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_AMUXBUSB_VPLUS 0x00080000
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_AMUXBUSA_VMINUS 0x00100000
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_AMUXBUSB_VMINUS 0x00200000
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_SARBUS0_VPLUS 0x00400000
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_SARBUS1_VPLUS 0x00800000
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_SARBUS0_VMINUS 0x01000000
/** switch status of corresponding bit in MUX_SWITCH0 @multiple */
  #define SAR_MUX_SWITCH_STATUS_MUX_FW_SARBUS1_VMINUS 0x02000000

/** Switch pump control @multiple */
#define SAR_PUMP_CTRL_ADDR                           0x00000380
#define SAR_PUMP_CTRL_MASK                           0x80000001
/** Clock select: 0=external clock, 1=internal clock (deprecated). @multiple */
  #define SAR_PUMP_CTRL_CLOCK_SEL                  0x00000001
/** 0=disabled: pump output is VDDA_PUMP, 1=enabled: pump output is boosted.
   @multiple */
  #define SAR_PUMP_CTRL_ENABLED                    0x80000000

#define SAR_ANA_TRIM_ADDR                            0x00000f00
#define SAR_ANA_TRIM_MASK                            0x0000000f
/** Attenuation cap trimming @multiple */
  #define SAR_ANA_TRIM_CAP_TRIM(v)                 ((v) << 0)
  #define SAR_ANA_TRIM_CAP_TRIM_SET(x, v)          do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define SAR_ANA_TRIM_CAP_TRIM_GET(x)             (((x) >> 0) & 0x7)
/** Attenuation cap trimming @multiple */
  #define SAR_ANA_TRIM_TRIMUNIT                    0x00000008

#define SAR_WOUNDING_ADDR                            0x00000f04
#define SAR_WOUNDING_MASK                            0x00000003
/** Maximum SAR resolution allowed @multiple */
  #define SAR_WOUNDING_WOUND_RESOLUTION(v)         ((SAR_WOUNDING_WOUND_RESOLUTION_##v) << 0)
  #define SAR_WOUNDING_WOUND_RESOLUTION_SET(x, v)  do { (x) = (((x) & ~0x3) | ((SAR_WOUNDING_WOUND_RESOLUTION_##v) << 0)); } while(0)
  #define SAR_WOUNDING_WOUND_RESOLUTION_SETVAL(x, v) do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define SAR_WOUNDING_WOUND_RESOLUTION_GET(x)     (((x) >> 0) & 0x3)
/** unwounded: up to full 12-bit SAR resolution allowed */
    #define SAR_WOUNDING_WOUND_RESOLUTION_12BIT      0x00000000
/** wounded: max resolution upto 10-bit SAR resolution allowed */
    #define SAR_WOUNDING_WOUND_RESOLUTION_10BIT      0x00000001
/** wounded: only 8-bit SAR resolution allowed */
    #define SAR_WOUNDING_WOUND_RESOLUTION_8BIT       0x00000002
/** wounded: only 8-bit SAR resolution allowed */
    #define SAR_WOUNDING_WOUND_RESOLUTION_8BIT_TOO   0x00000003

#endif

