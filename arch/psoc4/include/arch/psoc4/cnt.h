/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -I cnt.bf -O cnt.h -o cdefs cdefs_use_reg_mask=1                      \
     cdefs_use_field_setval=1
*/

#ifndef _CNT_BFGEN_DEFS_
#define _CNT_BFGEN_DEFS_

#define CNT_CTRL_ADDR                                0x00000100
#define CNT_CTRL_MASK                                0x0737ff0f
/** Specifies switching of the CC and buffered CC values. This field has a
   function in TIMER, PWM, PWM_DT and PWM_PR modes. When enabled in timer mode,
   switch on a compare match event. When enabled in PWM, PWM_DT, PWM_PR modes,
   switch on a terminal count event with an actively pending switch event.
   @multiple */
  #define CNT_CTRL_AUTO_RELOAD_CC                  0x00000001
/** Specifies switching of the PERIOD and buffered PERIOD values. This field has
   a function in PWM, PWM_DT and PWM_PR modes. If 1, switch on a terminal count
   event with and actively pending siwtch event. @multiple */
  #define CNT_CTRL_AUTO_RELOAD_PERIOD              0x00000002
/** Specifies asynchronous/synchronous kill behavior: @multiple */
  #define CNT_CTRL_PWM_SYNC_KILL(v)                ((CNT_CTRL_PWM_SYNC_KILL_##v) << 2)
  #define CNT_CTRL_PWM_SYNC_KILL_SET(x, v)         do { (x) = (((x) & ~0x4) | ((CNT_CTRL_PWM_SYNC_KILL_##v) << 2)); } while(0)
  #define CNT_CTRL_PWM_SYNC_KILL_SETVAL(x, v)      do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define CNT_CTRL_PWM_SYNC_KILL_GET(x)            (((x) >> 2) & 0x1)
/** asynchronous kill mode: the kill event only disables the "dt_line_out" and "dt_line_compl_out" signals when present. In asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET. This field has a function in PWM and PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'. */
    #define CNT_CTRL_PWM_SYNC_KILL_ASYNCHRONOUS      0x00000000
/** synchronous kill mode: the kill event disables the "dt_line_out" and "dt_line_compl_out" signals till the next terminal count event (synchronous kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE. */
    #define CNT_CTRL_PWM_SYNC_KILL_SYNCHRONOUS       0x00000001
/** Specifies whether the counter stops on a kill events: @multiple */
  #define CNT_CTRL_PWM_STOP_ON_KILL(v)             ((CNT_CTRL_PWM_STOP_ON_KILL_##v) << 3)
  #define CNT_CTRL_PWM_STOP_ON_KILL_SET(x, v)      do { (x) = (((x) & ~0x8) | ((CNT_CTRL_PWM_STOP_ON_KILL_##v) << 3)); } while(0)
  #define CNT_CTRL_PWM_STOP_ON_KILL_SETVAL(x, v)   do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define CNT_CTRL_PWM_STOP_ON_KILL_GET(x)         (((x) >> 3) & 0x1)
/** kill event does NOT stop counter. */
    #define CNT_CTRL_PWM_STOP_ON_KILL_KILL_EVENT_DOES_NOT_STOP_COUNTER 0x00000000
/** kill event stops counter. This field has a function in PWM, PWM_DT and PWM_PR modes only. */
    #define CNT_CTRL_PWM_STOP_ON_KILL_KILL_EVENT_STOPS_COUNTER 0x00000001
/** Generic 8-bit control field. In PWM_DT mode, this field is used to determine
   the dead time: amount of dead time cycles in the counter clock domain. In all
   other modes, the lower 3 bits of this field determine pre-scaling of the
   selected counter clock. Divide by 2^GENERIC @multiple */
  #define CNT_CTRL_GENERIC(v)                      ((v) << 8)
  #define CNT_CTRL_GENERIC_SET(x, v)               do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define CNT_CTRL_GENERIC_GET(x)                  (((x) >> 8) & 0xff)
/** Determines counter direction. @multiple */
  #define CNT_CTRL_UP_DOWN_MODE(v)                 ((CNT_CTRL_UP_DOWN_MODE_##v) << 16)
  #define CNT_CTRL_UP_DOWN_MODE_SET(x, v)          do { (x) = (((x) & ~0x30000) | ((CNT_CTRL_UP_DOWN_MODE_##v) << 16)); } while(0)
  #define CNT_CTRL_UP_DOWN_MODE_SETVAL(x, v)       do { (x) = (((x) & ~0x30000) | ((v) << 16)); } while(0)
  #define CNT_CTRL_UP_DOWN_MODE_GET(x)             (((x) >> 16) & 0x3)
/** Count up (to PERIOD). An overflow event is generated when the counter reaches PERIOD. A terminal count event is generated when the counter reaches PERIOD. */
    #define CNT_CTRL_UP_DOWN_MODE_COUNT_UP           0x00000000
/** Count down (to "0"). An underflow event is generated when the counter reaches "0". A terminal count event is generated when the counter reaches "0". */
    #define CNT_CTRL_UP_DOWN_MODE_COUNT_DOWN         0x00000001
/** Count up (to PERIOD), then count down (to "0"). An overflow event is generated when the counter reaches PERIOD. An underflow event is generated when the counter reaches "0". A terminal count event is generated when the counter reaches "0". */
    #define CNT_CTRL_UP_DOWN_MODE_COUNT_UPDN1        0x00000002
/** Count up (to PERIOD), then count down (to "0"). An overflow event is generated when the counter reaches PERIOD. An underflow event is generated when the counter reaches "0". A terminal count event is generated when the counter reaches "0" AND when the counter reaches PERIOD (this counter direction can be used for PWM functionality with asymmetrical updates). */
    #define CNT_CTRL_UP_DOWN_MODE_COUNT_UPDN2        0x00000003
/** When '0', counter runs continuous. When '1', counter is turned off by
   hardware when a terminal count event is generated. @multiple */
  #define CNT_CTRL_ONE_SHOT                        0x00040000
/** In QUAD mode selects quadrature encoding mode (X1/X2/X4). In PWM, PWM_DT and
   PWM_PR modes, these two bits can be used to invert "dt_line_out" and
   "dt_line_compl_out". Inversion is the last step in generation of "dt_line_out"
   and "dt_line_compl_out"; i.e. a disabled output line "dt_line_out" has the
   value QUADRATURE_MODE[0] and a disabled output line "dt_line_compl_out" has
   the value QUADRATURE_MODE[1]. @multiple */
  #define CNT_CTRL_QUADRATURE_MODE(v)              ((CNT_CTRL_QUADRATURE_MODE_##v) << 20)
  #define CNT_CTRL_QUADRATURE_MODE_SET(x, v)       do { (x) = (((x) & ~0x300000) | ((CNT_CTRL_QUADRATURE_MODE_##v) << 20)); } while(0)
  #define CNT_CTRL_QUADRATURE_MODE_SETVAL(x, v)    do { (x) = (((x) & ~0x300000) | ((v) << 20)); } while(0)
  #define CNT_CTRL_QUADRATURE_MODE_GET(x)          (((x) >> 20) & 0x3)
/** X1 encoding (QUAD mode) */
    #define CNT_CTRL_QUADRATURE_MODE_X1              0x00000000
/** X2 encoding (QUAD mode) */
    #define CNT_CTRL_QUADRATURE_MODE_X2              0x00000001
/** X4 encoding (QUAD mode) */
    #define CNT_CTRL_QUADRATURE_MODE_X4              0x00000002
/** Counter mode. @multiple */
  #define CNT_CTRL_MODE(v)                         ((CNT_CTRL_MODE_##v) << 24)
  #define CNT_CTRL_MODE_SET(x, v)                  do { (x) = (((x) & ~0x7000000) | ((CNT_CTRL_MODE_##v) << 24)); } while(0)
  #define CNT_CTRL_MODE_SETVAL(x, v)               do { (x) = (((x) & ~0x7000000) | ((v) << 24)); } while(0)
  #define CNT_CTRL_MODE_GET(x)                     (((x) >> 24) & 0x7)
/** Timer mode */
    #define CNT_CTRL_MODE_TIMER                      0x00000000
/** Capture mode */
    #define CNT_CTRL_MODE_CAPTURE                    0x00000002
/** Quadrature encoding mode */
    #define CNT_CTRL_MODE_QUAD                       0x00000003
/** Pulse width modulation (PWM) mode */
    #define CNT_CTRL_MODE_PWM                        0x00000004
/** PWM with deadtime insertion mode */
    #define CNT_CTRL_MODE_PWM_DT                     0x00000005
/** Pseudo random pulse width modulation */
    #define CNT_CTRL_MODE_PWM_PR                     0x00000006

#define CNT_STATUS_ADDR                              0x00000104
#define CNT_STATUS_MASK                              0x8000ff01
/** When '0', counter is counting up. When '1', counter is counting down. In QUAD
   mode, this field indicates the direction of the latest counter change: '0'
   when last incremented and '1' when last decremented. @multiple */
  #define CNT_STATUS_DOWN                          0x00000001
/** Generic 8-bit counter field. In PWM_DT mode, this counter is used for dead
   time insertion. In all other modes, this counter is used for pre-scaling the
   selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.
   @multiple */
  #define CNT_STATUS_GENERIC(v)                    ((v) << 8)
  #define CNT_STATUS_GENERIC_SET(x, v)             do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define CNT_STATUS_GENERIC_GET(x)                (((x) >> 8) & 0xff)
/** When '0', the counter is NOT running. When '1', the counter is running.
   @multiple */
  #define CNT_STATUS_RUNNING                       0x80000000

/** 16-bit counter value. It is advised to not write to this field when the
   counter is running. @multiple */
#define CNT_COUNTER_ADDR                             0x00000108
#define CNT_COUNTER_MASK                             0x00000000

/** In CAPTURE mode, captures the counter value. In other modes, compared to
   counter value. @multiple */
#define CNT_CC_ADDR                                  0x0000010c
#define CNT_CC_MASK                                  0x00000000

/** Additional buffer for counter CC register. @multiple */
#define CNT_CC_BUFF_ADDR                             0x00000110
#define CNT_CC_BUFF_MASK                             0x00000000

/** Period value: upper value of the counter. When the counter should count for n
   cycles, this field should be set to n-1. @multiple */
#define CNT_PERIOD_ADDR                              0x00000114
#define CNT_PERIOD_MASK                              0x00000000

/** Additional buffer for counter PERIOD register. @multiple */
#define CNT_PERIOD_BUFF_ADDR                         0x00000118
#define CNT_PERIOD_BUFF_MASK                         0x00000000

#define CNT_TR_CTRL0_ADDR                            0x00000120
#define CNT_TR_CTRL0_MASK                            0x000fffff
/** Selects one of the 16 input triggers as a capture trigger. Input trigger 0 is
   always '0' and input trigger is always '1'. In the PWM, PWM_DT and PWM_PR
   modes this trigger is used to switch the values if the compare and period
   registers with their buffer counterparts. @multiple */
  #define CNT_TR_CTRL0_CAPTURE_SEL(v)              ((v) << 0)
  #define CNT_TR_CTRL0_CAPTURE_SEL_SET(x, v)       do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define CNT_TR_CTRL0_CAPTURE_SEL_GET(x)          (((x) >> 0) & 0xf)
/** Selects one of the 16 input triggers as a count trigger. In QUAD mode, this
   is the first phase (phi A). Default setting selects input trigger 1, which is
   always '1'. @multiple */
  #define CNT_TR_CTRL0_COUNT_SEL(v)                ((v) << 4)
  #define CNT_TR_CTRL0_COUNT_SEL_SET(x, v)         do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define CNT_TR_CTRL0_COUNT_SEL_GET(x)            (((x) >> 4) & 0xf)
/** Selects one of the 16 input triggers as a reload trigger. In QUAD mode, this
   is the index or rev- olution pulse. In this mode, it will update the counter
   with the value in the TCPWM_CNTn_PERIOD register. @multiple */
  #define CNT_TR_CTRL0_RELOAD_SEL(v)               ((v) << 8)
  #define CNT_TR_CTRL0_RELOAD_SEL_SET(x, v)        do { (x) = (((x) & ~0xf00) | ((v) << 8)); } while(0)
  #define CNT_TR_CTRL0_RELOAD_SEL_GET(x)           (((x) >> 8) & 0xf)
/** Selects one of the 16 input triggers as a stop trigger. In PWM, PWM_DT and
   PWM_PR modes, this is the kill trigger. In these modes, the kill trigger is
   used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL is '0') or
   stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT
   modes, the blocking of the output signals can be asynchronous (STOP_EDGE
   should be NO_EDGE_DET) in which case the blocking is as long as the trigger is
   '1' or synchronous (STOP_EDGE should be RISING_EDGE) in which case it extends
   till the next terminal count event. @multiple */
  #define CNT_TR_CTRL0_STOP_SEL(v)                 ((v) << 12)
  #define CNT_TR_CTRL0_STOP_SEL_SET(x, v)          do { (x) = (((x) & ~0xf000) | ((v) << 12)); } while(0)
  #define CNT_TR_CTRL0_STOP_SEL_GET(x)             (((x) >> 12) & 0xf)
/** Selects one of the 16 input triggers as a start trigger. In QUAD mode, this
   is the second phase (phi B). @multiple */
  #define CNT_TR_CTRL0_START_SEL(v)                ((v) << 16)
  #define CNT_TR_CTRL0_START_SEL_SET(x, v)         do { (x) = (((x) & ~0xf0000) | ((v) << 16)); } while(0)
  #define CNT_TR_CTRL0_START_SEL_GET(x)            (((x) >> 16) & 0xf)

#define CNT_TR_CTRL1_ADDR                            0x00000124
#define CNT_TR_CTRL1_MASK                            0x000003ff
/** A capture event will copy the counter value into the CC register. @multiple
   */
  #define CNT_TR_CTRL1_CAPTURE_EDGE(v)             ((CNT_TR_CTRL1_CAPTURE_EDGE_##v) << 0)
  #define CNT_TR_CTRL1_CAPTURE_EDGE_SET(x, v)      do { (x) = (((x) & ~0x3) | ((CNT_TR_CTRL1_CAPTURE_EDGE_##v) << 0)); } while(0)
  #define CNT_TR_CTRL1_CAPTURE_EDGE_SETVAL(x, v)   do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define CNT_TR_CTRL1_CAPTURE_EDGE_GET(x)         (((x) >> 0) & 0x3)
/** Rising edge. Any rising edge generates an event. */
    #define CNT_TR_CTRL1_CAPTURE_EDGE_RISING_EDGE    0x00000000
/** Falling edge. Any falling edge generates an event. */
    #define CNT_TR_CTRL1_CAPTURE_EDGE_FALLING_EDGE   0x00000001
/** Rising AND falling edge. Any odd amount of edges generates an event. */
    #define CNT_TR_CTRL1_CAPTURE_EDGE_BOTH_EDGES     0x00000002
/** No edge detection, use trigger as is. */
    #define CNT_TR_CTRL1_CAPTURE_EDGE_NO_EDGE_DET    0x00000003
/** A counter event will increase or decrease the counter by '1'. @multiple */
  #define CNT_TR_CTRL1_COUNT_EDGE(v)               ((CNT_TR_CTRL1_COUNT_EDGE_##v) << 2)
  #define CNT_TR_CTRL1_COUNT_EDGE_SET(x, v)        do { (x) = (((x) & ~0xc) | ((CNT_TR_CTRL1_COUNT_EDGE_##v) << 2)); } while(0)
  #define CNT_TR_CTRL1_COUNT_EDGE_SETVAL(x, v)     do { (x) = (((x) & ~0xc) | ((v) << 2)); } while(0)
  #define CNT_TR_CTRL1_COUNT_EDGE_GET(x)           (((x) >> 2) & 0x3)
/** Rising edge. Any rising edge generates an event. */
    #define CNT_TR_CTRL1_COUNT_EDGE_RISING_EDGE      0x00000000
/** Falling edge. Any falling edge generates an event. */
    #define CNT_TR_CTRL1_COUNT_EDGE_FALLING_EDGE     0x00000001
/** Rising AND falling edge. Any odd amount of edges generates an event. */
    #define CNT_TR_CTRL1_COUNT_EDGE_BOTH_EDGES       0x00000002
/** No edge detection, use trigger as is. */
    #define CNT_TR_CTRL1_COUNT_EDGE_NO_EDGE_DET      0x00000003
/** A reload event will initialize the counter. When counting up, the counter is
   initialized to "0". When counting down, the counter is initialized with
   PERIOD. @multiple */
  #define CNT_TR_CTRL1_RELOAD_EDGE(v)              ((CNT_TR_CTRL1_RELOAD_EDGE_##v) << 4)
  #define CNT_TR_CTRL1_RELOAD_EDGE_SET(x, v)       do { (x) = (((x) & ~0x30) | ((CNT_TR_CTRL1_RELOAD_EDGE_##v) << 4)); } while(0)
  #define CNT_TR_CTRL1_RELOAD_EDGE_SETVAL(x, v)    do { (x) = (((x) & ~0x30) | ((v) << 4)); } while(0)
  #define CNT_TR_CTRL1_RELOAD_EDGE_GET(x)          (((x) >> 4) & 0x3)
/** Rising edge. Any rising edge generates an event. */
    #define CNT_TR_CTRL1_RELOAD_EDGE_RISING_EDGE     0x00000000
/** Falling edge. Any falling edge generates an event. */
    #define CNT_TR_CTRL1_RELOAD_EDGE_FALLING_EDGE    0x00000001
/** Rising AND falling edge. Any odd amount of edges generates an event. */
    #define CNT_TR_CTRL1_RELOAD_EDGE_BOTH_EDGES      0x00000002
/** No edge detection, use trigger as is. */
    #define CNT_TR_CTRL1_RELOAD_EDGE_NO_EDGE_DET     0x00000003
/** A stop event, will stop the counter; i.e. it will no longer be running.
   Stopping will NOT disable the counter. @multiple */
  #define CNT_TR_CTRL1_STOP_EDGE(v)                ((CNT_TR_CTRL1_STOP_EDGE_##v) << 6)
  #define CNT_TR_CTRL1_STOP_EDGE_SET(x, v)         do { (x) = (((x) & ~0xc0) | ((CNT_TR_CTRL1_STOP_EDGE_##v) << 6)); } while(0)
  #define CNT_TR_CTRL1_STOP_EDGE_SETVAL(x, v)      do { (x) = (((x) & ~0xc0) | ((v) << 6)); } while(0)
  #define CNT_TR_CTRL1_STOP_EDGE_GET(x)            (((x) >> 6) & 0x3)
/** Rising edge. Any rising edge generates an event. */
    #define CNT_TR_CTRL1_STOP_EDGE_RISING_EDGE       0x00000000
/** Falling edge. Any falling edge generates an event. */
    #define CNT_TR_CTRL1_STOP_EDGE_FALLING_EDGE      0x00000001
/** Rising AND falling edge. Any odd amount of edges generates an event. */
    #define CNT_TR_CTRL1_STOP_EDGE_BOTH_EDGES        0x00000002
/** No edge detection, use trigger as is. */
    #define CNT_TR_CTRL1_STOP_EDGE_NO_EDGE_DET       0x00000003
/** A start event will start the counter; i.e. the counter will become running.
   Starting does NOT en- able the counter. A start event will not initialize the
   counter whereas the reload event does. @multiple */
  #define CNT_TR_CTRL1_START_EDGE(v)               ((CNT_TR_CTRL1_START_EDGE_##v) << 8)
  #define CNT_TR_CTRL1_START_EDGE_SET(x, v)        do { (x) = (((x) & ~0x300) | ((CNT_TR_CTRL1_START_EDGE_##v) << 8)); } while(0)
  #define CNT_TR_CTRL1_START_EDGE_SETVAL(x, v)     do { (x) = (((x) & ~0x300) | ((v) << 8)); } while(0)
  #define CNT_TR_CTRL1_START_EDGE_GET(x)           (((x) >> 8) & 0x3)
/** Rising edge. Any rising edge generates an event. */
    #define CNT_TR_CTRL1_START_EDGE_RISING_EDGE      0x00000000
/** Falling edge. Any falling edge generates an event. */
    #define CNT_TR_CTRL1_START_EDGE_FALLING_EDGE     0x00000001
/** Rising AND falling edge. Any odd amount of edges generates an event. */
    #define CNT_TR_CTRL1_START_EDGE_BOTH_EDGES       0x00000002
/** No edge detection, use trigger as is. */
    #define CNT_TR_CTRL1_START_EDGE_NO_EDGE_DET      0x00000003

#define CNT_TR_CTRL2_ADDR                            0x00000128
#define CNT_TR_CTRL2_MASK                            0x0000003f
/** Determines the effect of a compare match event (COUNTER equals CC register)
   on the "line_out" output signals. Note that INVERT is especially useful for
   center aligned pulse width modulation. To generate a duty cycle of 0%, the
   counter CC register should be set to "0". For a 100% duty cycle, the counter
   CC register should be set to larger than the counter PERIOD register.
   @multiple */
  #define CNT_TR_CTRL2_CC_MATCH_MODE(v)            ((CNT_TR_CTRL2_CC_MATCH_MODE_##v) << 0)
  #define CNT_TR_CTRL2_CC_MATCH_MODE_SET(x, v)     do { (x) = (((x) & ~0x3) | ((CNT_TR_CTRL2_CC_MATCH_MODE_##v) << 0)); } while(0)
  #define CNT_TR_CTRL2_CC_MATCH_MODE_SETVAL(x, v)  do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define CNT_TR_CTRL2_CC_MATCH_MODE_GET(x)        (((x) >> 0) & 0x3)
/** Set to '1' */
    #define CNT_TR_CTRL2_CC_MATCH_MODE_SET           0x00000000
/** Set to '0' */
    #define CNT_TR_CTRL2_CC_MATCH_MODE_CLEAR         0x00000001
/** Invert */
    #define CNT_TR_CTRL2_CC_MATCH_MODE_INVERT        0x00000002
/** No Change */
    #define CNT_TR_CTRL2_CC_MATCH_MODE_NO_CHANGE     0x00000003
/** Determines the effect of a counter overflow event (COUNTER reaches PERIOD) on
   the "line_out" output signals. @multiple */
  #define CNT_TR_CTRL2_OVERFLOW_MODE(v)            ((CNT_TR_CTRL2_OVERFLOW_MODE_##v) << 2)
  #define CNT_TR_CTRL2_OVERFLOW_MODE_SET(x, v)     do { (x) = (((x) & ~0xc) | ((CNT_TR_CTRL2_OVERFLOW_MODE_##v) << 2)); } while(0)
  #define CNT_TR_CTRL2_OVERFLOW_MODE_SETVAL(x, v)  do { (x) = (((x) & ~0xc) | ((v) << 2)); } while(0)
  #define CNT_TR_CTRL2_OVERFLOW_MODE_GET(x)        (((x) >> 2) & 0x3)
/** Set to '1' */
    #define CNT_TR_CTRL2_OVERFLOW_MODE_SET           0x00000000
/** Set to '0' */
    #define CNT_TR_CTRL2_OVERFLOW_MODE_CLEAR         0x00000001
/** Invert */
    #define CNT_TR_CTRL2_OVERFLOW_MODE_INVERT        0x00000002
/** No Change */
    #define CNT_TR_CTRL2_OVERFLOW_MODE_NO_CHANGE     0x00000003
/** Determines the effect of a counter underflow event (COUNTER reaches "0") on
   the "line_out" output signals. @multiple */
  #define CNT_TR_CTRL2_UNDERFLOW_MODE(v)           ((CNT_TR_CTRL2_UNDERFLOW_MODE_##v) << 4)
  #define CNT_TR_CTRL2_UNDERFLOW_MODE_SET(x, v)    do { (x) = (((x) & ~0x30) | ((CNT_TR_CTRL2_UNDERFLOW_MODE_##v) << 4)); } while(0)
  #define CNT_TR_CTRL2_UNDERFLOW_MODE_SETVAL(x, v) do { (x) = (((x) & ~0x30) | ((v) << 4)); } while(0)
  #define CNT_TR_CTRL2_UNDERFLOW_MODE_GET(x)       (((x) >> 4) & 0x3)
/** Set to '1' */
    #define CNT_TR_CTRL2_UNDERFLOW_MODE_SET          0x00000000
/** Set to '0' */
    #define CNT_TR_CTRL2_UNDERFLOW_MODE_CLEAR        0x00000001
/** Invert */
    #define CNT_TR_CTRL2_UNDERFLOW_MODE_INVERT       0x00000002
/** No Change */
    #define CNT_TR_CTRL2_UNDERFLOW_MODE_NO_CHANGE    0x00000003

#define CNT_INTR_ADDR                                0x00000130
#define CNT_INTR_MASK                                0x00000003
/** Terminal count event. Set to '1', when event is detected. Write 1 to clear.
   @multiple */
  #define CNT_INTR_TC                              0x00000001
/** Counter matches CC register event. Set to '1', when event is detected. Write
   1 to clear. @multiple */
  #define CNT_INTR_CC_MATCH                        0x00000002

#define CNT_INTR_SET_ADDR                            0x00000134
#define CNT_INTR_SET_MASK                            0x00000003
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define CNT_INTR_SET_TC                          0x00000001
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define CNT_INTR_SET_CC_MATCH                    0x00000002

#define CNT_INTR_MASK_ADDR                           0x00000138
#define CNT_INTR_MASK_MASK                           0x00000003
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define CNT_INTR_MASK_TC                         0x00000001
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define CNT_INTR_MASK_CC_MATCH                   0x00000002

#define CNT_INTR_MASKED_ADDR                         0x0000013c
#define CNT_INTR_MASKED_MASK                         0x00000003
/** Logical and of corresponding request and mask bits. @multiple */
  #define CNT_INTR_MASKED_TC                       0x00000001
/** Logical and of corresponding request and mask bits. @multiple */
  #define CNT_INTR_MASKED_CC_MATCH                 0x00000002

#endif

