/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -I bless.bf -O bless.h -o cdefs cdefs_use_reg_mask=1                  \
     cdefs_use_field_setval=1
*/

#ifndef _BLESS_BFGEN_DEFS_
#define _BLESS_BFGEN_DEFS_

#define BLESS_WCO_CONFIG_ADDR                        0x00000000
#define BLESS_WCO_CONFIG_MASK                        0x805f0005
/** Force block into Low Power Mode @multiple */
  #define BLESS_WCO_CONFIG_LPM_EN                  0x00000001
/** Disables the load resistor and allows external clock input for pad_xin
   @multiple */
  #define BLESS_WCO_CONFIG_EXT_INPUT_EN            0x00000004
/** Load Resistor Control @multiple */
  #define BLESS_WCO_CONFIG_LOAD_RESISTOR_COUNT     4
  #define BLESS_WCO_CONFIG_LOAD_RESISTOR(fidx)     (0x00010000 << ((fidx)))
/** enable digital oscillator detect @multiple */
  #define BLESS_WCO_CONFIG_DOSC_DETECT             0x00100000
/** Enable both primary Beta Multipliers @multiple */
  #define BLESS_WCO_CONFIG_PRIMARY                 0x00400000
/** Master enable for WCO oscillator @multiple */
  #define BLESS_WCO_CONFIG_ENABLE                  0x80000000

#define BLESS_WCO_STATUS_ADDR                        0x00000004
#define BLESS_WCO_STATUS_MASK                        0x00000001
/** Indicates that WCO clock has transitioned. This bit is intended for Test Mode
   Only and is not a reliable indicator. @multiple */
  #define BLESS_WCO_STATUS_OUT_BLNK_A              0x00000001

#define BLESS_RF_CONFIG_ADDR                         0x00000060
#define BLESS_RF_CONFIG_MASK                         0x0000cff1
/** Enables the RF oscillator band gap. @multiple */
  #define BLESS_RF_CONFIG_RF_ENABLE                0x00000001
/** dbg_mux_pin1 selection, combine with BLERD and BLESS @multiple */
  #define BLESS_RF_CONFIG_DDFT_MUX_CFG1(v)         ((BLESS_RF_CONFIG_DDFT_MUX_CFG1_##v) << 4)
  #define BLESS_RF_CONFIG_DDFT_MUX_CFG1_SET(x, v)  do { (x) = (((x) & ~0xf0) | ((BLESS_RF_CONFIG_DDFT_MUX_CFG1_##v) << 4)); } while(0)
  #define BLESS_RF_CONFIG_DDFT_MUX_CFG1_SETVAL(x, v) do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define BLESS_RF_CONFIG_DDFT_MUX_CFG1_GET(x)     (((x) >> 4) & 0xf)
/** RD output */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG1_DBG_PIN_MUX_1_RD 0x00000000
/** RD output */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG1_RXCLK      0x00000001
/** RD input */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG1_BPKTCTL_TO_RD 0x00000002
/** llh_cy_asic output */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG1_DBUS_RX_EN 0x00000003
/** pwr_ctrl_top */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG1_HW_CLK_EN  0x00000004
/** pwr_ctrl_top */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG1_CLK_SWITCH_TO_SYSCLK 0x00000005
/** LL global clock enable from BLESS reg synced */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG1_LL_CLK_EN_SYNC 0x00000006
/** llh_cy_asic output */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG1_DSM_ENTRY_STAT 0x00000007
/** LL in DSM, RD XO enabled */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG1_LL_DSM_XO_ON 0x00000008
/** LL in DSM, RD XO disabled */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG1_LL_DSM_XO_OFF 0x00000009
/** m0s8bless_misc_dpslp_top output vs LS to s8blerf */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG1_DELAYED_BG_EN 0x0000000f
/** dbg_mux_pin2 selection, combine with BLERD and BLESS @multiple */
  #define BLESS_RF_CONFIG_DDFT_MUX_CFG2(v)         ((BLESS_RF_CONFIG_DDFT_MUX_CFG2_##v) << 8)
  #define BLESS_RF_CONFIG_DDFT_MUX_CFG2_SET(x, v)  do { (x) = (((x) & ~0xf00) | ((BLESS_RF_CONFIG_DDFT_MUX_CFG2_##v) << 8)); } while(0)
  #define BLESS_RF_CONFIG_DDFT_MUX_CFG2_SETVAL(x, v) do { (x) = (((x) & ~0xf00) | ((v) << 8)); } while(0)
  #define BLESS_RF_CONFIG_DDFT_MUX_CFG2_GET(x)     (((x) >> 8) & 0xf)
/** dbg_pin_mux_2_rd */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG2_DBG_PIN_MUX_2_RD 0x00000000
/** RD output */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG2_RXDATA     0x00000001
/** llh_cy_asic output */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG2_LL_DECODE_RX_DATA 0x00000002
/** dbus_tx_en (llh_cy_asic output) */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG2_DBUS_TX_EN 0x00000003
/** pwr_ctrl_top output */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG2_FW_CLK_EN  0x00000004
/** llh_cy_asic output */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG2_INTERRUPT_LL_N 0x00000005
/** llh is in SM */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG2_LL_ST_SM   0x00000006
/** llh is in DSM */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG2_LL_ST_DSM  0x00000007
/** RD eco xtal clock gater enable */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG2_CLK_GATE_EN_XTAL 0x0000000e
/** RD output */
    #define BLESS_RF_CONFIG_DDFT_MUX_CFG2_BB_XO_AMP_DETECT_DFT_MUX 0x0000000f
/** FW drives BLERD BPKTCTL if this register bit 15 enabled @multiple */
  #define BLESS_RF_CONFIG_BPKTCTL_FW               0x00004000
/** Enabled FW drives BLERD BPKCTL for radio standalone testing @multiple */
  #define BLESS_RF_CONFIG_BPKTCTL_FW_DRIVE         0x00008000

#define BLESS_XTAL_CLK_DIV_CONFIG_ADDR               0x00000064
#define BLESS_XTAL_CLK_DIV_CONFIG_MASK               0x0000000f
/** System clock pre-divider value. The 24 MHz crystal clock is divided to
   generate the system clock. @multiple */
  #define BLESS_XTAL_CLK_DIV_CONFIG_SYSCLK_DIV(v)  ((BLESS_XTAL_CLK_DIV_CONFIG_SYSCLK_DIV_##v) << 0)
  #define BLESS_XTAL_CLK_DIV_CONFIG_SYSCLK_DIV_SET(x, v) do { (x) = (((x) & ~0x3) | ((BLESS_XTAL_CLK_DIV_CONFIG_SYSCLK_DIV_##v) << 0)); } while(0)
  #define BLESS_XTAL_CLK_DIV_CONFIG_SYSCLK_DIV_SETVAL(x, v) do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define BLESS_XTAL_CLK_DIV_CONFIG_SYSCLK_DIV_GET(x) (((x) >> 0) & 0x3)
/** SYSCLK= XTALCLK/1 */
    #define BLESS_XTAL_CLK_DIV_CONFIG_SYSCLK_DIV_NO_DIV 0x00000000
/** SYSCLK= XTALCLK/2 */
    #define BLESS_XTAL_CLK_DIV_CONFIG_SYSCLK_DIV_DIV_BY_2 0x00000001
/** SYSCLK= XTALCLK/4 */
    #define BLESS_XTAL_CLK_DIV_CONFIG_SYSCLK_DIV_DIV_BY_4 0x00000002
/** SYSCLK= XTALCLK/8 */
    #define BLESS_XTAL_CLK_DIV_CONFIG_SYSCLK_DIV_DIV_BY_8 0x00000003
/** Link Layer clock pre-divider value. The 24 MHz crystal clock is divided to
   generate the Link Layer clock. @multiple */
  #define BLESS_XTAL_CLK_DIV_CONFIG_LLCLK_DIV(v)   ((BLESS_XTAL_CLK_DIV_CONFIG_LLCLK_DIV_##v) << 2)
  #define BLESS_XTAL_CLK_DIV_CONFIG_LLCLK_DIV_SET(x, v) do { (x) = (((x) & ~0xc) | ((BLESS_XTAL_CLK_DIV_CONFIG_LLCLK_DIV_##v) << 2)); } while(0)
  #define BLESS_XTAL_CLK_DIV_CONFIG_LLCLK_DIV_SETVAL(x, v) do { (x) = (((x) & ~0xc) | ((v) << 2)); } while(0)
  #define BLESS_XTAL_CLK_DIV_CONFIG_LLCLK_DIV_GET(x) (((x) >> 2) & 0x3)
/** LLCLK= XTALCLK/1 */
    #define BLESS_XTAL_CLK_DIV_CONFIG_LLCLK_DIV_NO_DIV 0x00000000
/** LLCLK= XTALCLK/2 */
    #define BLESS_XTAL_CLK_DIV_CONFIG_LLCLK_DIV_DIV_BY_2 0x00000001
/** LLCLK= XTALCLK/4 */
    #define BLESS_XTAL_CLK_DIV_CONFIG_LLCLK_DIV_DIV_BY_4 0x00000002
/** LLCLK= XTALCLK/8 */
    #define BLESS_XTAL_CLK_DIV_CONFIG_LLCLK_DIV_DIV_BY_8 0x00000003

#define BLESS_LL_DSM_INTR_STAT_ADDR                  0x00000068
#define BLESS_LL_DSM_INTR_STAT_MASK                  0x00000103
/** On a firmware request to LL to enter into state machine, working on LF clock,
   LL transitions into Deep Sleep Mode and asserts this interrupt. Write 1 to
   clear. @multiple */
  #define BLESS_LL_DSM_INTR_STAT_DSM_ENTERED_INTR  0x00000001
/** On a firmware request to LL to exit from Deep Sleep Mode, working on LF
   clock, LL transitions from Deep Sleep Mode and asserts this interrupt when the
   Deep Sleep clock gater is turned ON. Write 1 to clear. @multiple */
  #define BLESS_LL_DSM_INTR_STAT_DSM_EXITED_INTR   0x00000002
/** ECO stable signal interrupt. Write 1 to clear. @multiple */
  #define BLESS_LL_DSM_INTR_STAT_XTAL_ON_INTR      0x00000100

#define BLESS_LL_DSM_CTRL_ADDR                       0x0000006c
#define BLESS_LL_DSM_CTRL_MASK                       0x0000000f
/** When the Link Layer is in Deep Sleep Mode, firmware can set this bit to wake
   the Link Layer. @multiple */
  #define BLESS_LL_DSM_CTRL_DSM_EXIT               0x00000001
/** DSM Entered Interrupt enable @multiple */
  #define BLESS_LL_DSM_CTRL_DSM_ENTERED_INTR_EN    0x00000002
/** DSM Exited Interrupt enable @multiple */
  #define BLESS_LL_DSM_CTRL_DSM_EXITED_INTR_EN     0x00000004
/** ECO Stable Interrupt enable @multiple */
  #define BLESS_LL_DSM_CTRL_XTAL_ON_INTR_EN        0x00000008

/** Link Layer primary clock enable @multiple */
#define BLESS_LL_CLK_EN_ADDR                         0x00000070
#define BLESS_LL_CLK_EN_MASK                         0x00000003
/** Set this bit 1 to enable the clock to Link Layer. @multiple */
  #define BLESS_LL_CLK_EN_CLK_EN                   0x00000001
/** Set this bit 1 to enable Cypress Correlator logic to bypass MT logic
   @multiple */
  #define BLESS_LL_CLK_EN_CY_CORREL_EN             0x00000002

/** BLESS LF clock control @multiple */
#define BLESS_LF_CLK_CTRL_ADDR                       0x00000074
#define BLESS_LF_CLK_CTRL_MASK                       0x00000001
/** When set to 1, gates the LF clock input to the Link Layer. Ths is done for
   extended DSM mode where the DSM state machine needs to be forzen to prevent a
   default auto exit. @multiple */
  #define BLESS_LF_CLK_CTRL_DISABLE_LF_CLK         0x00000001

#define BLESS_WCO_TRIM_ADDR                          0x00000f00
#define BLESS_WCO_TRIM_MASK                          0x00000037
/** Amplifier GM setting @multiple */
  #define BLESS_WCO_TRIM_XGM(v)                    ((BLESS_WCO_TRIM_XGM_##v) << 0)
  #define BLESS_WCO_TRIM_XGM_SET(x, v)             do { (x) = (((x) & ~0x7) | ((BLESS_WCO_TRIM_XGM_##v) << 0)); } while(0)
  #define BLESS_WCO_TRIM_XGM_SETVAL(x, v)          do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define BLESS_WCO_TRIM_XGM_GET(x)                (((x) >> 0) & 0x7)
/** 3370 nA */
    #define BLESS_WCO_TRIM_XGM_3370_NA               0x00000000
/** 2620 nA */
    #define BLESS_WCO_TRIM_XGM_2620_NA               0x00000001
/** 2250 nA */
    #define BLESS_WCO_TRIM_XGM_2250_NA               0x00000002
/** 1500 nA */
    #define BLESS_WCO_TRIM_XGM_1500_NA               0x00000003
/** 1870 nA */
    #define BLESS_WCO_TRIM_XGM_1870_NA               0x00000004
/** 1120 nA */
    #define BLESS_WCO_TRIM_XGM_1120_NA               0x00000005
/** 750 nA */
    #define BLESS_WCO_TRIM_XGM_750_NA                0x00000006
/** 0 nA */
    #define BLESS_WCO_TRIM_XGM_0_NA                  0x00000007
/** GM setting for LPM (bandwidth = DC/ms) @multiple */
  #define BLESS_WCO_TRIM_LPM_GM(v)                 ((v) << 4)
  #define BLESS_WCO_TRIM_LPM_GM_SET(x, v)          do { (x) = (((x) & ~0x30) | ((v) << 4)); } while(0)
  #define BLESS_WCO_TRIM_LPM_GM_GET(x)             (((x) >> 4) & 0x3)

#endif

