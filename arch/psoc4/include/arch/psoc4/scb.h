/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -I scb.bf -O scb.h -o cdefs cdefs_use_reg_mask=1                      \
     cdefs_use_field_setval=1
*/

#ifndef _SCB_BFGEN_DEFS_
#define _SCB_BFGEN_DEFS_

#define SCB_CTRL_ADDR                                0x00000000
#define SCB_CTRL_MASK                                0x83030f0f
/** Oversampling ratio. @multiple */
  #define SCB_CTRL_OVS(v)                          ((v) << 0)
  #define SCB_CTRL_OVS_SET(x, v)                   do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SCB_CTRL_OVS_GET(x)                      (((x) >> 0) & 0xf)
/** Externally clocked mode address matching (I2C) or selection (SPI). Must be 0
   for UART mode. @multiple */
  #define SCB_CTRL_EC_AM_MODE                      0x00000100
/** Externally clocked mode operation. Must be 0 for UART mode. @multiple */
  #define SCB_CTRL_EC_OP_MODE                      0x00000200
/** EZ mode enable @multiple */
  #define SCB_CTRL_EZ_MODE                         0x00000400
/** Determines the number of bits per FIFO data element, if not byte mode, 16-bit
   data words are used. @multiple */
  #define SCB_CTRL_BYTE_MODE                       0x00000800
/** Whether to accept a matching received address. @multiple */
  #define SCB_CTRL_ADDR_ACCEPT                     0x00010000
/** Only used in externally clocked mode. If the externally clocked logic and the
   MMIO SW accesses to EZ memory coincide/collide, this bit determines whether a
   SW access should block and result in bus wait states ('BLOCK is 1') or not
   (BLOCK is '0'). IF BLOCK is 0 and the accesses collide, MMIO read operations
   return 0xffff:ffff and MMIO write operations are ignored. Colliding access- es
   are registered as interrupt causes: field BLOCKED of MMIO registers INTR_TX
   and INTR_RX. @multiple */
  #define SCB_CTRL_BLOCK                           0x00020000
/** Mode of operation @multiple */
  #define SCB_CTRL_MODE(v)                         ((SCB_CTRL_MODE_##v) << 24)
  #define SCB_CTRL_MODE_SET(x, v)                  do { (x) = (((x) & ~0x3000000) | ((SCB_CTRL_MODE_##v) << 24)); } while(0)
  #define SCB_CTRL_MODE_SETVAL(x, v)               do { (x) = (((x) & ~0x3000000) | ((v) << 24)); } while(0)
  #define SCB_CTRL_MODE_GET(x)                     (((x) >> 24) & 0x3)
/** Inter-Integrated Circuits (I2C) mode. */
    #define SCB_CTRL_MODE_I2C                        0x00000000
/** Serial Peripheral Interface (SPI) mode. */
    #define SCB_CTRL_MODE_SPI                        0x00000001
/** Universal Asynchronous Receiver/Transmitter (UART) mode. */
    #define SCB_CTRL_MODE_UART                       0x00000002
/** IP enabled @multiple */
  #define SCB_CTRL_ENABLED                         0x80000000

#define SCB_STATUS_ADDR                              0x00000004
#define SCB_STATUS_MASK                              0x00000001
/** Inidicates whether the externally clocked logic is potentially accessing the
   EZ memory (this is only possible in EZ mode). This bit can be used by SW to
   determine whether it is safe to issue a SW access to the EZ memory (without
   bus wait states (a blocked SW access) or bus errors being generated). Note
   that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to
   indicate whether a SW access was actually blocked by externally clocked logic.
   @multiple */
  #define SCB_STATUS_EC_BUSY                       0x00000001

#define SCB_SPI_CTRL_ADDR                            0x00000020
#define SCB_SPI_CTRL_MASK                            0x8f010f3f
/** Whether to keep slave select between words. @multiple */
  #define SCB_SPI_CTRL_CONTINUOUS                  0x00000001
/** Only used in SPI Texas Instruments' submode. Whether data frame start
   indication precedes or coincides with the transfer of the first data frame
   bit. @multiple */
  #define SCB_SPI_CTRL_SELECT_PRECEDE              0x00000002
/** Only applicable in SPI Motorola submode. @multiple */
  #define SCB_SPI_CTRL_CPHA                        0x00000004
/** Indicates the clock polarity. @multiple */
  #define SCB_SPI_CTRL_CPOL                        0x00000008
/** Changes the SCLK edge on which MISO is captured. Only used in master mode.
   @multiple */
  #define SCB_SPI_CTRL_LATE_MISO_SAMPLE            0x00000010
/** Only applicable in master mode. SCLK is always generated. @multiple */
  #define SCB_SPI_CTRL_SCLK_CONTINUOUS             0x00000020
/** Slave select polarity. Value on pin for selection @multiple */
  #define SCB_SPI_CTRL_SSEL_POLARITY_COUNT         4
  #define SCB_SPI_CTRL_SSEL_POLARITY(fidx)         (0x00000100 << ((fidx)))
/** Take MISO value from MOSI. Only used in master mode. Not used in National
   Semiconductors submode. @multiple */
  #define SCB_SPI_CTRL_LOOPBACK                    0x00010000
/** Submode of SPI operation @multiple */
  #define SCB_SPI_CTRL_MODE(v)                     ((SCB_SPI_CTRL_MODE_##v) << 24)
  #define SCB_SPI_CTRL_MODE_SET(x, v)              do { (x) = (((x) & ~0x3000000) | ((SCB_SPI_CTRL_MODE_##v) << 24)); } while(0)
  #define SCB_SPI_CTRL_MODE_SETVAL(x, v)           do { (x) = (((x) & ~0x3000000) | ((v) << 24)); } while(0)
  #define SCB_SPI_CTRL_MODE_GET(x)                 (((x) >> 24) & 0x3)
    #define SCB_SPI_CTRL_MODE_MOTOROLA               0x00000000
    #define SCB_SPI_CTRL_MODE_TI                     0x00000001
    #define SCB_SPI_CTRL_MODE_NS                     0x00000002
/** Selects one of the four outgoing SPI slave select signals: Only used in
   master mode. The IP should be disabled when changes are made to this field.
   @multiple */
  #define SCB_SPI_CTRL_SLAVE_SELECT(v)             ((SCB_SPI_CTRL_SLAVE_SELECT_##v) << 26)
  #define SCB_SPI_CTRL_SLAVE_SELECT_SET(x, v)      do { (x) = (((x) & ~0xc000000) | ((SCB_SPI_CTRL_SLAVE_SELECT_##v) << 26)); } while(0)
  #define SCB_SPI_CTRL_SLAVE_SELECT_SETVAL(x, v)   do { (x) = (((x) & ~0xc000000) | ((v) << 26)); } while(0)
  #define SCB_SPI_CTRL_SLAVE_SELECT_GET(x)         (((x) >> 26) & 0x3)
/** SPI_SELECT[0] */
    #define SCB_SPI_CTRL_SLAVE_SELECT_SLAVE_0        0x00000000
/** SPI_SELECT[1] */
    #define SCB_SPI_CTRL_SLAVE_SELECT_SLAVE_1        0x00000001
/** SPI_SELECT[2] */
    #define SCB_SPI_CTRL_SLAVE_SELECT_SLAVE_2        0x00000002
/** SPI_SELECT[3] */
    #define SCB_SPI_CTRL_SLAVE_SELECT_SLAVE_3        0x00000003
/** SPI master mode selection @multiple */
  #define SCB_SPI_CTRL_MASTER_MODE                 0x80000000

#define SCB_SPI_STATUS_ADDR                          0x00000024
#define SCB_SPI_STATUS_MASK                          0x00ffff03
/** SPI bus is busy. @multiple */
  #define SCB_SPI_STATUS_BUS_BUSY                  0x00000001
/** Inidicates whether the externally clocked logic is potentially accessing the
   EZ memory and/or up- dating BASE_ADDR or CURR_ADDR (this is only possible in
   EZ mode). @multiple */
  #define SCB_SPI_STATUS_SPI_EC_BUSY               0x00000002
/** SPI current EZ address. @multiple */
  #define SCB_SPI_STATUS_CURR_EZ_ADDR(v)           ((v) << 8)
  #define SCB_SPI_STATUS_CURR_EZ_ADDR_SET(x, v)    do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define SCB_SPI_STATUS_CURR_EZ_ADDR_GET(x)       (((x) >> 8) & 0xff)
/** SPI base EZ address. @multiple */
  #define SCB_SPI_STATUS_BASE_EZ_ADDR(v)           ((v) << 16)
  #define SCB_SPI_STATUS_BASE_EZ_ADDR_SET(x, v)    do { (x) = (((x) & ~0xff0000) | ((v) << 16)); } while(0)
  #define SCB_SPI_STATUS_BASE_EZ_ADDR_GET(x)       (((x) >> 16) & 0xff)

#define SCB_UART_CTRL_ADDR                           0x00000040
#define SCB_UART_CTRL_MASK                           0x03010000
/** Local loopback control: Take RX value on TX pin, likewise for CTS/RTS if
   handshaking is enabled. @multiple */
  #define SCB_UART_CTRL_LOOPBACK                   0x00010000
/** Submode of UART operation @multiple */
  #define SCB_UART_CTRL_MODE(v)                    ((SCB_UART_CTRL_MODE_##v) << 24)
  #define SCB_UART_CTRL_MODE_SET(x, v)             do { (x) = (((x) & ~0x3000000) | ((SCB_UART_CTRL_MODE_##v) << 24)); } while(0)
  #define SCB_UART_CTRL_MODE_SETVAL(x, v)          do { (x) = (((x) & ~0x3000000) | ((v) << 24)); } while(0)
  #define SCB_UART_CTRL_MODE_GET(x)                (((x) >> 24) & 0x3)
/** Standard UART submode. */
    #define SCB_UART_CTRL_MODE_STD                   0x00000000
/** SmartCard (ISO7816) submode. Support for negative acknowledgement (NACK) on the receiver side and retransmission on the transmitter side. */
    #define SCB_UART_CTRL_MODE_SMARTCARD             0x00000001
/** Infrared Data Association (IrDA) submode. Return to Zero modulation scheme. In this mode, the oversampling factor should be 16 (OVS = 15). */
    #define SCB_UART_CTRL_MODE_IRDA                  0x00000002

#define SCB_UART_TX_CTRL_ADDR                        0x00000044
#define SCB_UART_TX_CTRL_MASK                        0x00000137
/** Duration = (STOP_BITS - 1) / 2 periods. @multiple */
  #define SCB_UART_TX_CTRL_STOP_BITS(v)            ((v) << 0)
  #define SCB_UART_TX_CTRL_STOP_BITS_SET(x, v)     do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define SCB_UART_TX_CTRL_STOP_BITS_GET(x)        (((x) >> 0) & 0x7)
/** Parity bit. @multiple */
  #define SCB_UART_TX_CTRL_PARITY(v)               ((SCB_UART_TX_CTRL_PARITY_##v) << 4)
  #define SCB_UART_TX_CTRL_PARITY_SET(x, v)        do { (x) = (((x) & ~0x10) | ((SCB_UART_TX_CTRL_PARITY_##v) << 4)); } while(0)
  #define SCB_UART_TX_CTRL_PARITY_SETVAL(x, v)     do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define SCB_UART_TX_CTRL_PARITY_GET(x)           (((x) >> 4) & 0x1)
/** Even parity */
    #define SCB_UART_TX_CTRL_PARITY_EVEN             0x00000000
/** Odd parity */
    #define SCB_UART_TX_CTRL_PARITY_ODD              0x00000001
/** Parity generation enable (UART mode only). @multiple */
  #define SCB_UART_TX_CTRL_PARITY_EN               0x00000020
/** Data frame is retransmitted when a negative acknowledgement is received
   (Smartcard mode only). @multiple */
  #define SCB_UART_TX_CTRL_RETRY_ON_NACK           0x00000100

#define SCB_UART_RX_CTRL_ADDR                        0x00000048
#define SCB_UART_RX_CTRL_MASK                        0x000f3777
/** Duration = (STOP_BITS - 1) / 2 periods. @multiple */
  #define SCB_UART_RX_CTRL_STOP_BITS(v)            ((v) << 0)
  #define SCB_UART_RX_CTRL_STOP_BITS_SET(x, v)     do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define SCB_UART_RX_CTRL_STOP_BITS_GET(x)        (((x) >> 0) & 0x7)
/** Expected parity bit @multiple */
  #define SCB_UART_RX_CTRL_PARITY(v)               ((SCB_UART_RX_CTRL_PARITY_##v) << 4)
  #define SCB_UART_RX_CTRL_PARITY_SET(x, v)        do { (x) = (((x) & ~0x10) | ((SCB_UART_RX_CTRL_PARITY_##v) << 4)); } while(0)
  #define SCB_UART_RX_CTRL_PARITY_SETVAL(x, v)     do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define SCB_UART_RX_CTRL_PARITY_GET(x)           (((x) >> 4) & 0x1)
/** Even parity */
    #define SCB_UART_RX_CTRL_PARITY_EVEN             0x00000000
/** Odd parity */
    #define SCB_UART_RX_CTRL_PARITY_ODD              0x00000001
/** Parity check enable (UART only). @multiple */
  #define SCB_UART_RX_CTRL_PARITY_EN               0x00000020
/** Invert RX line polarity. @multiple */
  #define SCB_UART_RX_CTRL_POLARITY                0x00000040
/** Dont store byte on parity error. @multiple */
  #define SCB_UART_RX_CTRL_DROP_ON_PARITY_ERROR    0x00000100
/** Dont store byte on framing error. @multiple */
  #define SCB_UART_RX_CTRL_DROP_ON_FRAME_ERROR     0x00000200
/** Multi-processor mode. @multiple */
  #define SCB_UART_RX_CTRL_MP_MODE                 0x00000400
/** Detect baud rate receiving a 0x55 byte (UART only). @multiple */
  #define SCB_UART_RX_CTRL_LIN_MODE                0x00001000
/** Skip start bit detection, useful when start byte woke CPU from sleep (UART
   mode). @multiple */
  #define SCB_UART_RX_CTRL_SKIP_START              0x00002000
/** Break width. Duration = (BREAK_WIDTH + 1) periods. @multiple */
  #define SCB_UART_RX_CTRL_BREAK_WIDTH(v)          ((v) << 16)
  #define SCB_UART_RX_CTRL_BREAK_WIDTH_SET(x, v)   do { (x) = (((x) & ~0xf0000) | ((v) << 16)); } while(0)
  #define SCB_UART_RX_CTRL_BREAK_WIDTH_GET(x)      (((x) >> 16) & 0xf)

#define SCB_UART_RX_STATUS_ADDR                      0x0000004c
#define SCB_UART_RX_STATUS_MASK                      0x00000fff
/** bit period = BR_COUNTER / 8 peripheral clock ticks. This field has valid data
   when INTR_RX.BAUD_DETECT is set. @multiple */
  #define SCB_UART_RX_STATUS_BR_COUNTER(v)         ((v) << 0)
  #define SCB_UART_RX_STATUS_BR_COUNTER_SET(x, v)  do { (x) = (((x) & ~0xfff) | ((v) << 0)); } while(0)
  #define SCB_UART_RX_STATUS_BR_COUNTER_GET(x)     (((x) >> 0) & 0xfff)

#define SCB_UART_FLOW_CTRL_ADDR                      0x00000050
#define SCB_UART_FLOW_CTRL_MASK                      0x0301000f
/** Trigger level. When the receiver FIFO has less entries than the amount of
   this field, a Ready To Send (RTS) output signal "uart_rts_out" is activated.
   By setting this field to "0", flow control is effectively SW disabled (may be
   useful for debug purposes). @multiple */
  #define SCB_UART_FLOW_CTRL_TRIGGER_LEVEL(v)      ((v) << 0)
  #define SCB_UART_FLOW_CTRL_TRIGGER_LEVEL_SET(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SCB_UART_FLOW_CTRL_TRIGGER_LEVEL_GET(x)  (((x) >> 0) & 0xf)
/** Active level of the RTS output signal "uart_rts_out" @multiple */
  #define SCB_UART_FLOW_CTRL_RTS_POLARITY          0x00010000
/** Active level of the CTS input signal "uart_cts_in" @multiple */
  #define SCB_UART_FLOW_CTRL_CTS_POLARITY          0x01000000
/** Enable use of CTS input signal "uart_cts_in" by the UART transmitter.
   @multiple */
  #define SCB_UART_FLOW_CTRL_CTS_EN                0x02000000

#define SCB_I2C_CTRL_ADDR                            0x00000060
#define SCB_I2C_CTRL_MASK                            0xc001fbff
/** Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1
   peripheral clock periods constitute the high phase of a bit period. The valid
   range is [5, 15] with input signal me- dian filtering and [4, 15] without
   input signal median filtering. The field is only used in master mode. In slave
   mode, the field is NOT used. However, there is a frequency requirement for the
   IP clock wrt. the regular interface (IF) high time to guarantee func- tional
   correct behavior. With input signal median filtering, the IF high time should
   be >= 6 IP clock cycles and <= 16 IP clock cycles. Without input signal median
   filtering, the IF high time should be >= 5 IP clock cycles and <= 16 IP clock
   cycles. @multiple */
  #define SCB_I2C_CTRL_HIGH_PHASE_OVS(v)           ((v) << 0)
  #define SCB_I2C_CTRL_HIGH_PHASE_OVS_SET(x, v)    do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SCB_I2C_CTRL_HIGH_PHASE_OVS_GET(x)       (((x) >> 0) & 0xf)
/** Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1
   peripheral clock periods constitute the low phase of a bit period. The valid
   range is [7, 15] with input signal median filtering and [6, 15] without input
   signal median filtering. The field is only used in master mode. In slave mode,
   the field is NOT used. However, there is a frequency requirement for the IP
   clock wrt. the regular (no stretching) interface (IF) low time to guarantee
   functional correct behavior. With input signal median filtering, the IF low
   time should be >= 8 IP clock cycles and <= 16 IP clock cycles. Without input
   signal median filtering, the IF low time should be >= 7 IP clock cycles and <=
   16 IP clock cycles. @multiple */
  #define SCB_I2C_CTRL_LOW_PHASE_OVS(v)            ((v) << 4)
  #define SCB_I2C_CTRL_LOW_PHASE_OVS_SET(x, v)     do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define SCB_I2C_CTRL_LOW_PHASE_OVS_GET(x)        (((x) >> 4) & 0xf)
/** Data is immediately ACK'd when the receiver FIFO is not full. @multiple */
  #define SCB_I2C_CTRL_M_READY_DATA_ACK            0x00000100
/** Receiving behavior when RX fifo is full @multiple */
  #define SCB_I2C_CTRL_M_NOT_READY_DATA_NACK(v)    ((SCB_I2C_CTRL_M_NOT_READY_DATA_NACK_##v) << 9)
  #define SCB_I2C_CTRL_M_NOT_READY_DATA_NACK_SET(x, v) do { (x) = (((x) & ~0x200) | ((SCB_I2C_CTRL_M_NOT_READY_DATA_NACK_##v) << 9)); } while(0)
  #define SCB_I2C_CTRL_M_NOT_READY_DATA_NACK_SETVAL(x, v) do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
  #define SCB_I2C_CTRL_M_NOT_READY_DATA_NACK_GET(x) (((x) >> 9) & 0x1)
/** clock stretching is performed (till the receiver FIFO is no longer full). */
    #define SCB_I2C_CTRL_M_NOT_READY_DATA_NACK_STRETCH 0x00000000
/** a received data element byte the slave is immediately NACK'd when the receiver FIFO is full. */
    #define SCB_I2C_CTRL_M_NOT_READY_DATA_NACK_NACK  0x00000001
/** Received general call slave address is immediately NACK'd (no ACK or clock
   stretching) and treated as a non matching slave address. This is useful for
   slaves that do not need any data supplied within the general call structure.
   @multiple */
  #define SCB_I2C_CTRL_S_GENERAL_IGNORE            0x00000800
/** Received (matching) slave address is immediately ACK'd when the receiver FIFO
   is not full. @multiple */
  #define SCB_I2C_CTRL_S_READY_ADDR_ACK            0x00001000
/** Received data element by the slave is immediately ACK'd when the receiver
   FIFO is not full. @multiple */
  #define SCB_I2C_CTRL_S_READY_DATA_ACK            0x00002000
/** On an address match or general call address @multiple */
  #define SCB_I2C_CTRL_S_NOT_READY_ADDR_NACK(v)    ((SCB_I2C_CTRL_S_NOT_READY_ADDR_NACK_##v) << 14)
  #define SCB_I2C_CTRL_S_NOT_READY_ADDR_NACK_SET(x, v) do { (x) = (((x) & ~0x4000) | ((SCB_I2C_CTRL_S_NOT_READY_ADDR_NACK_##v) << 14)); } while(0)
  #define SCB_I2C_CTRL_S_NOT_READY_ADDR_NACK_SETVAL(x, v) do { (x) = (((x) & ~0x4000) | ((v) << 14)); } while(0)
  #define SCB_I2C_CTRL_S_NOT_READY_ADDR_NACK_GET(x) (((x) >> 14) & 0x1)
/** clock stretching is performed (till the receiver FIFO is no longer full). */
    #define SCB_I2C_CTRL_S_NOT_READY_ADDR_NACK_STRETCH 0x00000000
/** a received data element byte the slave is immediately NACK'd when the receiver FIFO is full. */
    #define SCB_I2C_CTRL_S_NOT_READY_ADDR_NACK_NACK  0x00000001
/** For internally clocked logic onlyn non EZ mode only. Functionality is as
   follows: @multiple */
  #define SCB_I2C_CTRL_S_NOT_READY_DATA_NACK(v)    ((SCB_I2C_CTRL_S_NOT_READY_DATA_NACK_##v) << 15)
  #define SCB_I2C_CTRL_S_NOT_READY_DATA_NACK_SET(x, v) do { (x) = (((x) & ~0x8000) | ((SCB_I2C_CTRL_S_NOT_READY_DATA_NACK_##v) << 15)); } while(0)
  #define SCB_I2C_CTRL_S_NOT_READY_DATA_NACK_SETVAL(x, v) do { (x) = (((x) & ~0x8000) | ((v) << 15)); } while(0)
  #define SCB_I2C_CTRL_S_NOT_READY_DATA_NACK_GET(x) (((x) >> 15) & 0x1)
/** clock stretching is performed (till the receiver FIFO is no longer full). */
    #define SCB_I2C_CTRL_S_NOT_READY_DATA_NACK_STRETCH 0x00000000
/** a received data element byte the slave is immediately NACK'd when the receiver FIFO is full. */
    #define SCB_I2C_CTRL_S_NOT_READY_DATA_NACK_NACK  0x00000001
/** Local loopback control @multiple */
  #define SCB_I2C_CTRL_LOOPBACK                    0x00010000
/** Enable slave mode @multiple */
  #define SCB_I2C_CTRL_SLAVE_MODE                  0x40000000
/** Enable master mode. @multiple */
  #define SCB_I2C_CTRL_MASTER_MODE                 0x80000000

#define SCB_I2C_STATUS_ADDR                          0x00000064
#define SCB_I2C_STATUS_MASK                          0x00ffff33
/** I2C bus is busy. @multiple */
  #define SCB_I2C_STATUS_BUS_BUSY                  0x00000001
/** Inidicates whether the externally clocked logic is potentially accessing the
   EZ memory. @multiple */
  #define SCB_I2C_STATUS_I2C_EC_BUSY               0x00000002
/** I2C slave read (1) or write (0) transfer. @multiple */
  #define SCB_I2C_STATUS_S_READ                    0x00000010
/** I2C master read (1) or write (0) transfer. @multiple */
  #define SCB_I2C_STATUS_M_READ                    0x00000020
/** I2C slave current EZ address. @multiple */
  #define SCB_I2C_STATUS_CURR_EZ_ADDR(v)           ((v) << 8)
  #define SCB_I2C_STATUS_CURR_EZ_ADDR_SET(x, v)    do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define SCB_I2C_STATUS_CURR_EZ_ADDR_GET(x)       (((x) >> 8) & 0xff)
/** I2C slave base EZ address. @multiple */
  #define SCB_I2C_STATUS_BASE_EZ_ADDR(v)           ((v) << 16)
  #define SCB_I2C_STATUS_BASE_EZ_ADDR_SET(x, v)    do { (x) = (((x) & ~0xff0000) | ((v) << 16)); } while(0)
  #define SCB_I2C_STATUS_BASE_EZ_ADDR_GET(x)       (((x) >> 16) & 0xff)

/** When actions are performed, the hardware resets relevant bits. @multiple */
#define SCB_I2C_M_CMD_ADDR                           0x00000068
#define SCB_I2C_M_CMD_MASK                           0x0000001f
/** Transmit a START or REPEATED START. @multiple */
  #define SCB_I2C_M_CMD_M_START                    0x00000001
/** Transmit a START as soon as the bus is idle. @multiple */
  #define SCB_I2C_M_CMD_M_START_ON_IDLE            0x00000002
/** Transmit an acknowledgement (ACK). @multiple */
  #define SCB_I2C_M_CMD_M_ACK                      0x00000004
/** Transmit a negative acknowledgement (NACK). @multiple */
  #define SCB_I2C_M_CMD_M_NACK                     0x00000008
/** Transmit a STOP. @multiple */
  #define SCB_I2C_M_CMD_M_STOP                     0x00000010

/** When actions are performed, the hardware resets relevant bits. @multiple */
#define SCB_I2C_S_CMD_ADDR                           0x0000006c
#define SCB_I2C_S_CMD_MASK                           0x00000003
/** Transmit an acknowledgement (ACK). @multiple */
  #define SCB_I2C_S_CMD_S_ACK                      0x00000001
/** Transmit a negative acknowledgement (NACK). @multiple */
  #define SCB_I2C_S_CMD_S_NACK                     0x00000002

#define SCB_I2C_CFG_ADDR                             0x00000070
#define SCB_I2C_CFG_MASK                             0x303f1313
/** Trim bits for "i2c_sda_in" 50 ns filter. @multiple */
  #define SCB_I2C_CFG_SDA_IN_FILT_TRIM(v)          ((v) << 0)
  #define SCB_I2C_CFG_SDA_IN_FILT_TRIM_SET(x, v)   do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define SCB_I2C_CFG_SDA_IN_FILT_TRIM_GET(x)      (((x) >> 0) & 0x3)
/** Enable of "i2c_sda_in" filter delay. @multiple */
  #define SCB_I2C_CFG_SDA_IN_FILT_SEL              0x00000010
/** Trim bits for "i2c_scl_in" 50 ns filter. @multiple */
  #define SCB_I2C_CFG_SCL_IN_FILT_TRIM(v)          ((v) << 8)
  #define SCB_I2C_CFG_SCL_IN_FILT_TRIM_SET(x, v)   do { (x) = (((x) & ~0x300) | ((v) << 8)); } while(0)
  #define SCB_I2C_CFG_SCL_IN_FILT_TRIM_GET(x)      (((x) >> 8) & 0x3)
/** Enable of "i2c_scl_in" filter delay. @multiple */
  #define SCB_I2C_CFG_SCL_IN_FILT_SEL              0x00001000
/** Trim bits for "i2c_sda_out" 50 ns filter. @multiple */
  #define SCB_I2C_CFG_SDA_OUT_FILT_TRIM_COUNT      3
  #define SCB_I2C_CFG_SDA_OUT_FILT_TRIM(fidx, v)   ((v) << ((fidx) * 2 + 16))
  #define SCB_I2C_CFG_SDA_OUT_FILT_TRIM_SET(fidx, x, v) do { (x) = (((x) & ~(0x30000 << ((fidx) * 2))) | ((v) << ((fidx) * 2 + 16))); } while(0)
  #define SCB_I2C_CFG_SDA_OUT_FILT_TRIM_GET(fidx, x) (((x) >> ((fidx) * 2 + 16)) & 0x3)
/** Selection of cumulative "i2c_sda_out" filter delay: @multiple */
  #define SCB_I2C_CFG_SDA_OUT_FILT_SEL(v)          ((SCB_I2C_CFG_SDA_OUT_FILT_SEL_##v) << 28)
  #define SCB_I2C_CFG_SDA_OUT_FILT_SEL_SET(x, v)   do { (x) = (((x) & ~0x30000000) | ((SCB_I2C_CFG_SDA_OUT_FILT_SEL_##v) << 28)); } while(0)
  #define SCB_I2C_CFG_SDA_OUT_FILT_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x30000000) | ((v) << 28)); } while(0)
  #define SCB_I2C_CFG_SDA_OUT_FILT_SEL_GET(x)      (((x) >> 28) & 0x3)
/** 0 ns. */
    #define SCB_I2C_CFG_SDA_OUT_FILT_SEL_0NS         0x00000000
/** 50 ns (filter 0 enabled). */
    #define SCB_I2C_CFG_SDA_OUT_FILT_SEL_50NS        0x00000001
/** 100 ns (filters 0 and 1 enabled). */
    #define SCB_I2C_CFG_SDA_OUT_FILT_SEL_100NS       0x00000002
/** 150 ns (filters 0, 1 and 2 enabled). */
    #define SCB_I2C_CFG_SDA_OUT_FILT_SEL_150NS       0x00000003

#define SCB_TX_CTRL_ADDR                             0x00000200
#define SCB_TX_CTRL_MASK                             0x0000010f
/** Dataframe width. Bits = DATA_WIDTH + 1. For SPI, the valid range is [3, 15].
   For I2C this must be 7. @multiple */
  #define SCB_TX_CTRL_DATA_WIDTH(v)                ((v) << 0)
  #define SCB_TX_CTRL_DATA_WIDTH_SET(x, v)         do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SCB_TX_CTRL_DATA_WIDTH_GET(x)            (((x) >> 0) & 0xf)
/** Endianness. For I2C, this field should be '1'. @multiple */
  #define SCB_TX_CTRL_MSB_FIRST                    0x00000100

#define SCB_TX_FIFO_CTRL_ADDR                        0x00000204
#define SCB_TX_FIFO_CTRL_MASK                        0x0003000f
/** Trigger transmission when fifo has less entry than this field. @multiple */
  #define SCB_TX_FIFO_CTRL_TRIGGER_LEVEL(v)        ((v) << 0)
  #define SCB_TX_FIFO_CTRL_TRIGGER_LEVEL_SET(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SCB_TX_FIFO_CTRL_TRIGGER_LEVEL_GET(x)    (((x) >> 0) & 0xf)
/** Invalidate the TX fifo and shift register @multiple */
  #define SCB_TX_FIFO_CTRL_CLEAR                   0x00010000
/** Transmit hardware does not pop from fifo @multiple */
  #define SCB_TX_FIFO_CTRL_FREEZE                  0x00020000

#define SCB_TX_FIFO_STATUS_ADDR                      0x00000208
#define SCB_TX_FIFO_STATUS_MASK                      0x0f0f801f
/** Amount of enties in the transmitter FIFO. The value of this field ranges from
   0 to FF_DATA_NR. @multiple */
  #define SCB_TX_FIFO_STATUS_USED(v)               ((v) << 0)
  #define SCB_TX_FIFO_STATUS_USED_SET(x, v)        do { (x) = (((x) & ~0x1f) | ((v) << 0)); } while(0)
  #define SCB_TX_FIFO_STATUS_USED_GET(x)           (((x) >> 0) & 0x1f)
/** Indicates whether the TX shift registers holds a valid data frame. @multiple
   */
  #define SCB_TX_FIFO_STATUS_SR_VALID              0x00008000
/** FIFO read pointer, FIFO location from which a data frame is read by the
   hardware. @multiple */
  #define SCB_TX_FIFO_STATUS_RD_PTR(v)             ((v) << 16)
  #define SCB_TX_FIFO_STATUS_RD_PTR_SET(x, v)      do { (x) = (((x) & ~0xf0000) | ((v) << 16)); } while(0)
  #define SCB_TX_FIFO_STATUS_RD_PTR_GET(x)         (((x) >> 16) & 0xf)
/** FIFO write pointer, FIFO location at which a new data frame is written.
   @multiple */
  #define SCB_TX_FIFO_STATUS_WR_PTR(v)             ((v) << 24)
  #define SCB_TX_FIFO_STATUS_WR_PTR_SET(x, v)      do { (x) = (((x) & ~0xf000000) | ((v) << 24)); } while(0)
  #define SCB_TX_FIFO_STATUS_WR_PTR_GET(x)         (((x) >> 24) & 0xf)

#define SCB_TX_FIFO_WR_ADDR                          0x00000240
#define SCB_TX_FIFO_WR_MASK                          0x0000ffff
/** Data frame written into the transmitter FIFO. Behavior is similar to that of
   a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are
   used. A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'. @multiple */
  #define SCB_TX_FIFO_WR_DATA(v)                   ((v) << 0)
  #define SCB_TX_FIFO_WR_DATA_SET(x, v)            do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SCB_TX_FIFO_WR_DATA_GET(x)               (((x) >> 0) & 0xffff)

#define SCB_RX_CTRL_ADDR                             0x00000300
#define SCB_RX_CTRL_MASK                             0x0000030f
/** Dataframe width. Bits = DATA_WIDTH + 1. For UART mode, the valid range is [3,
   8]. For SPI, the valid range is [3, 15]. For I2C, this value must be 7. In EZ
   mode (for both SPI and I2C), the only valid value is 7. @multiple */
  #define SCB_RX_CTRL_DATA_WIDTH(v)                ((v) << 0)
  #define SCB_RX_CTRL_DATA_WIDTH_SET(x, v)         do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SCB_RX_CTRL_DATA_WIDTH_GET(x)            (((x) >> 0) & 0xf)
/** Endianness. For I2C, this field should be 1. @multiple */
  #define SCB_RX_CTRL_MSB_FIRST                    0x00000100
/** Median filter. When enabled, a digital 3 taps median filter is performed on
   input interface lines. This filter should reduce the susceptability to errors.
   However, its requires higher oversampling val- ues. For UART IrDA submode,
   this field should always be '1'. @multiple */
  #define SCB_RX_CTRL_MEDIAN                       0x00000200

#define SCB_RX_FIFO_CTRL_ADDR                        0x00000304
#define SCB_RX_FIFO_CTRL_MASK                        0x0003000f
/** Trigger event when fifo has more entry than this field. @multiple */
  #define SCB_RX_FIFO_CTRL_TRIGGER_LEVEL(v)        ((v) << 0)
  #define SCB_RX_FIFO_CTRL_TRIGGER_LEVEL_SET(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SCB_RX_FIFO_CTRL_TRIGGER_LEVEL_GET(x)    (((x) >> 0) & 0xf)
/** Invalidate the RX fifo and shift register @multiple */
  #define SCB_RX_FIFO_CTRL_CLEAR                   0x00010000
/** Receive hardware does not push in fifo @multiple */
  #define SCB_RX_FIFO_CTRL_FREEZE                  0x00020000

#define SCB_RX_FIFO_STATUS_ADDR                      0x00000308
#define SCB_RX_FIFO_STATUS_MASK                      0x0f0f801f
/** Amount of enties in the receiver FIFO. The value of this field ranges from 0
   to FF_DATA_NR. @multiple */
  #define SCB_RX_FIFO_STATUS_USED(v)               ((v) << 0)
  #define SCB_RX_FIFO_STATUS_USED_SET(x, v)        do { (x) = (((x) & ~0x1f) | ((v) << 0)); } while(0)
  #define SCB_RX_FIFO_STATUS_USED_GET(x)           (((x) >> 0) & 0x1f)
/** Indicates whether the RX shift registers holds a valid data frame. @multiple
   */
  #define SCB_RX_FIFO_STATUS_SR_VALID              0x00008000
/** FIFO read pointer, FIFO location from which a data frame is read. @multiple
   */
  #define SCB_RX_FIFO_STATUS_RD_PTR(v)             ((v) << 16)
  #define SCB_RX_FIFO_STATUS_RD_PTR_SET(x, v)      do { (x) = (((x) & ~0xf0000) | ((v) << 16)); } while(0)
  #define SCB_RX_FIFO_STATUS_RD_PTR_GET(x)         (((x) >> 16) & 0xf)
/** FIFO write pointer, FIFO location at which a new data frame is written by the
   hardware. @multiple */
  #define SCB_RX_FIFO_STATUS_WR_PTR(v)             ((v) << 24)
  #define SCB_RX_FIFO_STATUS_WR_PTR_SET(x, v)      do { (x) = (((x) & ~0xf000000) | ((v) << 24)); } while(0)
  #define SCB_RX_FIFO_STATUS_WR_PTR_GET(x)         (((x) >> 24) & 0xf)

#define SCB_RX_MATCH_ADDR                            0x00000310
#define SCB_RX_MATCH_MASK                            0x00ff00ff
/** Slave device address. In UART multi-processor mode, all 8 bits are used. In
   I2C slave mode, only bits 7 down to 1 are used. This reflects the organization
   of the first trans- mitted byte in a I2C transfer: the first 7 bits represent
   the address of the addressed slave, and the last 1 bit is a read/write
   indicator ('0': write, '1': read). @multiple */
  #define SCB_RX_MATCH_ADDR_VALUE(v)               ((v) << 0)
  #define SCB_RX_MATCH_ADDR_VALUE_SET(x, v)        do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define SCB_RX_MATCH_ADDR_VALUE_GET(x)           (((x) >> 0) & 0xff)
/** Slave device address mask. This field is a mask that specifies which of the
   ADDR field bits in the ADDR field take part in the matching of the slave
   address: MATCH = ((ADDR & MASK) == ("slave address" & MASK)). @multiple */
  #define SCB_RX_MATCH_ADDR_MASK(v)                ((v) << 16)
  #define SCB_RX_MATCH_ADDR_MASK_SET(x, v)         do { (x) = (((x) & ~0xff0000) | ((v) << 16)); } while(0)
  #define SCB_RX_MATCH_ADDR_MASK_GET(x)            (((x) >> 16) & 0xff)

#define SCB_RX_FIFO_RD_ADDR                          0x00000340
#define SCB_RX_FIFO_RD_MASK                          0x0000ffff
/** Data read from the receiver FIFO. @multiple */
  #define SCB_RX_FIFO_RD_DATA(v)                   ((v) << 0)
  #define SCB_RX_FIFO_RD_DATA_SET(x, v)            do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SCB_RX_FIFO_RD_DATA_GET(x)               (((x) >> 0) & 0xffff)

#define SCB_RX_FIFO_PEEK_ADDR                        0x00000344
#define SCB_RX_FIFO_PEEK_MASK                        0x0000ffff
/** Data read from the receiver FIFO. @multiple */
  #define SCB_RX_FIFO_PEEK_DATA(v)                 ((v) << 0)
  #define SCB_RX_FIFO_PEEK_DATA_SET(x, v)          do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SCB_RX_FIFO_PEEK_DATA_GET(x)             (((x) >> 0) & 0xffff)

#define SCB_EZ_DATA_ADDR(ridx)                       (0x00000400 + (ridx) * 4)
#define SCB_EZ_DATA_COUNT                            32
#define SCB_EZ_DATA_MASK                             0x000000ff
/** Data in buffer memory location. In case of a blocked discarded access, a read
   access returns 0xffff:ffff and a write access is dropped. Note that the
   0xffff:ffff value is unique (not a legal EZ_DATA byte value) and can be
   detected by SW. Note that a discarded write access can be detected by reading
   back the written value. @multiple */
  #define SCB_EZ_DATA_EZ_DATA(v)                   ((v) << 0)
  #define SCB_EZ_DATA_EZ_DATA_SET(x, v)            do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define SCB_EZ_DATA_EZ_DATA_GET(x)               (((x) >> 0) & 0xff)

#define SCB_INTR_CAUSE_ADDR                          0x00000e00
#define SCB_INTR_CAUSE_MASK                          0x0000003f
/** Master interrupt @multiple */
  #define SCB_INTR_CAUSE_M                         0x00000001
/** Slave interrupt @multiple */
  #define SCB_INTR_CAUSE_S                         0x00000002
/** Transmitter interrupt @multiple */
  #define SCB_INTR_CAUSE_TX                        0x00000004
/** Receiver interrupt @multiple */
  #define SCB_INTR_CAUSE_RX                        0x00000008
/** Externally clock I2C interrupt @multiple */
  #define SCB_INTR_CAUSE_I2C_EC                    0x00000010
/** Externally clocked SPI interrupt @multiple */
  #define SCB_INTR_CAUSE_SPI_EC                    0x00000020

#define SCB_INTR_I2C_EC_ADDR                         0x00000e80
#define SCB_INTR_I2C_EC_MASK                         0x0000000f
/** Wake up requested. @multiple */
  #define SCB_INTR_I2C_EC_WAKE_UP                  0x00000001
/** STOP detected. @multiple */
  #define SCB_INTR_I2C_EC_EZ_STOP                  0x00000002
/** STOP detection after a write transfer occurred. @multiple */
  #define SCB_INTR_I2C_EC_EZ_WRITE_STOP            0x00000004
/** STOP detection after a read transfer occurred. @multiple */
  #define SCB_INTR_I2C_EC_EZ_READ_STOP             0x00000008

#define SCB_INTR_I2C_EC_MASK_ADDR                    0x00000e88
#define SCB_INTR_I2C_EC_MASK_MASK                    0x0000000f
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_I2C_EC_MASK_WAKE_UP             0x00000001
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_I2C_EC_MASK_EZ_STOP             0x00000002
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_I2C_EC_MASK_EZ_WRITE_STOP       0x00000004
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_I2C_EC_MASK_EZ_READ_STOP        0x00000008

#define SCB_INTR_I2C_EC_MASKED_ADDR                  0x00000e8c
#define SCB_INTR_I2C_EC_MASKED_MASK                  0x0000000f
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_I2C_EC_MASKED_WAKE_UP           0x00000001
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_I2C_EC_MASKED_EZ_STOP           0x00000002
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_I2C_EC_MASKED_EZ_WRITE_STOP     0x00000004
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_I2C_EC_MASKED_EZ_READ_STOP      0x00000008

#define SCB_INTR_SPI_EC_ADDR                         0x00000ec0
#define SCB_INTR_SPI_EC_MASK                         0x0000000f
/** Wake up requested. @multiple */
  #define SCB_INTR_SPI_EC_WAKE_UP                  0x00000001
/** STOP detected. @multiple */
  #define SCB_INTR_SPI_EC_EZ_STOP                  0x00000002
/** STOP detection after a write transfer occurred. @multiple */
  #define SCB_INTR_SPI_EC_EZ_WRITE_STOP            0x00000004
/** STOP detection after a read transfer occurred. @multiple */
  #define SCB_INTR_SPI_EC_EZ_READ_STOP             0x00000008

#define SCB_INTR_SPI_EC_MASK_ADDR                    0x00000ec8
#define SCB_INTR_SPI_EC_MASK_MASK                    0x0000000f
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_SPI_EC_MASK_WAKE_UP             0x00000001
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_SPI_EC_MASK_EZ_STOP             0x00000002
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_SPI_EC_MASK_EZ_WRITE_STOP       0x00000004
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_SPI_EC_MASK_EZ_READ_STOP        0x00000008

#define SCB_INTR_SPI_EC_MASKED_ADDR                  0x00000ecc
#define SCB_INTR_SPI_EC_MASKED_MASK                  0x0000000f
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_SPI_EC_MASKED_WAKE_UP           0x00000001
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_SPI_EC_MASKED_EZ_STOP           0x00000002
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_SPI_EC_MASKED_EZ_WRITE_STOP     0x00000004
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_SPI_EC_MASKED_EZ_READ_STOP      0x00000008

#define SCB_INTR_M_ADDR                              0x00000f00
#define SCB_INTR_M_MASK                              0x00000317
/** I2C master lost arbitration. @multiple */
  #define SCB_INTR_M_I2C_ARB_LOST                  0x00000001
/** I2C master negative acknowledgement. @multiple */
  #define SCB_INTR_M_I2C_NACK                      0x00000002
/** I2C master acknowledgement. @multiple */
  #define SCB_INTR_M_I2C_ACK                       0x00000004
/** I2C master STOP. @multiple */
  #define SCB_INTR_M_I2C_STOP                      0x00000010
/** I2C master bus error. @multiple */
  #define SCB_INTR_M_I2C_BUS_ERROR                 0x00000100
/** SPI master transfer done event. @multiple */
  #define SCB_INTR_M_SPI_DONE                      0x00000200

#define SCB_INTR_M_SET_ADDR                          0x00000f04
#define SCB_INTR_M_SET_MASK                          0x00000317
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_M_SET_I2C_ARB_LOST              0x00000001
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_M_SET_I2C_NACK                  0x00000002
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_M_SET_I2C_ACK                   0x00000004
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_M_SET_I2C_STOP                  0x00000010
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_M_SET_I2C_BUS_ERROR             0x00000100
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_M_SET_SPI_DONE                  0x00000200

#define SCB_INTR_M_MASK_ADDR                         0x00000f08
#define SCB_INTR_M_MASK_MASK                         0x00000317
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_M_MASK_I2C_ARB_LOST             0x00000001
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_M_MASK_I2C_NACK                 0x00000002
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_M_MASK_I2C_ACK                  0x00000004
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_M_MASK_I2C_STOP                 0x00000010
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_M_MASK_I2C_BUS_ERROR            0x00000100
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_M_MASK_SPI_DONE                 0x00000200

#define SCB_INTR_M_MASKED_ADDR                       0x00000f0c
#define SCB_INTR_M_MASKED_MASK                       0x00000317
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_M_MASKED_I2C_ARB_LOST           0x00000001
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_M_MASKED_I2C_NACK               0x00000002
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_M_MASKED_I2C_ACK                0x00000004
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_M_MASKED_I2C_STOP               0x00000010
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_M_MASKED_I2C_BUS_ERROR          0x00000100
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_M_MASKED_SPI_DONE               0x00000200

#define SCB_INTR_S_ADDR                              0x00000f40
#define SCB_INTR_S_MASK                              0x00000fff
/** I2C slave lost arbitration. @multiple */
  #define SCB_INTR_S_I2C_ARB_LOST                  0x00000001
/** I2C slave negative acknowledgement received. @multiple */
  #define SCB_INTR_S_I2C_NACK                      0x00000002
/** I2C slave acknowledgement received. @multiple */
  #define SCB_INTR_S_I2C_ACK                       0x00000004
/** I2C STOP event for I2C write transfer intended for this slave (address
   matching is performed). @multiple */
  #define SCB_INTR_S_I2C_WRITE_STOP                0x00000008
/** I2C STOP event for I2C (read or write) transfer intended for this slave.
   @multiple */
  #define SCB_INTR_S_I2C_STOP                      0x00000010
/** I2C slave START received. @multiple */
  #define SCB_INTR_S_I2C_START                     0x00000020
/** I2C slave matching address received. @multiple */
  #define SCB_INTR_S_I2C_ADDR_MATCH                0x00000040
/** I2C slave general call address received. @multiple */
  #define SCB_INTR_S_I2C_GENERAL                   0x00000080
/** I2C slave bus error (unexpected detection of START or STOP condition).
   @multiple */
  #define SCB_INTR_S_I2C_BUS_ERROR                 0x00000100
/** SPI slave deselected after a write EZ SPI transfer occurred. @multiple */
  #define SCB_INTR_S_SPI_EZ_WRITE_STOP             0x00000200
/** SPI slave deselected after any EZ SPI transfer occurred. @multiple */
  #define SCB_INTR_S_SPI_EZ_STOP                   0x00000400
/** SPI slave deselected at an unexpected time in the SPI transfer. @multiple */
  #define SCB_INTR_S_SPI_BUS_ERROR                 0x00000800

#define SCB_INTR_S_SET_ADDR                          0x00000f44
#define SCB_INTR_S_SET_MASK                          0x00000fff
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_S_SET_I2C_ARB_LOST              0x00000001
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_S_SET_I2C_NACK                  0x00000002
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_S_SET_I2C_ACK                   0x00000004
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_S_SET_I2C_WRITE_STOP            0x00000008
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_S_SET_I2C_STOP                  0x00000010
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_S_SET_I2C_START                 0x00000020
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_S_SET_I2C_ADDR_MATCH            0x00000040
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_S_SET_I2C_GENERAL               0x00000080
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_S_SET_I2C_BUS_ERROR             0x00000100
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_S_SET_SPI_EZ_WRITE_STOP         0x00000200
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_S_SET_SPI_EZ_STOP               0x00000400
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_S_SET_SPI_BUS_ERROR             0x00000800

#define SCB_INTR_S_MASK_ADDR                         0x00000f48
#define SCB_INTR_S_MASK_MASK                         0x00000fff
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_S_MASK_I2C_ARB_LOST             0x00000001
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_S_MASK_I2C_NACK                 0x00000002
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_S_MASK_I2C_ACK                  0x00000004
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_S_MASK_I2C_WRITE_STOP           0x00000008
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_S_MASK_I2C_STOP                 0x00000010
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_S_MASK_I2C_START                0x00000020
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_S_MASK_I2C_ADDR_MATCH           0x00000040
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_S_MASK_I2C_GENERAL              0x00000080
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_S_MASK_I2C_BUS_ERROR            0x00000100
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_S_MASK_SPI_EZ_WRITE_STOP        0x00000200
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_S_MASK_SPI_EZ_STOP              0x00000400
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_S_MASK_SPI_BUS_ERROR            0x00000800

#define SCB_INTR_S_MASKED_ADDR                       0x00000f4c
#define SCB_INTR_S_MASKED_MASK                       0x00000fff
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_S_MASKED_I2C_ARB_LOST           0x00000001
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_S_MASKED_I2C_NACK               0x00000002
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_S_MASKED_I2C_ACK                0x00000004
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_S_MASKED_I2C_WRITE_STOP         0x00000008
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_S_MASKED_I2C_STOP               0x00000010
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_S_MASKED_I2C_START              0x00000020
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_S_MASKED_I2C_ADDR_MATCH         0x00000040
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_S_MASKED_I2C_GENERAL            0x00000080
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_S_MASKED_I2C_BUS_ERROR          0x00000100
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_S_MASKED_SPI_EZ_WRITE_STOP      0x00000200
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_S_MASKED_SPI_EZ_STOP            0x00000400
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_S_MASKED_SPI_BUS_ERROR          0x00000800

#define SCB_INTR_TX_ADDR                             0x00000f80
#define SCB_INTR_TX_MASK                             0x000007f3
/** Less entries in the TX FIFO than the value specified by TX_FIFO_CTRL. Only
   used in FIFO mode. @multiple */
  #define SCB_INTR_TX_TRIGGER                      0x00000001
/** TX FIFO is not full. @multiple */
  #define SCB_INTR_TX_NOT_FULL                     0x00000002
/** TX FIFO is empty; i.e. it has 0 entries. Only used in FIFO mode. @multiple */
  #define SCB_INTR_TX_EMPTY                        0x00000010
/** Attempt to write to a full TX FIFO. Only used in FIFO mode. @multiple */
  #define SCB_INTR_TX_OVERFLOW                     0x00000020
/** Attempt to read from an empty TX FIFO. This happens when the IP is ready to
   transfer data and EMPTY is '1'. Only used in FIFO mode. @multiple */
  #define SCB_INTR_TX_UNDERFLOW                    0x00000040
/** AHB-Lite write transfer can not get access to the EZ memory (EZ data access),
   due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is
   '1'. @multiple */
  #define SCB_INTR_TX_BLOCKED                      0x00000080
/** UART transmitter received a negative acknowledgement in SmartCard mode.
   @multiple */
  #define SCB_INTR_TX_UART_NACK                    0x00000100
/** UART transmitter done. @multiple */
  #define SCB_INTR_TX_UART_DONE                    0x00000200
/** UART lost arbitration. @multiple */
  #define SCB_INTR_TX_UART_ARB_LOST                0x00000400

#define SCB_INTR_TX_SET_ADDR                         0x00000f84
#define SCB_INTR_TX_SET_MASK                         0x000007f3
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_TX_SET_TRIGGER                  0x00000001
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_TX_SET_NOT_FULL                 0x00000002
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_TX_SET_EMPTY                    0x00000010
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_TX_SET_OVERFLOW                 0x00000020
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_TX_SET_UNDERFLOW                0x00000040
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_TX_SET_BLOCKED                  0x00000080
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_TX_SET_UART_NACK                0x00000100
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_TX_SET_UART_DONE                0x00000200
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_TX_SET_UART_ARB_LOST            0x00000400

#define SCB_INTR_TX_MASK_ADDR                        0x00000f88
#define SCB_INTR_TX_MASK_MASK                        0x000007f3
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_TX_MASK_TRIGGER                 0x00000001
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_TX_MASK_NOT_FULL                0x00000002
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_TX_MASK_EMPTY                   0x00000010
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_TX_MASK_OVERFLOW                0x00000020
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_TX_MASK_UNDERFLOW               0x00000040
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_TX_MASK_BLOCKED                 0x00000080
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_TX_MASK_UART_NACK               0x00000100
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_TX_MASK_UART_DONE               0x00000200
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_TX_MASK_UART_ARB_LOST           0x00000400

#define SCB_INTR_TX_MASKED_ADDR                      0x00000f8c
#define SCB_INTR_TX_MASKED_MASK                      0x000007f3
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_TX_MASKED_TRIGGER               0x00000001
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_TX_MASKED_NOT_FULL              0x00000002
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_TX_MASKED_EMPTY                 0x00000010
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_TX_MASKED_OVERFLOW              0x00000020
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_TX_MASKED_UNDERFLOW             0x00000040
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_TX_MASKED_BLOCKED               0x00000080
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_TX_MASKED_UART_NACK             0x00000100
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_TX_MASKED_UART_DONE             0x00000200
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_TX_MASKED_UART_ARB_LOST         0x00000400

#define SCB_INTR_RX_ADDR                             0x00000fc0
#define SCB_INTR_RX_MASK                             0x00000fed
/** More entries in the RX FIFO than the value specified by TRIGGER_LEVEL in
   SCB_RX_FIFO_CTL. Only used in FIFO mode. @multiple */
  #define SCB_INTR_RX_TRIGGER                      0x00000001
/** RX FIFO is not empty. Only used in FIFO mode. @multiple */
  #define SCB_INTR_RX_NOT_EMPTY                    0x00000004
/** RX FIFO is full. @multiple */
  #define SCB_INTR_RX_FULL                         0x00000008
/** Attempt to write to a full RX FIFO. Only used in FIFO mode. @multiple */
  #define SCB_INTR_RX_OVERFLOW                     0x00000020
/** Attempt to read from an empty RX FIFO. Only used in FIFO mode. @multiple */
  #define SCB_INTR_RX_UNDERFLOW                    0x00000040
/** AHB-Lite read transfer can not get access to the EZ memory (EZ_DATA
   accesses), due to an externally clocked EZ access. This may happen when
   STATUS.EC_BUSY is '1'. @multiple */
  #define SCB_INTR_RX_BLOCKED                      0x00000080
/** Frame error in received data frame. @multiple */
  #define SCB_INTR_RX_FRAME_ERROR                  0x00000100
/** Parity error in received data frame. @multiple */
  #define SCB_INTR_RX_PARITY_ERROR                 0x00000200
/** LIN baudrate detection is completed. @multiple */
  #define SCB_INTR_RX_BAUD_DETECT                  0x00000400
/** Break detection is successful. @multiple */
  #define SCB_INTR_RX_BREAK_DETECT                 0x00000800

#define SCB_INTR_RX_SET_ADDR                         0x00000fc4
#define SCB_INTR_RX_SET_MASK                         0x00000fed
/** Write with '1' to set corresponding bit in interrupt request register.
   @multiple */
  #define SCB_INTR_RX_SET_TRIGGER                  0x00000001
/** Write with '1' to set corresponding bit in interrupt status register.
   @multiple */
  #define SCB_INTR_RX_SET_NOT_EMPTY                0x00000004
/** Write with '1' to set corresponding bit in interrupt status register.
   @multiple */
  #define SCB_INTR_RX_SET_FULL                     0x00000008
/** Write with '1' to set corresponding bit in interrupt status register.
   @multiple */
  #define SCB_INTR_RX_SET_OVERFLOW                 0x00000020
/** Write with '1' to set corresponding bit in interrupt status register.
   @multiple */
  #define SCB_INTR_RX_SET_UNDERFLOW                0x00000040
/** Write with '1' to set corresponding bit in interrupt status register.
   @multiple */
  #define SCB_INTR_RX_SET_BLOCKED                  0x00000080
/** Write with '1' to set corresponding bit in interrupt status register.
   @multiple */
  #define SCB_INTR_RX_SET_FRAME_ERROR              0x00000100
/** Write with '1' to set corresponding bit in interrupt status register.
   @multiple */
  #define SCB_INTR_RX_SET_PARITY_ERROR             0x00000200
/** Write with '1' to set corresponding bit in interrupt status register.
   @multiple */
  #define SCB_INTR_RX_SET_BAUD_DETECT              0x00000400
/** Write with '1' to set corresponding bit in interrupt status register.
   @multiple */
  #define SCB_INTR_RX_SET_BREAK_DETECT             0x00000800

#define SCB_INTR_RX_MASK_ADDR                        0x00000fc8
#define SCB_INTR_RX_MASK_MASK                        0x00000fed
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_RX_MASK_TRIGGER                 0x00000001
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_RX_MASK_NOT_EMPTY               0x00000004
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_RX_MASK_FULL                    0x00000008
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_RX_MASK_OVERFLOW                0x00000020
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_RX_MASK_UNDERFLOW               0x00000040
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_RX_MASK_BLOCKED                 0x00000080
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_RX_MASK_FRAME_ERROR             0x00000100
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_RX_MASK_PARITY_ERROR            0x00000200
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_RX_MASK_BAUD_DETECT             0x00000400
/** Mask bit for corresponding bit in interrupt request register. @multiple */
  #define SCB_INTR_RX_MASK_BREAK_DETECT            0x00000800

#define SCB_INTR_RX_MASKED_ADDR                      0x00000fcc
#define SCB_INTR_RX_MASKED_MASK                      0x00000fed
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_RX_MASKED_TRIGGER               0x00000001
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_RX_MASKED_NOT_EMPTY             0x00000004
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_RX_MASKED_FULL                  0x00000008
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_RX_MASKED_OVERFLOW              0x00000020
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_RX_MASKED_UNDERFLOW             0x00000040
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_RX_MASKED_BLOCKED               0x00000080
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_RX_MASKED_FRAME_ERROR           0x00000100
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_RX_MASKED_PARITY_ERROR          0x00000200
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_RX_MASKED_BAUD_DETECT           0x00000400
/** Logical and of corresponding request and mask bits. @multiple */
  #define SCB_INTR_RX_MASKED_BREAK_DETECT          0x00000800

#endif

