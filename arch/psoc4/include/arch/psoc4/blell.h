/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -I blell.bf -O blell.h -o cdefs cdefs_use_reg_mask=1                  \
     cdefs_use_field_setval=1
*/

#ifndef _BLELL_BFGEN_DEFS_
#define _BLELL_BFGEN_DEFS_

#define BLELL_COMMAND_ADDR                           0x00000000
#define BLELL_COMMAND_MASK                           0x000000ff
/** 8-bit command from firmware to the link layer controller. See below for the
   list of instructions and their opcodes. The instruction results in the link
   layer hardware starting/stopping an operation. Notes on use Few of the
   commands will require other configuration registers to be set, before the
   command is written. Refer to the description below for details of the
   registers to be set before setting these instructions. @multiple */
  #define BLELL_COMMAND_COMMAND(v)                 ((BLELL_COMMAND_COMMAND_##v) << 0)
  #define BLELL_COMMAND_COMMAND_SET(x, v)          do { (x) = (((x) & ~0xff) | ((BLELL_COMMAND_COMMAND_##v) << 0)); } while(0)
  #define BLELL_COMMAND_COMMAND_SETVAL(x, v)       do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define BLELL_COMMAND_COMMAND_GET(x)             (((x) >> 0) & 0xff)
/** Start Advertiser operation. The associated Advertiser configuration registers are programmed before the command is issued */
    #define BLELL_COMMAND_COMMAND_START_ADV          0x00000040
/** Stop advertiser operation */
    #define BLELL_COMMAND_COMMAND_STOP_ADV           0x00000041
/** Start scanner operation. The associated configuration registers must be programmed before the command is issued */
    #define BLELL_COMMAND_COMMAND_START_SCAN         0x00000042
/** Stop the scanner operation */
    #define BLELL_COMMAND_COMMAND_STOP_SCAN          0x00000043
/** Start connection creation operation. The associated configuration registers must be programmed before the command is issued */
    #define BLELL_COMMAND_COMMAND_START_INIT         0x00000044
/** Cancel connection creation operation */
    #define BLELL_COMMAND_COMMAND_STOP_INIT          0x00000045
/** Start Direct Test Mode Transmit Test. The associated configuration registers must be programmed before the command is issued */
    #define BLELL_COMMAND_COMMAND_DTM_TX_START       0x00000046
/** Start Direct Test Mode Receive Test. The associated configuration registers must be programmed before the command is issued */
    #define BLELL_COMMAND_COMMAND_DTM_RX_START       0x00000047
/** Stop Direct Test Mode */
    #define BLELL_COMMAND_COMMAND_DTM_STOP           0x00000048
/** Update channel map for the connection */
    #define BLELL_COMMAND_COMMAND_UPDATE_CHAN_MAP    0x0000004b
/** Start connection update procedure for the connection */
    #define BLELL_COMMAND_COMMAND_UPDATE_CONN_PROC   0x0000004c
/** Indicates a received connection packet is read by firmware from connection receive FIFO */
    #define BLELL_COMMAND_COMMAND_PACKET_RECEIVED    0x0000004d
/** Enter deep sleep mode */
    #define BLELL_COMMAND_COMMAND_ENTER_DSM          0x00000050
/** Enter sleep mode */
    #define BLELL_COMMAND_COMMAND_CORE_CLK_OFF       0x00000051
/** Exit sleep mode */
    #define BLELL_COMMAND_COMMAND_CORE_CLK_ON        0x00000052
/** Turn on clock to encryption block */
    #define BLELL_COMMAND_COMMAND_ENC_CLK_ON         0x00000053
/** Turn off clock to encryption block */
    #define BLELL_COMMAND_COMMAND_ENC_CLK_OFF        0x00000054
/** Turn on clock to advertiser block in NAP mode */
    #define BLELL_COMMAND_COMMAND_ADV_CLK_ON         0x00000055
/** Turn off clock to advertiser block in NAP mode */
    #define BLELL_COMMAND_COMMAND_ADV_CLK_OFF        0x00000056
/** Turn on clock to scanner block in NAP mode */
    #define BLELL_COMMAND_COMMAND_SCAN_CLK_ON        0x00000057
/** Turn off clock to scanner block in NAP mode */
    #define BLELL_COMMAND_COMMAND_SCAN_CLK_OFF       0x00000058
/** Turn on clock to initiator block in NAP mode */
    #define BLELL_COMMAND_COMMAND_INIT_CLK_ON        0x00000059
/** Turn off clock to initiator block in NAP mode */
    #define BLELL_COMMAND_COMMAND_INIT_CLK_OFF       0x0000005a
/** Turn on clock to connection block in NAP mode */
    #define BLELL_COMMAND_COMMAND_CONN_CLK_ON        0x0000005b
/** Turn off clock to connection  block in NAP mode */
    #define BLELL_COMMAND_COMMAND_CONN_CLK_OFF       0x0000005c
/** Update connection parameters. Deprecated */
    #define BLELL_COMMAND_COMMAND_UPDATE_CONN        0x00000068
/** Kill connection immediately */
    #define BLELL_COMMAND_COMMAND_KILL_CONN          0x00000070
/** Kill connection after a transmit operation is over */
    #define BLELL_COMMAND_COMMAND_KILL_CONN_AFTER_TX 0x00000071
/** Start PDU response timer. The PDU_RESP_TIMER register must be programmed with timeout value before issuing this command */
    #define BLELL_COMMAND_COMMAND_RESP_TIMER_ON      0x00000072
/** Stop PDU response timer */
    #define BLELL_COMMAND_COMMAND_RESP_TIMER_OFF     0x00000073
/** Reset the white list memory read pointer to 0 */
    #define BLELL_COMMAND_COMMAND_RESET_READ_PTR     0x00000074
/** Start connection ping timer */
    #define BLELL_COMMAND_COMMAND_CONN_PING_TIMER_ON 0x00000075
/** Stop connection ping timer */
    #define BLELL_COMMAND_COMMAND_CONN_PING_TIMER_OFF 0x00000076
/** Software reset. Resets all the hardware registers (except a few registers related to radio initialization) */
    #define BLELL_COMMAND_COMMAND_SOFT_RESET         0x00000080
/** Reset microsecond counter */
    #define BLELL_COMMAND_COMMAND_RESET_US_COUNTER   0x000000c3

#define BLELL_EVENT_INTR_ADDR                        0x00000008
#define BLELL_EVENT_INTR_MASK                        0x0000007f
/** Advertiser interrupt. If bit is set to 1, it indicates an event occurred in
   the advertising procedure. The source of the event needs to be read from the
   ADV_INTR register. This bit is cleared, when firmware clears ALL interrupts by
   writing to the ADV_INTR register. @multiple */
  #define BLELL_EVENT_INTR_ADV_INTR                0x0001
/** Scanner interrupt. If bit is set to 1, it indicates an event occurred in the
   scanning procedure. The source of the event needs to be read from the
   SCAN_INTR register. This bit is cleared, when firmware clears ALL interrupts
   by writing to the SCAN_INTR register. @multiple */
  #define BLELL_EVENT_INTR_SCAN_INTR               0x0002
/** Initiator interrupt. If bit is set to 1, it indicates an event occurred in
   the initiating procedure. The source of the event needs to be read from the
   INIT_INTR register. This bit is cleared, when firmware clears ALL interrupts
   by writing to the INIT_INTR register. @multiple */
  #define BLELL_EVENT_INTR_INIT_INTR               0x0004
/** Connection interrupt. If bit is set to 1, it indicates an event occurred in
   the connection operation. This interrupt is aggregation of interrupts for all
   the connections. The source of the event for the specific connection, needs to
   be read from the CONN_INTR register specific to the connection. This bit is
   cleared, when firmware clears ALL interrupts by writing to the CONN_INTR
   register. @multiple */
  #define BLELL_EVENT_INTR_CONN_INTR               0x0008
/** Sleep-mode-exit interrupt. This bit is set, when link layer hardware exits
   from sleep mode. Write: Clear sleep-mode-exit interrupt. Write 1 to clear.
   @multiple */
  #define BLELL_EVENT_INTR_SM_INTR                 0x0010
/** Deep sleep mode exit interrupt. This bit is set, when link layer hardware
   exits from deep sleep mode. Write 1 to clear. @multiple */
  #define BLELL_EVENT_INTR_DSM_INTR                0x0020
/** Encryption module interrupt. @multiple */
  #define BLELL_EVENT_INTR_ENC_INTR                0x0040

#define BLELL_EVENT_ENABLE_ADDR                      0x00000010
#define BLELL_EVENT_ENABLE_MASK                      0x0000007f
/** Advertiser interrupt enable @multiple */
  #define BLELL_EVENT_ENABLE_ADV_INT_EN            0x0001
/** Scanner interrupt enable @multiple */
  #define BLELL_EVENT_ENABLE_SCN_INT_EN            0x0002
/** Initiator interrupt enable @multiple */
  #define BLELL_EVENT_ENABLE_INIT_INT_EN           0x0004
/** Connection interrupt enable @multiple */
  #define BLELL_EVENT_ENABLE_CONN_INT_EN           0x0008
/** Sleep-mode-exit interrupt enable @multiple */
  #define BLELL_EVENT_ENABLE_SM_INT_EN             0x0010
/** Deep Sleep-mode-exit interrupt enable @multiple */
  #define BLELL_EVENT_ENABLE_DSM_INT_EN            0x0020
/** Encryption module interrupt enable @multiple */
  #define BLELL_EVENT_ENABLE_ENC_INT_EN            0x0040

#define BLELL_ADV_PARAMS_ADDR                        0x00000018
#define BLELL_ADV_PARAMS_MASK                        0x000085ff
/** Device own address type. @multiple */
  #define BLELL_ADV_PARAMS_TX_ADDR(v)              ((BLELL_ADV_PARAMS_TX_ADDR_##v) << 0)
  #define BLELL_ADV_PARAMS_TX_ADDR_SET(x, v)       do { (x) = (((x) & ~0x1) | ((BLELL_ADV_PARAMS_TX_ADDR_##v) << 0)); } while(0)
  #define BLELL_ADV_PARAMS_TX_ADDR_SETVAL(x, v)    do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define BLELL_ADV_PARAMS_TX_ADDR_GET(x)          (((x) >> 0) & 0x1)
/** Address type is public */
    #define BLELL_ADV_PARAMS_TX_ADDR_PUBLIC          0x00000000
/** Address type is random */
    #define BLELL_ADV_PARAMS_TX_ADDR_RANDOM          0x00000001
/** Advertising packet type @multiple */
  #define BLELL_ADV_PARAMS_ADV_TYPE(v)             ((BLELL_ADV_PARAMS_ADV_TYPE_##v) << 1)
  #define BLELL_ADV_PARAMS_ADV_TYPE_SET(x, v)      do { (x) = (((x) & ~0x6) | ((BLELL_ADV_PARAMS_ADV_TYPE_##v) << 1)); } while(0)
  #define BLELL_ADV_PARAMS_ADV_TYPE_SETVAL(x, v)   do { (x) = (((x) & ~0x6) | ((v) << 1)); } while(0)
  #define BLELL_ADV_PARAMS_ADV_TYPE_GET(x)         (((x) >> 1) & 0x3)
/** Connectable undirected advertising */
    #define BLELL_ADV_PARAMS_ADV_TYPE_ADV_IND        0x00000000
/** Connectable directed advertising */
    #define BLELL_ADV_PARAMS_ADV_TYPE_ADV_DIRECT_IND 0x00000001
/** Discoverable undirected advertising */
    #define BLELL_ADV_PARAMS_ADV_TYPE_ADV_DISCOVER_IND 0x00000002
/** Non connectable undirected advertising */
    #define BLELL_ADV_PARAMS_ADV_TYPE_ADV_NONCONN_ADV 0x00000003
/** Allow scan request from white-listed devices only @multiple */
  #define BLELL_ADV_PARAMS_SCAN_WHITE_LIST         0x0008
/** Allow connection request from white-listed devices only @multiple */
  #define BLELL_ADV_PARAMS_CONN_WHITE_LIST         0x0010
/** Enable channel 37 for advertising @multiple */
  #define BLELL_ADV_PARAMS_ADV_CHANNEL_37          0x0020
/** Enable channel 38 for advertising @multiple */
  #define BLELL_ADV_PARAMS_ADV_CHANNEL_38          0x0040
/** Enable channel 39 for advertising @multiple */
  #define BLELL_ADV_PARAMS_ADV_CHANNEL_39          0x0080
/** Peer addresses type. This is the Direct_Address_type field programmed, only
   if ADV_DIRECT_IND type is sent. @multiple */
  #define BLELL_ADV_PARAMS_RX_ADDR(v)              ((BLELL_ADV_PARAMS_RX_ADDR_##v) << 8)
  #define BLELL_ADV_PARAMS_RX_ADDR_SET(x, v)       do { (x) = (((x) & ~0x100) | ((BLELL_ADV_PARAMS_RX_ADDR_##v) << 8)); } while(0)
  #define BLELL_ADV_PARAMS_RX_ADDR_SETVAL(x, v)    do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define BLELL_ADV_PARAMS_RX_ADDR_GET(x)          (((x) >> 8) & 0x1)
/** Rx addr type is public */
    #define BLELL_ADV_PARAMS_RX_ADDR_PUBLIC          0x00000000
/** Rx addr type is random. */
    #define BLELL_ADV_PARAMS_RX_ADDR_RANDOM          0x00000001
/** This bit field is used to specify to the Controller the Low Duty Cycle
   connectable directed advertising variant being used @multiple */
  #define BLELL_ADV_PARAMS_ADV_LOW_DUTY_CYCLE      0x0400
/** Transmit address field of the received packet extracted from the receive
   packet. This field is used by firmware to report peer_addr_type parameter in
   the connection complete event. @multiple */
  #define BLELL_ADV_PARAMS_RCV_TX_ADDR             0x8000

#define BLELL_ADV_INTERVAL_TIMEOUT_ADDR              0x0000001c
#define BLELL_ADV_INTERVAL_TIMEOUT_MASK              0x00007fff
/** Time in 0.625 msec steps. Minimum is 160 for ADV_SCAN_IND and NONCONN_IND.
   For directed advertising, firmware programs the default value of 1.28 seconds
   @multiple */
  #define BLELL_ADV_INTERVAL_TIMEOUT_ADV_INTERVAL(v) ((v) << 0)
  #define BLELL_ADV_INTERVAL_TIMEOUT_ADV_INTERVAL_SET(x, v) do { (x) = (((x) & ~0x7fff) | ((v) << 0)); } while(0)
  #define BLELL_ADV_INTERVAL_TIMEOUT_ADV_INTERVAL_GET(x) (((x) >> 0) & 0x7fff)

#define BLELL_ADV_INTR_ADDR                          0x00000020
#define BLELL_ADV_INTR_MASK                          0x000001ff
/** A new advertising event started after interval expiry. Write 1 to clear.
   @multiple */
  #define BLELL_ADV_INTR_ADV_STRT_INTR             0x0001
/** Current advertising event is closed. Write 1 to clear. @multiple */
  #define BLELL_ADV_INTR_ADV_CLOSE_INTR            0x0002
/** ADV packet is transmitted. Write 1 to clear. @multiple */
  #define BLELL_ADV_INTR_ADV_TX_INTR               0x0004
/** Scan response packet transmitted in response to previously received scan
   request packet. Write 1 to clear. @multiple */
  #define BLELL_ADV_INTR_SCAN_RSP_TX_INTR          0x0008
/** Scan request packet received. Write 1 to clear. @multiple */
  #define BLELL_ADV_INTR_SCAN_REQ_RX_INTR          0x0010
/** Connect request packet is received. Write 1 to clear. @multiple */
  #define BLELL_ADV_INTR_CONN_REQ_RX_INTR          0x0020
/** Connection is created as slave. Write 1 to clear. @multiple */
  #define BLELL_ADV_INTR_SLV_CONNECTED             0x0040
/** The directed advertising event has timed out after 1.28 seconds. Applicable
   in adv_direct_ind advertising. Write 1 to clear. @multiple */
  #define BLELL_ADV_INTR_ADV_TIMEOUT               0x0080
/** Advertiser procedure is ON in hardware. @multiple */
  #define BLELL_ADV_INTR_ADV_ON                    0x0100

/** Shows the next start of advertising event with reference to the internal
   reference clock. @multiple */
#define BLELL_ADV_NEXT_INSTANT_ADDR                  0x00000024
#define BLELL_ADV_NEXT_INSTANT_MASK                  0x00000000

/** Scan interval time in 0.625 msec steps. Interval between two consecutive
   scanning events. Firmware sets the scanning interval value to this register
   before issuing start scan command. @multiple */
#define BLELL_SCAN_INTERVAL_ADDR                     0x00000028
#define BLELL_SCAN_INTERVAL_MASK                     0x00000000

/** Scan window duration time in 0.625 msec steps. Firmware sets the scan window
   value to this register before issuing start scan command. @multiple */
#define BLELL_SCAN_WINDOW_ADDR                       0x0000002c
#define BLELL_SCAN_WINDOW_MASK                       0x00000000

#define BLELL_SCAN_PARAM_ADDR                        0x00000030
#define BLELL_SCAN_PARAM_MASK                        0x0000003f
/** Devices own address type @multiple */
  #define BLELL_SCAN_PARAM_TX_ADDR(v)              ((BLELL_SCAN_PARAM_TX_ADDR_##v) << 0)
  #define BLELL_SCAN_PARAM_TX_ADDR_SET(x, v)       do { (x) = (((x) & ~0x1) | ((BLELL_SCAN_PARAM_TX_ADDR_##v) << 0)); } while(0)
  #define BLELL_SCAN_PARAM_TX_ADDR_SETVAL(x, v)    do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define BLELL_SCAN_PARAM_TX_ADDR_GET(x)          (((x) >> 0) & 0x1)
/** addr type is public */
    #define BLELL_SCAN_PARAM_TX_ADDR_PUBLIC          0x00000000
/** addr type is random */
    #define BLELL_SCAN_PARAM_TX_ADDR_RANDOM          0x00000001
  #define BLELL_SCAN_PARAM_SCAN_TYPE(v)            ((BLELL_SCAN_PARAM_SCAN_TYPE_##v) << 1)
  #define BLELL_SCAN_PARAM_SCAN_TYPE_SET(x, v)     do { (x) = (((x) & ~0x6) | ((BLELL_SCAN_PARAM_SCAN_TYPE_##v) << 1)); } while(0)
  #define BLELL_SCAN_PARAM_SCAN_TYPE_SETVAL(x, v)  do { (x) = (((x) & ~0x6) | ((v) << 1)); } while(0)
  #define BLELL_SCAN_PARAM_SCAN_TYPE_GET(x)        (((x) >> 1) & 0x3)
/** passive scanning */
    #define BLELL_SCAN_PARAM_SCAN_TYPE_PASSIVE       0x00000000
/** active scanning */
    #define BLELL_SCAN_PARAM_SCAN_TYPE_ACTIVE        0x00000001
/** Policy for processing packets in the scanner. ADV_DIRECT_IND packets which
   are not addressed to this device are ignored. @multiple */
  #define BLELL_SCAN_PARAM_SCAN_FILT_POLICY(v)     ((BLELL_SCAN_PARAM_SCAN_FILT_POLICY_##v) << 3)
  #define BLELL_SCAN_PARAM_SCAN_FILT_POLICY_SET(x, v) do { (x) = (((x) & ~0x18) | ((BLELL_SCAN_PARAM_SCAN_FILT_POLICY_##v) << 3)); } while(0)
  #define BLELL_SCAN_PARAM_SCAN_FILT_POLICY_SETVAL(x, v) do { (x) = (((x) & ~0x18) | ((v) << 3)); } while(0)
  #define BLELL_SCAN_PARAM_SCAN_FILT_POLICY_GET(x) (((x) >> 3) & 0x3)
/** Accept advertising packets from any device. */
    #define BLELL_SCAN_PARAM_SCAN_FILT_POLICY_ANY    0x00000000
/** Accept advertising packets from only devices in the whitelist */
    #define BLELL_SCAN_PARAM_SCAN_FILT_POLICY_WHITELIST 0x00000001
/** Whether to filter duplicate packets @multiple */
  #define BLELL_SCAN_PARAM_DUP_FILT_EN             0x0020

#define BLELL_SCAN_INTR_ADDR                         0x00000038
#define BLELL_SCAN_INTR_MASK                         0x0000011f
/** scan window is opened. Write 1 to clear. @multiple */
  #define BLELL_SCAN_INTR_SCAN_STRT_INTR           0x0001
/** scan window is closed. Write 1 to clear. @multiple */
  #define BLELL_SCAN_INTR_SCAN_CLOSE_INTR          0x0002
/** scan request packet is transmitted. Write 1 to clear. @multiple */
  #define BLELL_SCAN_INTR_SCAN_TX_INTR             0x0004
/** ADV packet received. Firmware can read the content of the packet from the
   INIT_SCN_ADV_RX_FIFO. This interrupt is generated while active/passive
   scanning upon receiving adv packets. Write 1 to clear. @multiple */
  #define BLELL_SCAN_INTR_ADV_RX_INTR              0x0008
/** SCAN_RSP packet is received. Firmware can read the content of the packet from
   the INIT_SCN_ADV_RX_FIFO. This interrupt is generated while active scanning
   upon receiving scan response packet. Write 1 to clear. @multiple */
  #define BLELL_SCAN_INTR_SCAN_RSP_RX_INTR         0x0010
/** Whether Scan procedure is active @multiple */
  #define BLELL_SCAN_INTR_SCAN_ON                  0x0100

/** Shows the instant with respect to internal reference clock of resolution 625
   us at which next scanning event begins. @multiple */
#define BLELL_SCAN_NEXT_INSTANT_ADDR                 0x0000003c
#define BLELL_SCAN_NEXT_INSTANT_MASK                 0x00000000

/** Initiator interval in 0.625 msec steps. Interval between two consecutive
   scanning events. Firmware sets the initiators scanning interval value to this
   register before issuing create connection command. @multiple */
#define BLELL_INIT_INTERVAL_ADDR                     0x00000040
#define BLELL_INIT_INTERVAL_MASK                     0x00000000

/** Duration of scan in a scanning event in 0.625 msec steps. This should be less
   than or equal to scan interval value. Firmware sets the scan window value to
   this register before issuing create connection command. @multiple */
#define BLELL_INIT_WINDOW_ADDR                       0x00000044
#define BLELL_INIT_WINDOW_MASK                       0x00000000

#define BLELL_INIT_PARAM_ADDR                        0x00000048
#define BLELL_INIT_PARAM_MASK                        0x0000000b
/** Device own address type. @multiple */
  #define BLELL_INIT_PARAM_TX_ADDR(v)              ((BLELL_INIT_PARAM_TX_ADDR_##v) << 0)
  #define BLELL_INIT_PARAM_TX_ADDR_SET(x, v)       do { (x) = (((x) & ~0x1) | ((BLELL_INIT_PARAM_TX_ADDR_##v) << 0)); } while(0)
  #define BLELL_INIT_PARAM_TX_ADDR_SETVAL(x, v)    do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define BLELL_INIT_PARAM_TX_ADDR_GET(x)          (((x) >> 0) & 0x1)
/** addr type is public. */
    #define BLELL_INIT_PARAM_TX_ADDR_PUBLIC          0x00000000
/** addr type is random. */
    #define BLELL_INIT_PARAM_TX_ADDR_RANDOM          0x00000001
/** Peer address type. This field is updated by the receiver with the address
   type of the received connectable advertising packet. @multiple */
  #define BLELL_INIT_PARAM_RX_ADDR(v)              ((BLELL_INIT_PARAM_RX_ADDR_##v) << 1)
  #define BLELL_INIT_PARAM_RX_ADDR_SET(x, v)       do { (x) = (((x) & ~0x2) | ((BLELL_INIT_PARAM_RX_ADDR_##v) << 1)); } while(0)
  #define BLELL_INIT_PARAM_RX_ADDR_SETVAL(x, v)    do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define BLELL_INIT_PARAM_RX_ADDR_GET(x)          (((x) >> 1) & 0x1)
/** addr type is public. */
    #define BLELL_INIT_PARAM_RX_ADDR_PUBLIC          0x00000000
/** addr type is random. */
    #define BLELL_INIT_PARAM_RX_ADDR_RANDOM          0x00000001
/** This is used to determine whether the White List is used or not. If not, the
   PEER_ADDRESS_TYPE and PEER_ADDRESS fields are used to specify the address type
   and address of the advertising device to connect to. @multiple */
  #define BLELL_INIT_PARAM_INIT_FILT_POLICY(v)     ((BLELL_INIT_PARAM_INIT_FILT_POLICY_##v) << 3)
  #define BLELL_INIT_PARAM_INIT_FILT_POLICY_SET(x, v) do { (x) = (((x) & ~0x8) | ((BLELL_INIT_PARAM_INIT_FILT_POLICY_##v) << 3)); } while(0)
  #define BLELL_INIT_PARAM_INIT_FILT_POLICY_SETVAL(x, v) do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define BLELL_INIT_PARAM_INIT_FILT_POLICY_GET(x) (((x) >> 3) & 0x1)
/** Use explicit peer address */
    #define BLELL_INIT_PARAM_INIT_FILT_POLICY_SPECIFIC 0x00000000
/** Connect to devices in the whitelist */
    #define BLELL_INIT_PARAM_INIT_FILT_POLICY_WHITELIST 0x00000001

#define BLELL_INIT_INTR_ADDR                         0x00000050
#define BLELL_INIT_INTR_MASK                         0x00000017
/** Initiator scan window has started. Write 1 to clear. @multiple */
  #define BLELL_INIT_INTR_INIT_INTERVAL_EXPIRE_INTR 0x0001
/** Initiator scan window has finished. Write 1 to clear. @multiple */
  #define BLELL_INIT_INTR_INIT_CLOSE_WINDOW_INR    0x0002
/** Initiator packet (CONREQ) transmission has started. Write 1 to clear.
   @multiple */
  #define BLELL_INIT_INTR_INIT_TX_START_INTR       0x0004
/** Connection is created as master. Write 1 to clear. @multiple */
  #define BLELL_INIT_INTR_MASTER_CONN_CREATED      0x0010

/** Shows the instant with respect to internal reference clock of resolution 625
   us at which next initiator scanning event begins. @multiple */
#define BLELL_INIT_NEXT_INSTANT_ADDR                 0x00000054
#define BLELL_INIT_NEXT_INSTANT_MASK                 0x00000000

/** Lower 16 bit of 48-bit random address of the device. @multiple */
#define BLELL_DEVICE_RAND_ADDR_L_ADDR                0x00000058
#define BLELL_DEVICE_RAND_ADDR_L_MASK                0x00000000

/** Middle 16 bit of 48-bit random address of the device. @multiple */
#define BLELL_DEVICE_RAND_ADDR_M_ADDR                0x0000005c
#define BLELL_DEVICE_RAND_ADDR_M_MASK                0x00000000

/** Higher 16 bit of 48-bit random address of the device. @multiple */
#define BLELL_DEVICE_RAND_ADDR_H_ADDR                0x00000060
#define BLELL_DEVICE_RAND_ADDR_H_MASK                0x00000000

/** Lower 16 bit of 48-bit address of the peer device. The peer address registers
   are used for multiple purposes. The register is written by firmware to provide
   the peer address to be used for a hardware procedure. When firmware reads the
   register, it reads back peer address values updated by hardware. While doing
   directed Advertising, the firmware writes the peer address of the device
   specified by the DIRECT_ADDRESS parameter of the LE_SET_ADVERTISING_PARAMETERS
   command. While device is configured as an initiator without white list
   filtering, the peer address specified in the PEER_ADDRESS field of the create
   connection command is programmed into this register, which is used by hardware
   procedures. While device is configured as an initiator and white list is
   enabled, firmware can read this register to get the address of the peer device
   from which connectable ADV packet was received and to which the connection is
   created. When a connection is created as a slave, the firmware can read this
   register to get the address of the peer device to which connection is created.
   @multiple */
#define BLELL_PEER_ADDR_L_ADDR                       0x00000068
#define BLELL_PEER_ADDR_L_MASK                       0x00000000

/** Middle 16 bit of 48-bit address of the peer device. @multiple */
#define BLELL_PEER_ADDR_M_ADDR                       0x0000006c
#define BLELL_PEER_ADDR_M_MASK                       0x00000000

/** Higher 16 bit of 48-bit address of the peer device. @multiple */
#define BLELL_PEER_ADDR_H_ADDR                       0x00000070
#define BLELL_PEER_ADDR_H_MASK                       0x00000000

#define BLELL_WL_ADDR_TYPE_ADDR                      0x00000078
#define BLELL_WL_ADDR_TYPE_MASK                      0x000000ff
/** Address type corresponding to the device address stored. @multiple */
  #define BLELL_WL_ADDR_TYPE_WL_ADDR_TYPE_COUNT    8
  #define BLELL_WL_ADDR_TYPE_WL_ADDR_TYPE(fidx, v) ((BLELL_WL_ADDR_TYPE_WL_ADDR_TYPE_##v) << ((fidx) + 0))
  #define BLELL_WL_ADDR_TYPE_WL_ADDR_TYPE_SET(fidx, x, v) do { (x) = (((x) & ~(0x1 << ((fidx)))) | ((BLELL_WL_ADDR_TYPE_WL_ADDR_TYPE_##v) << ((fidx) + 0))); } while(0)
  #define BLELL_WL_ADDR_TYPE_WL_ADDR_TYPE_SETVAL(fidx, x, v) do { (x) = (((x) & ~(0x1 << ((fidx)))) | ((v) << ((fidx) + 0))); } while(0)
  #define BLELL_WL_ADDR_TYPE_WL_ADDR_TYPE_GET(fidx, x) (((x) >> ((fidx) + 0)) & 0x1)
/** Address type is public. */
  #define BLELL_WL_ADDR_TYPE_WL_ADDR_TYPE_PUBLIC   0x00000000
/** Address type is random. */
  #define BLELL_WL_ADDR_TYPE_WL_ADDR_TYPE_RANDOM   0x00000001

#define BLELL_WL_ENABLE_ADDR                         0x0000007c
#define BLELL_WL_ENABLE_MASK                         0x000000ff
/** Stores the valid entry bit corresponding to each of the eight device address
   stored in the whitelist. @multiple */
  #define BLELL_WL_ENABLE_WL_ENABLE_COUNT          8
  #define BLELL_WL_ENABLE_WL_ENABLE(fidx, v)       ((BLELL_WL_ENABLE_WL_ENABLE_##v) << ((fidx) + 0))
  #define BLELL_WL_ENABLE_WL_ENABLE_SET(fidx, x, v) do { (x) = (((x) & ~(0x1 << ((fidx)))) | ((BLELL_WL_ENABLE_WL_ENABLE_##v) << ((fidx) + 0))); } while(0)
  #define BLELL_WL_ENABLE_WL_ENABLE_SETVAL(fidx, x, v) do { (x) = (((x) & ~(0x1 << ((fidx)))) | ((v) << ((fidx) + 0))); } while(0)
  #define BLELL_WL_ENABLE_WL_ENABLE_GET(fidx, x)   (((x) >> ((fidx) + 0)) & 0x1)
/** White list entry is Invalid */
  #define BLELL_WL_ENABLE_WL_ENABLE_ENTRY_INVALID  0x00000000
/** White list entry is Valid */
  #define BLELL_WL_ENABLE_WL_ENABLE_ENTRY_VALID    0x00000001

/** This is used to determine the first anchor point for the master transmission,
   from the time of connection creation. Range: This shall be a multiple of 1.25
   ms in the range of 0 ms to connInterval value. @multiple */
#define BLELL_TRANSMIT_WINDOW_OFFSET_ADDR            0x00000080
#define BLELL_TRANSMIT_WINDOW_OFFSET_MASK            0x00000000

#define BLELL_TRANSMIT_WINDOW_SIZE_ADDR              0x00000084
#define BLELL_TRANSMIT_WINDOW_SIZE_MASK              0x000000ff
/** window_size along with the window_offset is used to calculate the first
   connection point anchor point for the master. This shall be a multiple of 1.25
   ms in the range of 1.25 ms to the lesser of 10 ms and (connInter- val 1.25
   ms). Values range from 0 to 10 ms. @multiple */
  #define BLELL_TRANSMIT_WINDOW_SIZE_TX_WINDOW_SIZE(v) ((v) << 0)
  #define BLELL_TRANSMIT_WINDOW_SIZE_TX_WINDOW_SIZE_SET(x, v) do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define BLELL_TRANSMIT_WINDOW_SIZE_TX_WINDOW_SIZE_GET(x) (((x) >> 0) & 0xff)

/** This register field indicates which of the data channels are in use. This
   stores the information for the lower 16 (15:0) data channel indices. 1
   indicates the corresponding data channel is used and 0 indicates the channel
   is unused. Note: The Data channel map 0 and data channel map 1 are two sets of
   channel maps stored, common for all the connections. At any given time, only
   two maps can be maintained and the connections will use one of the two sets as
   indicated by the channel map index field in the CE_CNFG_STS registers specific
   to the link. Firmware must also manage to update this field along with the
   map. @multiple */
#define BLELL_DATA_CHANNELS_L0_ADDR                  0x00000088
#define BLELL_DATA_CHANNELS_L0_MASK                  0x00000000

/** This register field indicates which of the data channels are in use. This
   stores the information for the middle 16 (32:16) data channel indices. 1
   indicates the corresponding data channel is used and 0 indicates the channel
   is unused. @multiple */
#define BLELL_DATA_CHANNELS_M0_ADDR                  0x0000008c
#define BLELL_DATA_CHANNELS_M0_MASK                  0x00000000

#define BLELL_DATA_CHANNELS_H0_ADDR                  0x00000090
#define BLELL_DATA_CHANNELS_H0_MASK                  0x0000001f
/** This register field indicates which of the data channels are in use. This
   stores the information for the upper 5 (36:32) data channel indices. 1
   indicates the corresponding data channel is used and 0 indicates the channel
   is unused. @multiple */
  #define BLELL_DATA_CHANNELS_H0_DATA_CHANNELS_H0(v) ((v) << 0)
  #define BLELL_DATA_CHANNELS_H0_DATA_CHANNELS_H0_SET(x, v) do { (x) = (((x) & ~0x1f) | ((v) << 0)); } while(0)
  #define BLELL_DATA_CHANNELS_H0_DATA_CHANNELS_H0_GET(x) (((x) >> 0) & 0x1f)

/** This register field indicates which of the data channels are in use. This
   stores the information for the lower 16 (15:0) data channel indices. 1
   indicates the corresponding data channel is used and 0 indicates the channel
   is unused. Note: The Data channel map 0 and data channel map 1 are two sets of
   channel maps stored, common for all the connections. At any given time, only
   two maps can be maintained and the connections will use one of the two sets as
   indicated by the channel map index field in the CE_CNFG_STS registers specific
   to the link. Firmware must also manage to update this field along with the
   map. @multiple */
#define BLELL_DATA_CHANNELS_L1_ADDR                  0x00000098
#define BLELL_DATA_CHANNELS_L1_MASK                  0x00000000

/** This register field indicates which of the data channels are in use. This
   stores the information for the middle 16 (32:16) data channel indices. 1
   indicates the corresponding data channel is used and 0 indicates the channel
   is unused. @multiple */
#define BLELL_DATA_CHANNELS_M1_ADDR                  0x0000009c
#define BLELL_DATA_CHANNELS_M1_MASK                  0x00000000

/** This register field indicates which of the data channels are in use. This
   stores the information for the upper 5 data channel indices. 1 indicates the
   corresponding data channel is used and 0 indicates the channel is unused.
   @multiple */
#define BLELL_DATA_CHANNELS_H1_ADDR                  0x000000a0
#define BLELL_DATA_CHANNELS_H1_MASK                  0x00000000

#define BLELL_CONN_INTR_ADDR                         0x000000a8
#define BLELL_CONN_INTR_MASK                         0x0000ffff
/** the link is disconnected. Write 1 to clear @multiple */
  #define BLELL_CONN_INTR_CONN_CLOSED              0x0001
/** the connection has been established. The bit is also set when a connection
   update procedure is completed, at the start of the first anchor point with the
   updated parameters. Write 1 to clear @multiple */
  #define BLELL_CONN_INTR_CONN_ESTB                0x0002
/** Channel map update completed. Write 1 to clear @multiple */
  #define BLELL_CONN_INTR_MAP_UPDT_DONE            0x0004
/** Connection event started. Write 1 to clear @multiple */
  #define BLELL_CONN_INTR_CE_STARTED               0x0008
/** Connection event was closed. Write 1 to clear @multiple */
  #define BLELL_CONN_INTR_CE_CLOSED                0x0010
/** The connection event transmission acknowledgement is received for the
   previous non-empty packet transmitted. Write 1 to clear @multiple */
  #define BLELL_CONN_INTR_CE_TX_ACK                0x0020
/** A packet is received in the connection event. Write 1 to clear @multiple */
  #define BLELL_CONN_INTR_CE_RX                    0x0040
/** Last connection event with previous connection parameters is reached. The bit
   is set immediately after the receive operation at the anchor point of the last
   connection event. Write 1 to clear @multiple */
  #define BLELL_CONN_INTR_CON_UPDT_DONE            0x0080
/** Reason for disconnect indicates the reason the link is disconnected by
   hardware. @multiple */
  #define BLELL_CONN_INTR_DISCON_STATUS(v)         ((BLELL_CONN_INTR_DISCON_STATUS_##v) << 8)
  #define BLELL_CONN_INTR_DISCON_STATUS_SET(x, v)  do { (x) = (((x) & ~0x700) | ((BLELL_CONN_INTR_DISCON_STATUS_##v) << 8)); } while(0)
  #define BLELL_CONN_INTR_DISCON_STATUS_SETVAL(x, v) do { (x) = (((x) & ~0x700) | ((v) << 8)); } while(0)
  #define BLELL_CONN_INTR_DISCON_STATUS_GET(x)     (((x) >> 8) & 0x7)
/** connection failed to be established */
    #define BLELL_CONN_INTR_DISCON_STATUS_NOT_ESTABLISHED 0x00000001
/** supervision timeout */
    #define BLELL_CONN_INTR_DISCON_STATUS_SUPERVISION_TIMEOUT 0x00000002
/** kill connection by host */
    #define BLELL_CONN_INTR_DISCON_STATUS_KILLED_BY_HOST 0x00000003
/** kill connection after ACK transmitted */
    #define BLELL_CONN_INTR_DISCON_STATUS_KILLED_AFTER_ACK 0x00000004
/** PDU response timer expired */
    #define BLELL_CONN_INTR_DISCON_STATUS_RESPONSE_TIMEOUT 0x00000005
/** Status of PDU received. This information is valid along with receive
   interrupt. 0bxx1: Bad Packet (packet with CRC error) @multiple */
  #define BLELL_CONN_INTR_RX_PDU_STATUS(v)         ((BLELL_CONN_INTR_RX_PDU_STATUS_##v) << 11)
  #define BLELL_CONN_INTR_RX_PDU_STATUS_SET(x, v)  do { (x) = (((x) & ~0x3800) | ((BLELL_CONN_INTR_RX_PDU_STATUS_##v) << 11)); } while(0)
  #define BLELL_CONN_INTR_RX_PDU_STATUS_SETVAL(x, v) do { (x) = (((x) & ~0x3800) | ((v) << 11)); } while(0)
  #define BLELL_CONN_INTR_RX_PDU_STATUS_GET(x)     (((x) >> 11) & 0x7)
/** empty PDU */
    #define BLELL_CONN_INTR_RX_PDU_STATUS_EMPTY_PDU  0x00000000
/** new data (non-empty) PDU */
    #define BLELL_CONN_INTR_RX_PDU_STATUS_NEW_DATA   0x00000002
/** Duplicate Packet */
    #define BLELL_CONN_INTR_RX_PDU_STATUS_DUPLICATE_PACKET 0x00000006
/** If this is set, it indicates that ping timer has expired. @multiple */
  #define BLELL_CONN_INTR_PING_TIMER_EXPIRD_INTR   0x4000
/** If this is set, it indicates that ping timer has nearly expired. @multiple */
  #define BLELL_CONN_INTR_PING_NEARLY_EXPIRD_INTR  0x8000

#define BLELL_CONN_STATUS_ADDR                       0x000000ac
#define BLELL_CONN_STATUS_MASK                       0x0000f000
/** This field stores the count for the number of received packets in the receive
   FIFO that are still not read by firmware. The counter value is incremented by
   hardware for every good packet it stores in the FIFO. After firmware reads a
   packet, it decrements the counter by issuing the PACKET_RECEIVED command from
   the commander. @multiple */
  #define BLELL_CONN_STATUS_RECEIVE_PACKET_COUNT(v) ((v) << 12)
  #define BLELL_CONN_STATUS_RECEIVE_PACKET_COUNT_SET(x, v) do { (x) = (((x) & ~0xf000) | ((v) << 12)); } while(0)
  #define BLELL_CONN_STATUS_RECEIVE_PACKET_COUNT_GET(x) (((x) >> 12) & 0xf)

/** This field is used to index the multiple connections existing. Range is 0 to
   maximum number of connections supported. For a single connection device,
   conn_index is 0. @multiple */
#define BLELL_CONN_INDEX_ADDR                        0x000000b0
#define BLELL_CONN_INDEX_MASK                        0x00000000

#define BLELL_WAKEUP_CONFIG_ADDR                     0x000000b8
#define BLELL_WAKEUP_CONFIG_MASK                     0x0000fcff
/** Oscillator stabilization/startup delay. This is in X.Y format where X is in
   terms of number of BT slots (625 us) and Y is in terms of number of clock
   periods of 16KHz clock input, required for RF oscillator to stabilize the
   clock output to the controller on its output pin, after oscillator is turned
   ON. In this period the clock is assumed to be unstable, and so the controller
   does not turn on the clock to internal logic till this period is over. This
   means, the wake up from deep sleep mode must account for this delay before the
   wakeup instant. Osc_startup_delay[7:5] is number of slots (625us)
   Osc_startup_delay[4:0] is number of clock periods of 16KHz clock (Warning:
   Min. value of Osc_startup_delay [4:0] supported is 1 and Max. value is 9.
   Therefore programmable range is 1 to 9) @multiple */
  #define BLELL_WAKEUP_CONFIG_OSC_STARTUP_DELAY(v) ((v) << 0)
  #define BLELL_WAKEUP_CONFIG_OSC_STARTUP_DELAY_SET(x, v) do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define BLELL_WAKEUP_CONFIG_OSC_STARTUP_DELAY_GET(x) (((x) >> 0) & 0xff)
/** Number of slots before the wake up instant before which the hardware needs to
   exit from deep sleep mode. The slot is of 0.625ms period. This is a onetime
   configuration field, which is used every time hardware does an auto-wakeup
   before the next wakeup instant. @multiple */
  #define BLELL_WAKEUP_CONFIG_DSM_OFFSET_TO_WAKEUP_INSTANT(v) ((v) << 10)
  #define BLELL_WAKEUP_CONFIG_DSM_OFFSET_TO_WAKEUP_INSTANT_SET(x, v) do { (x) = (((x) & ~0xfc00) | ((v) << 10)); } while(0)
  #define BLELL_WAKEUP_CONFIG_DSM_OFFSET_TO_WAKEUP_INSTANT_GET(x) (((x) >> 10) & 0x3f)

/** Instant, with reference to the internal 16-bit clock reference, at which the
   hardware must wakeup from deep sleep mode. This is calculated by firmware
   based on the next closest instant where a controller operation is required
   (like advertiser/scanner). Firmware reads the next instant of the procedures
   in the corresponding *_NEXT_INSTANT registers. This value is used only when
   hardware auto wakeup from deep sleep mode is enabled in the clock control
   register. Note: it is recommended to program wakeup_instant such a way that
   the actual instant to wake- up shall be at least two counts (two slots of 625
   us) ahead of reference clock when entering DSM. The actual instant to wakeup
   is wakeup_instant dsm_offset_to_wakeup_instant osc_startup_delay, and it shall
   be greater than reference clock + 2 @multiple */
#define BLELL_WAKEUP_CONTROL_ADDR                    0x000000c0
#define BLELL_WAKEUP_CONTROL_MASK                    0x00000000

#define BLELL_CLOCK_CONFIG_ADDR                      0x000000c4
#define BLELL_CLOCK_CONFIG_MASK                      0x0000d7ff
/** Advertiser block clock gate enable. Enables gating of clock to the advertiser
   module (llh_adv) in hardware. If 1, the sleep mode logic can control the clock
   gate to shutdown/wakeup the clock to the module. If 0, the logic has no con-
   trol and clock to the module is always turned ON. @multiple */
  #define BLELL_CLOCK_CONFIG_ADV_CLK_GATE_EN       0x0001
/** Scan block clock gate enable. Enables gating of clock to the scanner module
   (llh_scan) in hardware. If 1, the sleep mode logic can control the clock gate
   to shutdown/wakeup the clock to the module. If 0, the logic has no con- trol
   and clock to the module is always turned ON. @multiple */
  #define BLELL_CLOCK_CONFIG_SCAN_CLK_GATE_EN      0x0002
/** Initiator block clock gate enable. Enables gating of clock to the initiator
   module (llh_init). If 1, the sleep mode logic can control the clock gate to
   shutdown/wakeup the clock to the module. If 0, the logic has no control and
   clock to the module is always turned ON. @multiple */
  #define BLELL_CLOCK_CONFIG_INIT_CLK_GATE_EN      0x0004
/** Connection block clock gate enable. Enables gating of clock to the connection
   module (llh_connch_top) in hardware. If 1, the sleep mode logic can control
   the clock gate to shutdown/wakeup the clock to the engine. If 0, the logic has
   no control and clock to the module is always turned ON. @multiple */
  #define BLELL_CLOCK_CONFIG_CONN_CLK_GATE_EN      0x0008
/** Core clock gate enable. Enables gating of clock to the llh_core module in
   hard-ware. If 1, the sleep mode/deep sleep mode logic can control the clock
   gate to shutdown/wakeup the clock to the module. If 0, the logic has no
   control and clock is always turned ON. @multiple */
  #define BLELL_CLOCK_CONFIG_CORECLK_GATE_EN       0x0010
/** Sysclk gate enable. Enables clock gating of system clock input to the link
   layer. If 1, it enables the DSM logic to con- trol the clock gate for system
   clock input from pin. If 0, the DSM logic has no control and the system clock
   is always ON. @multiple */
  #define BLELL_CLOCK_CONFIG_SYSCLK_GATE_EN        0x0020
/** Digital PHY clock enable. Enable the Digital PHY to shutdown the clock. When
   1, it indicates that controller has an upcom- ing activity so PHY clock must
   be turned ON. When 0, it indicates inactivity in the controller. @multiple */
  #define BLELL_CLOCK_CONFIG_PHY_CLK_GATE_EN       0x0040
/** Indicates if hardware is doing any transmit/receive operation. This
   information is used by firm- ware to decide to program the hardware into deep
   sleep mode. When busy, LL hardware will not enter deep sleep mode, even if
   firmware gives an enter DSM command. (In this situation hardware generates dsm
   exit interrupt to inform firmware that DSM entry was not successful).
   @multiple */
  #define BLELL_CLOCK_CONFIG_LLH_IDLE              0x0080
/** Clock frequency select. Base frequency of the sleep_clk input used for
   generat-ing the internal reference clock of approx- imate 16Khz frequency.
   @multiple */
  #define BLELL_CLOCK_CONFIG_LPO_CLK_FREQ_SEL(v)   ((BLELL_CLOCK_CONFIG_LPO_CLK_FREQ_SEL_##v) << 8)
  #define BLELL_CLOCK_CONFIG_LPO_CLK_FREQ_SEL_SET(x, v) do { (x) = (((x) & ~0x100) | ((BLELL_CLOCK_CONFIG_LPO_CLK_FREQ_SEL_##v) << 8)); } while(0)
  #define BLELL_CLOCK_CONFIG_LPO_CLK_FREQ_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define BLELL_CLOCK_CONFIG_LPO_CLK_FREQ_SEL_GET(x) (((x) >> 8) & 0x1)
    #define BLELL_CLOCK_CONFIG_LPO_CLK_FREQ_SEL_32KHZ 0x00000000
    #define BLELL_CLOCK_CONFIG_LPO_CLK_FREQ_SEL_32_768KHZ 0x00000001
/** Select external sleep clock. The field is used to select either the low power
   clock in-put on sleep_clk input pin(of frequency 16.384KHz) di-rectly to run
   the DSM logic or to use the internal gener-ated reference clock(of 16KHz) for
   the same. @multiple */
  #define BLELL_CLOCK_CONFIG_LPO_SEL_EXTERNAL      0x0200
/** Enable sleep mode auto wakeup enable. Enables hardware to automatically
   wakeup from sleep mode at the instant = wakeup_instant
   sm_offset_to_wakeup_instant. The wakeup_insant is the field in the wakeup
   control register de- scribed earlier. The sm_offset_to_wakeup_instant value is
   the field described in the wakeup con- figuration register. @multiple */
  #define BLELL_CLOCK_CONFIG_SM_AUTO_WKUP_EN       0x0400
/** Enable SM exit interrupt. Enables hardware to generate an interrupt while
   exiting sleep mode irrespective of whether it is initiated by hardware or
   firmware. The interrupt is captured and stored till it gets cleared. Dis-
   abling this bit mask the sleep mode exit event from hardware & firmware.
   @multiple */
  #define BLELL_CLOCK_CONFIG_SM_INTR_EN            0x1000
/** Enable sleep mode. Enables hardware to control sleep mode operation.
   @multiple */
  #define BLELL_CLOCK_CONFIG_SLEEP_MODE_EN         0x4000
/** Enable deep sleep mode. Enables hardware logic related to deep sleep mode to
   control the deep sleep mode operation. If disabled, the related logic is not
   executed and hardware cannot enter deep sleep mode. @multiple */
  #define BLELL_CLOCK_CONFIG_DEEP_SLEEP_MODE_EN    0x8000

/** 16-bit internal reference clock. The clock is a free run-ning clock,
   incremented by a 0.625ms pe- riodic pulse. It is used as a reference clock to
   derive all the timing required as per protocol. @multiple */
#define BLELL_TIM_COUNTER_L_ADDR                     0x000000c8
#define BLELL_TIM_COUNTER_L_MASK                     0x00000000

#define BLELL_TIM_CONTROL_ADDR                       0x000000d8
#define BLELL_TIM_CONTROL_MASK                       0x000000f8
/** LLH clock configuration. The clock frequency of the clock input to this
   design is configured in this register. This is used to derive a 1MHz clock.
   @multiple */
  #define BLELL_TIM_CONTROL_BB_CLK_FREQ_MINUS_1(v) ((v) << 3)
  #define BLELL_TIM_CONTROL_BB_CLK_FREQ_MINUS_1_SET(x, v) do { (x) = (((x) & ~0xf8) | ((v) << 3)); } while(0)
  #define BLELL_TIM_CONTROL_BB_CLK_FREQ_MINUS_1_GET(x) (((x) >> 3) & 0x1f)

/** IO mapped FIFO of depth 16 (2 byte wide), to store ADV data of maximum length
   31 bytes for transmitting. Firmware writes consecutive words by writing to the
   same address location. Note: ADV_TX_DATA_FIFO and ADV_SCN_RSP_TX_FIFO shares
   same physical FIFO of depth 32. 16 locations for each FIFO are allocated.
   @multiple */
#define BLELL_ADV_TX_DATA_FIFO_ADDR                  0x000000e0
#define BLELL_ADV_TX_DATA_FIFO_MASK                  0x00000000

/** IO mapped FIFO of depth 16 (2 byte wide), to store scan response data of
   maximum length 31 bytes for transmitting. Firmware writes consecutive words by
   writing to the same location. Note: ADV_TX_DATA_FIFO and ADV_SCN_RSP_TX_FIFO
   shares same physical FIFO of depth 32. 16 locations for each FIFO are
   allocated. @multiple */
#define BLELL_ADV_SCN_RSP_TX_FIFO_ADDR               0x000000e8
#define BLELL_ADV_SCN_RSP_TX_FIFO_MASK               0x00000000

/** IO mapped FIFO of depth 64, to store ADV and SCAN_RSP header and payload
   received by the scanner. The RSSI value at the time of reception of this
   packet is also stored. Firmware reads from the same address to read out
   consecutive words of data. Note: The 16 bit header is first loaded to the
   advertise channel data receive FIFO followed by the payload data and then 16
   bit RSSI. @multiple */
#define BLELL_INIT_SCN_ADV_RX_FIFO_ADDR              0x000000f8
#define BLELL_INIT_SCN_ADV_RX_FIFO_MASK              0x00000000

/** The value configured in this register determines the spacing between the
   connection events. This shall be a multiple of 1.25 ms in the range of 7.5 ms
   to 4.0 s. @multiple */
#define BLELL_CONN_INTERVAL_ADDR                     0x00000100
#define BLELL_CONN_INTERVAL_MASK                     0x00000000

/** This field defines the maximum time between two received Data packet PDUs
   before the connection is considered lost. This shall be a multiple of 10 ms in
   the range of 100 ms to 32.0 s and it shall be larger than
   (1+connSlaveLatency)*connInterval. @multiple */
#define BLELL_SUP_TIMEOUT_ADDR                       0x00000104
#define BLELL_SUP_TIMEOUT_MASK                       0x00000000

/** The value configured in this field defines the number of consecutive
   connection events that the slave device is not required to listen for master.
   The value of connSlaveLatency should not cause a Supervision Timeout. This
   shall be an integer in the range of 0 to ((connSupervision
   Timeout/connInterval)-1). @multiple */
#define BLELL_SLAVE_LATENCY_ADDR                     0x00000108
#define BLELL_SLAVE_LATENCY_MASK                     0x00000000

/** This field defines the max length of Connection event where MD is set by any
   peer. @multiple */
#define BLELL_CE_LENGTH_ADDR                         0x0000010c
#define BLELL_CE_LENGTH_MASK                         0x00000000

/** This field defines the lower 16 bits of the access address for each Link
   layer connection between any two devices. @multiple */
#define BLELL_PDU_ACCESS_ADDR_L_ADDR                 0x00000110
#define BLELL_PDU_ACCESS_ADDR_L_MASK                 0x00000000

/** This field defines the higher 16 bits of the access address for each Link
   layer connection between any two devices. @multiple */
#define BLELL_PDU_ACCESS_ADDR_H_ADDR                 0x00000114
#define BLELL_PDU_ACCESS_ADDR_H_MASK                 0x00000000

/** This is the value of the free running Connection Event counter when the new
   parameters of con- nection update and/or Channel map update will be effective.
   @multiple */
#define BLELL_CONN_CE_INSTANT_ADDR                   0x00000118
#define BLELL_CONN_CE_INSTANT_MASK                   0x00000000

#define BLELL_CE_CNFG_STS_ADDR                       0x0000011c
#define BLELL_CE_CNFG_STS_MASK                       0x0000f5ff
/** Data list index for start/resume. This field must be valid along with
   data_list_head_up and indi- cate the transmit packet buffer index at which the
   data is loaded. The default number of buffers in the IP is 5,but may be
   customized for a customer. The buffers are indexed 0 to 4. Hardware will start
   the next data transmission from the index indicated by this field. @multiple
   */
  #define BLELL_CE_CNFG_STS_DATA_LIST_INDEX_LAST_ACK_INDEX(v) ((v) << 0)
  #define BLELL_CE_CNFG_STS_DATA_LIST_INDEX_LAST_ACK_INDEX_SET(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define BLELL_CE_CNFG_STS_DATA_LIST_INDEX_LAST_ACK_INDEX_GET(x) (((x) >> 0) & 0xf)
/** Update the first packet buffer index ready for transmission to start/resume
   data transfer after a pause. The bit must be toggled every time the firmware
   needs to indicate the start/resume. This requires a read modify write
   operation. @multiple */
  #define BLELL_CE_CNFG_STS_DATA_LIST_HEAD_UP      0x0010
/** This field indicates that device is configured as a master or a slave.
   @multiple */
  #define BLELL_CE_CNFG_STS_MASTER                 0x0020
/** MD bit set to 1 indicates device has more data to be sent. @multiple */
  #define BLELL_CE_CNFG_STS_MD                     0x0040
/** Written by firmware to select the map index to be used by hardware for this
   connection. When firmware reads this field, it returns the current map index
   being used in hardware. @multiple */
  #define BLELL_CE_CNFG_STS_MAP_CURR_INDEX         0x0080
/** Pause the data transfer on the connection. The current_pdu_index in hardware
   does not move to next index until pause_data is cleared. @multiple */
  #define BLELL_CE_CNFG_STS_PAUSE_DATA             0x0100
/** This bit is 1 whenever the connection is active. @multiple */
  #define BLELL_CE_CNFG_STS_CONN_ACTIVE            0x0400
/** The index of the transmit packet buffer that is currently in
   transmission/waiting for transmission. @multiple */
  #define BLELL_CE_CNFG_STS_CURRENT_PDU_INDEX(v)   ((v) << 12)
  #define BLELL_CE_CNFG_STS_CURRENT_PDU_INDEX_SET(x, v) do { (x) = (((x) & ~0xf000) | ((v) << 12)); } while(0)
  #define BLELL_CE_CNFG_STS_CURRENT_PDU_INDEX_GET(x) (((x) >> 12) & 0xf)

/** Internal reference clock value at which the next connection event will occur
   on a connection. The connection index register must be programmed with index
   of the connection, before reading the register. @multiple */
#define BLELL_NEXT_CE_INSTANT_ADDR                   0x00000120
#define BLELL_NEXT_CE_INSTANT_MASK                   0x00000000

/** This is the free running counter, connEventCounter as defined by Bluetooth
   spec. Firmware will read the instantaneous Event counter from this register,
   during connection update and channel map update procedure. Firmware will use
   this value to calculate the instant from which the new parameters (for
   connection update and channel map update) will be effective. @multiple */
#define BLELL_CONN_CE_COUNTER_ADDR                   0x00000124
#define BLELL_CONN_CE_COUNTER_MASK                   0x00000000

#define BLELL_DATA_LIST_SENT_ADDR                    0x00000128
#define BLELL_DATA_LIST_SENT_MASK                    0x0000009f
/** Write:Indicates the buffer index for which the SENT bit is being updated by
   firmware. The default number of buffers in the IP is 5. The index range is
   0-4. Read: Reads TX_SENT[3:0]. The bits in this field indicate the status of
   the SENT bit in the hard-ware for each packet buffer. The bit values are 1:
   QUEUED 0: no packet / packet ack received by hardware Example1: If the read
   value is : 0x03, then packets in buffer 0 and buffer 1 are in the queue to be
   transmitted. All the other FIFOs are empty or hardware has cleared them after
   receiving acknowledgement. @multiple */
  #define BLELL_DATA_LIST_SENT_LIST_INDEX__TX_SENT_3_0(v) ((v) << 0)
  #define BLELL_DATA_LIST_SENT_LIST_INDEX__TX_SENT_3_0_SET(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define BLELL_DATA_LIST_SENT_LIST_INDEX__TX_SENT_3_0_GET(x) (((x) >> 0) & 0xf)
/** Read: Reads TX_SENT[4]. The bits in this field indicate the status of the
   SENT bit in the hard-ware for each packet buffer. The bit values are 1 queued
   0 no packet / packet ack received by hardware Example1: If the read value is :
   0x03, then packets in buffer 0 and buffer 1 are in the queue to be
   transmitted. All the other FIFOs are empty or hardware has cleared them after
   receiving ac- knowledgement. NOTE: The SENT status bit and ACK status bit have
   to be taken together to understand the meaning of packet status. The table
   below describes how the two bits are sequentially updated by either
   hardware/firmware to complete one data transmission. SENT ACK Description 0 0
   Buffer is empty. No packet is queued in the buffer 1 0 Packet is queued by
   firmware. 1 1 Packet is transmitted by hardware. Hardware is waiting for
   acknowledgement. 0 1 Hardware has received ACK. Firmware has not yet processed
   the ACK. 0 0 Firmware has processed the ack. The buffer is again empty.
   @multiple */
  #define BLELL_DATA_LIST_SENT_TX_SENT_4           0x0010
/** Write: Used to set the SENT bit in hardware for the selected packet buffer. 1
   packet queued When firmware has a packet to send, firmware first loads the
   next available packet buffer. Then the hardware SENT bit is set by writing 1
   to this bit field along with the list_index field that iden- tified the buffer
   index. This indicates that a packet has been queued in the data buffer for
   send- ing. This packet is now ready to be transmitted. The SENT bit in
   hardware is cleared by hardware only when it has received an acknowledge- ment
   from the remote device. Firmware typically does not clear the bit. However, It
   only clears the bit on its own if it needs to flush a packet from the buffer,
   without waiting to receive acknowledgement from the remote de- vice, firmware
   clears BIT7 along with the list_index specified. @multiple */
  #define BLELL_DATA_LIST_SENT_SET_CLEAR           0x0080

#define BLELL_DATA_LIST_ACK_ADDR                     0x0000012c
#define BLELL_DATA_LIST_ACK_MASK                     0x0000009f
/** Write: Indicates the buffer index for which the ACK bit is being updated by
   firmware. The default number of buffers in the IP is 5. The index range is
   0-4. Read: Reads TX_ACK[3:0] If a particular bit is set, then the packet in
   the selected buffer has been transmitted (at least once) by the hardware and
   hardware is waiting for acknowledgement. Example1 : If the read value is :
   0x03, then packets in FIFO-0 and FIFO-1 are acknowledged by the remote device.
   These acknowledgements are pending to be processed by firmware. Example2 : If
   the read value is : 0x02, then packet FIFO-1 is acknowledged by the remote
   device. This acknowledgement is pending to be processed by firmware. @multiple
   */
  #define BLELL_DATA_LIST_ACK_LIST_INDEX__TX_ACK_3_0(v) ((v) << 0)
  #define BLELL_DATA_LIST_ACK_LIST_INDEX__TX_ACK_3_0_SET(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define BLELL_DATA_LIST_ACK_LIST_INDEX__TX_ACK_3_0_GET(x) (((x) >> 0) & 0xf)
/** Reads TX_ACK[4] If a particular bit is set, then the packet in the selected
   buffer has been transmitted (at least once) by the hardware and hardware is
   waiting for acknowledgement. Example1 : If the read value is : 0x03, then
   packets in FIFO-0 and FIFO-1 are acknowledged by the remote device. These
   acknowledgements are pending to be processed by firmware. Example2 : If the
   read value is : 0x02, then packet FIFO-1 is acknowledged by the remote device.
   This acknowledgement is pending to be processed by firmware. NOTE: The SENT
   status bit and ACK status bit have to be taken together to understand the
   meaning of packet status. The table below describes how the two bits are
   sequentially updated by either hardware/firmware to complete one data
   transmission. SENT ACK Description 0 0 Buffer is empty. No packet is queued in
   the buffer 1 0 Packet is queued by firmware. 1 1 Packet is transmitted by
   hardware. Hardware is waiting for acknowledgement. 0 1 Hardware has received
   ACK. Firmware has not yet processed the ACK. 0 0 Firmware has processed the
   ack. The buffer is again empty. @multiple */
  #define BLELL_DATA_LIST_ACK_TX_ACK_4             0x0010
/** Write: Firmware uses the field to clear and ACK bit in the hardware to
   indicate that the acknowl- edgement for the transmit packet has been received
   and processed by firmware. Firmware clears the ACK bit in the hardware by
   writing in this register only after the acknowl- edgement is processed
   successfully by firmware. For clearing ack for a packet transmitted in
   fifo-index : 3, firm-ware will write 3 in the list-index field and set this
   bit (BIT7) to 0. This is the indication that the corresponding packet buffer
   identi-fied by List-Index is cleared of previous transmission and can be
   re-used for another packet from now on. The ACK bit in hardware is set by
   hardware when it has success-fully transmitted a packet. @multiple */
  #define BLELL_DATA_LIST_ACK_SET_CLEAR            0x0080

#define BLELL_DATA_MEM_DESCRIPTOR_ADDR(ridx)         (0x00000140 + (ridx) * 4)
#define BLELL_DATA_MEM_DESCRIPTOR_COUNT              5
#define BLELL_DATA_MEM_DESCRIPTOR_MASK               0x0000007f
/** The LLID indicates whether the packet is an LL Data PDU or an LL Control PDU.
   @multiple */
  #define BLELL_DATA_MEM_DESCRIPTOR_LLID(v)        ((BLELL_DATA_MEM_DESCRIPTOR_LLID_##v) << 0)
  #define BLELL_DATA_MEM_DESCRIPTOR_LLID_SET(x, v) do { (x) = (((x) & ~0x3) | ((BLELL_DATA_MEM_DESCRIPTOR_LLID_##v) << 0)); } while(0)
  #define BLELL_DATA_MEM_DESCRIPTOR_LLID_SETVAL(x, v) do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define BLELL_DATA_MEM_DESCRIPTOR_LLID_GET(x)    (((x) >> 0) & 0x3)
/** Reserved. */
    #define BLELL_DATA_MEM_DESCRIPTOR_LLID_RESERVED  0x00000000
/** Continuation fragment of an L2CAP message or an Empty PDU. */
    #define BLELL_DATA_MEM_DESCRIPTOR_LLID_LL_DATA_PDU 0x00000001
/** Start of an L@CAP message or a complete L2CAP message with no fragmentation. */
    #define BLELL_DATA_MEM_DESCRIPTOR_LLID_LL_DATA_PDU 0x00000002
/** LL Control PDU. */
    #define BLELL_DATA_MEM_DESCRIPTOR_LLID_LL_CONTROL_PDU 0x00000003
/** This field indicates the length of the data packet. Range 0x0 to 0xF.
   @multiple */
  #define BLELL_DATA_MEM_DESCRIPTOR_DATA_LENGTH(v) ((v) << 2)
  #define BLELL_DATA_MEM_DESCRIPTOR_DATA_LENGTH_SET(x, v) do { (x) = (((x) & ~0x7c) | ((v) << 2)); } while(0)
  #define BLELL_DATA_MEM_DESCRIPTOR_DATA_LENGTH_GET(x) (((x) >> 2) & 0x1f)

#define BLELL_WINDOW_WIDEN_INTVL_ADDR                0x00000160
#define BLELL_WINDOW_WIDEN_INTVL_MASK                0x00000fff
/** This value defines the increased listening time for the slave. The window
   widening shall be smaller than ((connInterval/2)-T_IFS us) This value is
   calculated by firmware based on the drift, the connec-tion interval value. The
   value is the unit widening value for one con-nection interval duration. In
   case of slave latency, this val- ue is accu-mulated till the next anchor point
   at which the slave will listen. @multiple */
  #define BLELL_WINDOW_WIDEN_INTVL_WINDOW_WIDEN_INTVL(v) ((v) << 0)
  #define BLELL_WINDOW_WIDEN_INTVL_WINDOW_WIDEN_INTVL_SET(x, v) do { (x) = (((x) & ~0xfff) | ((v) << 0)); } while(0)
  #define BLELL_WINDOW_WIDEN_INTVL_WINDOW_WIDEN_INTVL_GET(x) (((x) >> 0) & 0xfff)

#define BLELL_WINDOW_WIDEN_WINOFF_ADDR               0x00000164
#define BLELL_WINDOW_WIDEN_WINOFF_MASK               0x00000fff
/** This field stores the additional number of microseconds the slave must extend
   its listening win- dow to listen for a master packet. This value is calculated
   based on the window offset value. This is used at connection setup directly.
   During connection setup, this value is added with window_widen_intvl register
   value to calculate the window widening size. @multiple */
  #define BLELL_WINDOW_WIDEN_WINOFF_WINDOW_WIDEN_WINOFF(v) ((v) << 0)
  #define BLELL_WINDOW_WIDEN_WINOFF_WINDOW_WIDEN_WINOFF_SET(x, v) do { (x) = (((x) & ~0xfff) | ((v) << 0)); } while(0)
  #define BLELL_WINDOW_WIDEN_WINOFF_WINDOW_WIDEN_WINOFF_GET(x) (((x) >> 0) & 0xfff)

#define BLELL_LE_RF_TEST_MODE_ADDR                   0x00000170
#define BLELL_LE_RF_TEST_MODE_MASK                   0x0000ffff
/** radio channel number. Value = (f - 2402) / 2 @multiple */
  #define BLELL_LE_RF_TEST_MODE_TEST_FREQUENCY(v)  ((v) << 0)
  #define BLELL_LE_RF_TEST_MODE_TEST_FREQUENCY_SET(x, v) do { (x) = (((x) & ~0x3f) | ((v) << 0)); } while(0)
  #define BLELL_LE_RF_TEST_MODE_TEST_FREQUENCY_GET(x) (((x) >> 0) & 0x3f)
  #define BLELL_LE_RF_TEST_MODE_TEST_TYPE(v)       ((BLELL_LE_RF_TEST_MODE_TEST_TYPE_##v) << 6)
  #define BLELL_LE_RF_TEST_MODE_TEST_TYPE_SET(x, v) do { (x) = (((x) & ~0x40) | ((BLELL_LE_RF_TEST_MODE_TEST_TYPE_##v) << 6)); } while(0)
  #define BLELL_LE_RF_TEST_MODE_TEST_TYPE_SETVAL(x, v) do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
  #define BLELL_LE_RF_TEST_MODE_TEST_TYPE_GET(x)   (((x) >> 6) & 0x1)
/** DTM test OFF */
    #define BLELL_LE_RF_TEST_MODE_TEST_TYPE_DTM_TEST_OFF 0x00000000
/** DTM test ON */
    #define BLELL_LE_RF_TEST_MODE_TEST_TYPE_DTM_TEST_ON 0x00000001
/** Payload type as per the HCI parameter. @multiple */
  #define BLELL_LE_RF_TEST_MODE_PKT_PAYLOAD(v)     ((BLELL_LE_RF_TEST_MODE_PKT_PAYLOAD_##v) << 7)
  #define BLELL_LE_RF_TEST_MODE_PKT_PAYLOAD_SET(x, v) do { (x) = (((x) & ~0x380) | ((BLELL_LE_RF_TEST_MODE_PKT_PAYLOAD_##v) << 7)); } while(0)
  #define BLELL_LE_RF_TEST_MODE_PKT_PAYLOAD_SETVAL(x, v) do { (x) = (((x) & ~0x380) | ((v) << 7)); } while(0)
  #define BLELL_LE_RF_TEST_MODE_PKT_PAYLOAD_GET(x) (((x) >> 7) & 0x7)
/** Pseudo-Random bit sequence 9 */
    #define BLELL_LE_RF_TEST_MODE_PKT_PAYLOAD_PRBS9  0x00000000
/** Pattern of alter-nating bits 11110000 */
    #define BLELL_LE_RF_TEST_MODE_PKT_PAYLOAD_PATTERN_11110000 0x00000001
/** Pattern of alternating bits 10101010 */
    #define BLELL_LE_RF_TEST_MODE_PKT_PAYLOAD_PATTERN_1010 0x00000002
/** Pseudo-Random bit sequence 15 */
    #define BLELL_LE_RF_TEST_MODE_PKT_PAYLOAD_PRBS15 0x00000003
/** Pat-tern of All 1 bits */
    #define BLELL_LE_RF_TEST_MODE_PKT_PAYLOAD_PATTERN_ALL1 0x00000004
/** Pattern of All 0 bits */
    #define BLELL_LE_RF_TEST_MODE_PKT_PAYLOAD_PATTERN_ALL0 0x00000005
/** Pattern of alternating bits 00001111 */
    #define BLELL_LE_RF_TEST_MODE_PKT_PAYLOAD_PATTERN_00001111 0x00000006
/** Pattern of alternating bits 0101 */
    #define BLELL_LE_RF_TEST_MODE_PKT_PAYLOAD_PATTERN_0101 0x00000007
/** 0x00-0x25 Length in bytes of payload data in each packet 0x26-0xFF Reserved
   for future use @multiple */
  #define BLELL_LE_RF_TEST_MODE_TEST_LENGTH(v)     ((v) << 10)
  #define BLELL_LE_RF_TEST_MODE_TEST_LENGTH_SET(x, v) do { (x) = (((x) & ~0xfc00) | ((v) << 10)); } while(0)
  #define BLELL_LE_RF_TEST_MODE_TEST_LENGTH_GET(x) (((x) >> 10) & 0x3f)

/** Number of packets received in receive test mode. @multiple */
#define BLELL_DTM_RX_PKT_COUNT_ADDR                  0x00000174
#define BLELL_DTM_RX_PKT_COUNT_MASK                  0x00000000

#define BLELL_TXRX_HOP_ADDR                          0x00000188
#define BLELL_TXRX_HOP_MASK                          0x00007f7f
/** Transmit channel index. Channel index on which previous packet is
   transmitted. @multiple */
  #define BLELL_TXRX_HOP_HOP_CH_TX(v)              ((v) << 0)
  #define BLELL_TXRX_HOP_HOP_CH_TX_SET(x, v)       do { (x) = (((x) & ~0x7f) | ((v) << 0)); } while(0)
  #define BLELL_TXRX_HOP_HOP_CH_TX_GET(x)          (((x) >> 0) & 0x7f)
/** Receive channel index. Channel index on which previous packet is received.
   @multiple */
  #define BLELL_TXRX_HOP_HOP_CH_RX(v)              ((v) << 8)
  #define BLELL_TXRX_HOP_HOP_CH_RX_SET(x, v)       do { (x) = (((x) & ~0x7f00) | ((v) << 8)); } while(0)
  #define BLELL_TXRX_HOP_HOP_CH_RX_GET(x)          (((x) >> 8) & 0x7f)

#define BLELL_TX_RX_ON_DELAY_ADDR                    0x00000190
#define BLELL_TX_RX_ON_DELAY_MASK                    0x0000ffff
/** Receive delay Delay from start of receive to expected first bit of receive
   packet at the controller. Used to control the turn on time of radio to
   optimize on power. The delay is in resolution of 1 microsecond. @multiple */
  #define BLELL_TX_RX_ON_DELAY_RXON_DELAY(v)       ((v) << 0)
  #define BLELL_TX_RX_ON_DELAY_RXON_DELAY_SET(x, v) do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define BLELL_TX_RX_ON_DELAY_RXON_DELAY_GET(x)   (((x) >> 0) & 0xff)
/** Transmit delay Delay from start of transmit to transmission of first bit on
   air. It is used to control the T_IFS. The delay is in resolution of 1
   microsecond. @multiple */
  #define BLELL_TX_RX_ON_DELAY_TXON_DELAY(v)       ((v) << 8)
  #define BLELL_TX_RX_ON_DELAY_TXON_DELAY_SET(x, v) do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define BLELL_TX_RX_ON_DELAY_TXON_DELAY_GET(x)   (((x) >> 8) & 0xff)

/** Lower 16 bit of 48-bit public address of the device. @multiple */
#define BLELL_DEV_PUB_ADDR_L_ADDR                    0x000001c0
#define BLELL_DEV_PUB_ADDR_L_MASK                    0x00000000

/** Middle 16 bit of 48-bit public address of the device. @multiple */
#define BLELL_DEV_PUB_ADDR_M_ADDR                    0x000001c4
#define BLELL_DEV_PUB_ADDR_M_MASK                    0x00000000

/** Higher 16 bit of 48-bit public address of the device. @multiple */
#define BLELL_DEV_PUB_ADDR_H_ADDR                    0x000001c8
#define BLELL_DEV_PUB_ADDR_H_MASK                    0x00000000

/** Units: dBm, accuracy: +/- 4 dBm. @multiple */
#define BLELL_ADV_CH_TX_POWER_ADDR                   0x000001cc
#define BLELL_ADV_CH_TX_POWER_MASK                   0x00000000

/** The offset w.r.t the internal reference clock at which instant the first
   event occurs. This register will give flexibility to the firmware to position
   the con-nection at a desired point with respect to the internal free running
   clock. It is optional to be updated by firmware. This is not up- dated in the
   current firmware. @multiple */
#define BLELL_OFFSET_TO_FIRST_INSTANT_ADDR           0x000001d0
#define BLELL_OFFSET_TO_FIRST_INSTANT_MASK           0x00000000

#define BLELL_ADV_CONFIG_ADDR                        0x000001d4
#define BLELL_ADV_CONFIG_MASK                        0x0000f9ff
/** Enable advertising event start interrupt. @multiple */
  #define BLELL_ADV_CONFIG_ADV_STRT_EN             0x0001
/** Enable advertising event stop interrupt. @multiple */
  #define BLELL_ADV_CONFIG_ADV_CLS_EN              0x0002
/** Enable adv packet transmitted interrupt. @multiple */
  #define BLELL_ADV_CONFIG_ADV_TX_EN               0x0004
/** Enable scan response packet transmitted interrupt. @multiple */
  #define BLELL_ADV_CONFIG_SCN_RSP_TX_EN           0x0008
/** Enable scan request packet received interrupt. @multiple */
  #define BLELL_ADV_CONFIG_ADV_SCN_REQ_RX_EN       0x0010
/** Enable connect request packet received interrupt. @multiple */
  #define BLELL_ADV_CONFIG_ADV_CONN_REQ_RX_EN      0x0020
/** Enable slave connected interrupt. @multiple */
  #define BLELL_ADV_CONFIG_SLV_CONNECTED_EN        0x0040
/** Enable adv_timeout interrupt. Applicable in adv_direct_ind advertising.
   @multiple */
  #define BLELL_ADV_CONFIG_ADV_TIMEOUT_EN          0x0080
/** Disable randomization of adv interval. When disabled, interval is same as
   programmed in adv_interval register. @multiple */
  #define BLELL_ADV_CONFIG_ADV_RAND_DISABLE        0x0100
/** Time between the beginning of two consecutive advertising PDUs. Time = N *
   0.625 msec Time Range: <=10msec. @multiple */
  #define BLELL_ADV_CONFIG_ADV_PKT_INTERVAL(v)     ((v) << 11)
  #define BLELL_ADV_CONFIG_ADV_PKT_INTERVAL_SET(x, v) do { (x) = (((x) & ~0xf800) | ((v) << 11)); } while(0)
  #define BLELL_ADV_CONFIG_ADV_PKT_INTERVAL_GET(x) (((x) >> 11) & 0x1f)

#define BLELL_SCAN_CONFIG_ADDR                       0x000001d8
#define BLELL_SCAN_CONFIG_MASK                       0x0000e81f
/** Enable scan event start interrupt. @multiple */
  #define BLELL_SCAN_CONFIG_SCN_STRT_EN            0x0001
/** Enable scan event close interrupt. @multiple */
  #define BLELL_SCAN_CONFIG_SCN_CLOSE_EN           0x0002
/** Enable scan request packet transmitted interrupt. @multiple */
  #define BLELL_SCAN_CONFIG_SCN_TX_EN              0x0004
/** Enable adv packet received interrupt. @multiple */
  #define BLELL_SCAN_CONFIG_ADV_RX_EN              0x0008
/** Enable scan_rsp packet received interrupt. @multiple */
  #define BLELL_SCAN_CONFIG_SCN_RSP_RX_EN          0x0010
/** Enable random backoff feature in scanner. @multiple */
  #define BLELL_SCAN_CONFIG_BACKOFF_ENABLE         0x0800
/** enables channel 37 for scanning. @multiple */
  #define BLELL_SCAN_CONFIG_SCAN_CHANNEL_37        0x2000
/** enables channel 38 for scanning. @multiple */
  #define BLELL_SCAN_CONFIG_SCAN_CHANNEL_38        0x4000
/** enables channel 39 for scanning. @multiple */
  #define BLELL_SCAN_CONFIG_SCAN_CHANNEL_39        0x8000

#define BLELL_INIT_CONFIG_ADDR                       0x000001dc
#define BLELL_INIT_CONFIG_MASK                       0x0000e017
/** Enable Initiator event start interrupt. @multiple */
  #define BLELL_INIT_CONFIG_INIT_STRT_EN           0x0001
/** Enable Initiator event close interrupt. @multiple */
  #define BLELL_INIT_CONFIG_INIT_CLOSE_EN          0x0002
/** Enables connection request packet transmission start interrupt. @multiple */
  #define BLELL_INIT_CONFIG_CONN_REQ_TX_EN         0x0004
/** Enable master connection created interrupt @multiple */
  #define BLELL_INIT_CONFIG_CONN_CREATED           0x0010
/** enables channel 37 for initiator scanning. @multiple */
  #define BLELL_INIT_CONFIG_INIT_CHANNEL_37        0x2000
/** enables channel 38 for initiator scanning. @multiple */
  #define BLELL_INIT_CONFIG_INIT_CHANNEL_38        0x4000
/** enables channel 39 for initiator scanning. @multiple */
  #define BLELL_INIT_CONFIG_INIT_CHANNEL_39        0x8000

#define BLELL_CONN_CONFIG_ADDR                       0x000001e0
#define BLELL_CONN_CONFIG_MASK                       0x0000f9ff
/** Defines a limit for the number of Rx packets that can be re-ceived by the
   LLH. Default maximum value is 0xF.Minimum value shall be 1 or no packet will
   be stored in the Rx FIFO. @multiple */
  #define BLELL_CONN_CONFIG_RX_PKT_LIMIT(v)        ((v) << 0)
  #define BLELL_CONN_CONFIG_RX_PKT_LIMIT_SET(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define BLELL_CONN_CONFIG_RX_PKT_LIMIT_GET(x)    (((x) >> 0) & 0xf)
/** This register field allows setting a threshold for the packet received
   interrupt to the firmware. For example if the value programmed is 0x2 then HW
   will generate interrupt only on receiving the second packet. In any case if
   the received number of packets in a conn event is less than the threshold or
   there are still packets (less than threshold) pending in the Rx FIFO, HW will
   generate the interrupt at the ce_close. Min value possible is 1. Max value
   depends on the Rx FIFO capacity. @multiple */
  #define BLELL_CONN_CONFIG_RX_INTR_THRESHOLD(v)   ((v) << 4)
  #define BLELL_CONN_CONFIG_RX_INTR_THRESHOLD_SET(x, v) do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define BLELL_CONN_CONFIG_RX_INTR_THRESHOLD_GET(x) (((x) >> 4) & 0xf)
/** This register field indicates whether the MD (More Data) bit needs to be
   controlled by software or, hardware and soft-ware logic combined. @multiple */
  #define BLELL_CONN_CONFIG_MD_BIT_CLEAR(v)        ((BLELL_CONN_CONFIG_MD_BIT_CLEAR_##v) << 8)
  #define BLELL_CONN_CONFIG_MD_BIT_CLEAR_SET(x, v) do { (x) = (((x) & ~0x100) | ((BLELL_CONN_CONFIG_MD_BIT_CLEAR_##v) << 8)); } while(0)
  #define BLELL_CONN_CONFIG_MD_BIT_CLEAR_SETVAL(x, v) do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define BLELL_CONN_CONFIG_MD_BIT_CLEAR_GET(x)    (((x) >> 8) & 0x1)
/** MD Bit in the transmitted pdu is controlled by software and hardware logic. MD bit is set in transmitted packet, only if the software has set the md bit in CE_CNFG_STS[6] and either of the following conditions is true, a) If there are packets queued for transmission. b) If there is an acknowledgement awaited from the remote side for the packet transmitted. */
    #define BLELL_CONN_CONFIG_MD_BIT_CLEAR_BOTH      0x00000000
/** MD bit is exclusively controlled by software, ie based on status of CE_CNFG_STS[6] - md bit. */
    #define BLELL_CONN_CONFIG_MD_BIT_CLEAR_SOFTWARE  0x00000001
/** This bit configures the DSM slot counting mode. @multiple */
  #define BLELL_CONN_CONFIG_DSM_SLOT_VARIANCE(v)   ((BLELL_CONN_CONFIG_DSM_SLOT_VARIANCE_##v) << 11)
  #define BLELL_CONN_CONFIG_DSM_SLOT_VARIANCE_SET(x, v) do { (x) = (((x) & ~0x800) | ((BLELL_CONN_CONFIG_DSM_SLOT_VARIANCE_##v) << 11)); } while(0)
  #define BLELL_CONN_CONFIG_DSM_SLOT_VARIANCE_SETVAL(x, v) do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
  #define BLELL_CONN_CONFIG_DSM_SLOT_VARIANCE_GET(x) (((x) >> 11) & 0x1)
/** The DSM slot count variance with respect to actual time is less than 1 slot */
    #define BLELL_CONN_CONFIG_DSM_SLOT_VARIANCE_1_SLOT 0x00000000
/** The DSM slot count variance with respect to actual time is more than 1 slot, less than 2 slots */
    #define BLELL_CONN_CONFIG_DSM_SLOT_VARIANCE_1_2_SLOT 0x00000001
/** This bit is set to configure the MD bit control when IUT is in slave role.
   @multiple */
  #define BLELL_CONN_CONFIG_SLV_MD_CONFIG(v)       ((BLELL_CONN_CONFIG_SLV_MD_CONFIG_##v) << 12)
  #define BLELL_CONN_CONFIG_SLV_MD_CONFIG_SET(x, v) do { (x) = (((x) & ~0x1000) | ((BLELL_CONN_CONFIG_SLV_MD_CONFIG_##v) << 12)); } while(0)
  #define BLELL_CONN_CONFIG_SLV_MD_CONFIG_SETVAL(x, v) do { (x) = (((x) & ~0x1000) | ((v) << 12)); } while(0)
  #define BLELL_CONN_CONFIG_SLV_MD_CONFIG_GET(x)   (((x) >> 12) & 0x1)
/** MD bit will be decided on packet queued in next buffer status This bit has effect only when CONN_CONFIG.md_bit_ctr bit is not set. */
    #define BLELL_CONN_CONFIG_SLV_MD_CONFIG_QUEUED   0x00000000
/** MD bit will be decided on packet pending status */
    #define BLELL_CONN_CONFIG_SLV_MD_CONFIG_PENDING  0x00000001
/** This bit is used to enable/disable extending the additional rx window on
   slave side during con- nection update in event of packet miss at the update
   instant. @multiple */
  #define BLELL_CONN_CONFIG_EXTEND_CU_TX_WIN       0x2000
/** This bit is used to enable/disable masking of internal hardware supervision
   timeout trigger when switching from old connection parameters to new
   parameters. @multiple */
  #define BLELL_CONN_CONFIG_MASK_SUTO_AT_UPDT      0x4000
/** This bit is used to enable extension of the Conn Request to arbiter to 1 slot
   early. When enabled the request length is 2 slots. @multiple */
  #define BLELL_CONN_CONFIG_CONN_REQ_1SLOT_EARLY   0x8000

/** Transmit power to be used for all packets transmitted on the connection
   channel. @multiple */
#define BLELL_CONN_CH_TX_POWER_ADDR                  0x000001e4
#define BLELL_CONN_CH_TX_POWER_MASK                  0x00000000

#define BLELL_CONN_PARAM1_ADDR                       0x000001e8
#define BLELL_CONN_PARAM1_MASK                       0x0000ffff
/** Sleep Clock Accuracy @multiple */
  #define BLELL_CONN_PARAM1_SCA(v)                 ((v) << 0)
  #define BLELL_CONN_PARAM1_SCA_SET(x, v)          do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define BLELL_CONN_PARAM1_SCA_GET(x)             (((x) >> 0) & 0x7)
/** Hop increment for connection channel. @multiple */
  #define BLELL_CONN_PARAM1_HOP(v)                 ((v) << 3)
  #define BLELL_CONN_PARAM1_HOP_SET(x, v)          do { (x) = (((x) & ~0xf8) | ((v) << 3)); } while(0)
  #define BLELL_CONN_PARAM1_HOP_GET(x)             (((x) >> 3) & 0x1f)
/** This field defines the lower byte (7:0) of the CRC initialization vector.
   @multiple */
  #define BLELL_CONN_PARAM1_CRC_INIT_L(v)          ((v) << 8)
  #define BLELL_CONN_PARAM1_CRC_INIT_L_SET(x, v)   do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define BLELL_CONN_PARAM1_CRC_INIT_L_GET(x)      (((x) >> 8) & 0xff)

/** This field defines the upper two bytes (23:8) of the CRC initialization
   vector. @multiple */
#define BLELL_CONN_PARAM2_ADDR                       0x000001ec
#define BLELL_CONN_PARAM2_MASK                       0x00000000

#define BLELL_CONN_INTR_MASK_ADDR                    0x000001f0
#define BLELL_CONN_INTR_MASK_MASK                    0x0000c3ff
/** Connection closed interrupt is enabled. @multiple */
  #define BLELL_CONN_INTR_MASK_CONN_CL_INT_EN      0x0001
/** Connection establishment interrupt is enabled. @multiple */
  #define BLELL_CONN_INTR_MASK_CONN_ESTB_INT_EN    0x0002
/** Channel map update interrupt is enabled. @multiple */
  #define BLELL_CONN_INTR_MASK_MAP_UPDT_INT_EN     0x0004
/** Connection event start interrupt is enabled @multiple */
  #define BLELL_CONN_INTR_MASK_START_CE_INT_EN     0x0008
/** Connection event closed interrupt is enabled. @multiple */
  #define BLELL_CONN_INTR_MASK_CLOSE_CE_INT_EN     0x0010
/** Transmission acknowledgement interrupt is enabled: This interrupt is
   generated to indicate to the firmware that a non-empty packet transmitted is
   suc- cessfully acknowledged by the remote device. For negative
   acknowledgements from remote device, this interrupt indication is not
   generated. @multiple */
  #define BLELL_CONN_INTR_MASK_CE_TX_ACK_INT_EN    0x0020
/** Interrupt is enabled for reception of packet in a connection event. @multiple
   */
  #define BLELL_CONN_INTR_MASK_CE_RX_INT_EN        0x0040
/** Connection update interrupt is enabled. @multiple */
  #define BLELL_CONN_INTR_MASK_CONN_UPDATE_INTR_EN 0x0080
/** Packet receive good pdu interrupt is enabled. Effective only when bit 6 is
   set. @multiple */
  #define BLELL_CONN_INTR_MASK_RX_GOOD_PDU_INT_EN  0x0100
/** Packet receive bad pdu interrupt is enabled. Effective only when bit 6 is
   set. @multiple */
  #define BLELL_CONN_INTR_MASK_RX_BAD_PDU_INT_EN   0x0200
/** Ping timer expired interrupt is enabled. @multiple */
  #define BLELL_CONN_INTR_MASK_PING_TIMER_EXPIRD_INTR 0x4000
/** Ping timer nearly expired interrupt is enabled @multiple */
  #define BLELL_CONN_INTR_MASK_PING_NEARLY_EXPIRD_INTR 0x8000

#define BLELL_SLAVE_TIMING_CONTROL_ADDR              0x000001f4
#define BLELL_SLAVE_TIMING_CONTROL_MASK              0x0000ffff
/** Programmable adjust value to the clock counter when slave is connected
   @multiple */
  #define BLELL_SLAVE_TIMING_CONTROL_SLAVE_TIME_SET_VAL(v) ((v) << 0)
  #define BLELL_SLAVE_TIMING_CONTROL_SLAVE_TIME_SET_VAL_SET(x, v) do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define BLELL_SLAVE_TIMING_CONTROL_SLAVE_TIME_SET_VAL_GET(x) (((x) >> 0) & 0xff)
/** Timing adjust value. The internal micro second counter is adjusted to this
   value whenever slave receives a good access address match at connection anchor
   point. This will ensure the slave gets synchronized to master timing.
   @multiple */
  #define BLELL_SLAVE_TIMING_CONTROL_SLAVE_TIME_ADJ_VAL(v) ((v) << 8)
  #define BLELL_SLAVE_TIMING_CONTROL_SLAVE_TIME_ADJ_VAL_SET(x, v) do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define BLELL_SLAVE_TIMING_CONTROL_SLAVE_TIME_ADJ_VAL_GET(x) (((x) >> 8) & 0xff)

#define BLELL_RECEIVE_TRIG_CTRL_ADDR                 0x000001f8
#define BLELL_RECEIVE_TRIG_CTRL_MASK                 0x0000ff3f
/** Access address match threshold value. Number of bits of ac-cess address that
   should match with the expected access ad-dress to trigger an access code
   match. Lower values may be programmed for bad radios or channels but care must
   be taken to ensure there are no false matches due to reduced number of bits
   required to match. @multiple */
  #define BLELL_RECEIVE_TRIG_CTRL_ACC_TRIGGER_THRESHOLD(v) ((v) << 0)
  #define BLELL_RECEIVE_TRIG_CTRL_ACC_TRIGGER_THRESHOLD_SET(x, v) do { (x) = (((x) & ~0x3f) | ((v) << 0)); } while(0)
  #define BLELL_RECEIVE_TRIG_CTRL_ACC_TRIGGER_THRESHOLD_GET(x) (((x) >> 0) & 0x3f)
/** If access address match does not occur then within this time from the start
   of receive operation, the receive operation times out and stops. An internal
   counter value of 1usec resolution is con- tinuously compared with the value
   programmed. @multiple */
  #define BLELL_RECEIVE_TRIG_CTRL_ACC_TRIGGER_TIMEOUT(v) ((v) << 8)
  #define BLELL_RECEIVE_TRIG_CTRL_ACC_TRIGGER_TIMEOUT_SET(x, v) do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define BLELL_RECEIVE_TRIG_CTRL_ACC_TRIGGER_TIMEOUT_GET(x) (((x) >> 8) & 0xff)

/** If CY_CORREL_EN is 0: [2:0] Read pointer correction on DPLL overflow. Optimal
   setting is 0x4. [6:4] Minimum distance from Rd ptr to Wr ptr to start read in
   DPLL. Optimal setting is 0x6. [11:8] Sets lower water mark for DPLL. Optimal
   setting is 0x2. [15:12] Sets upper water mark for DPLL. Optimal setting is
   0x9. If CY_CORREL_EN is 1: [11:0] CY correl Access address compare mask for
   LSB 12 bits. Ideal value is 0xFFF [15:12] CY correl maximum number of allowed
   mismatched bits in access address. Ideal value is 0x0. @multiple */
#define BLELL_DPLL_CONFIG_ADDR                       0x00000258
#define BLELL_DPLL_CONFIG_MASK                       0x00000000

/** Device address values written to white list memory are written as 16-bit wide
   address. @multiple */
#define BLELL_WHITELIST_BASE_ADDR_ADDR               0x00000340
#define BLELL_WHITELIST_BASE_ADDR_MASK               0x00000000

/** This register will have the new connection interval that the hardware will
   use after the connection update instant. Before the instant, the connection
   interval in the register CONN_INTERVAL will be used by hardware. @multiple */
#define BLELL_CONN_UPDATE_NEW_INTERVAL_ADDR          0x000003a4
#define BLELL_CONN_UPDATE_NEW_INTERVAL_MASK          0x00000000

/** This register will have the new slave latency parameter that the hardware
   will use after the con- nection update instant. Before the instant, the
   connection interval in the register SLAVE_LATENCY will be used by hardware.
   @multiple */
#define BLELL_CONN_UPDATE_NEW_LATENCY_ADDR           0x000003a8
#define BLELL_CONN_UPDATE_NEW_LATENCY_MASK           0x00000000

/** This register will have the new supervision timeout that the hardware will
   use after the connection update instant. Before the instant, the connection
   interval in the register SUP_TIMEOUT will be used by hardware. @multiple */
#define BLELL_CONN_UPDATE_NEW_SUP_TO_ADDR            0x000003ac
#define BLELL_CONN_UPDATE_NEW_SUP_TO_MASK            0x00000000

/** This register will have the new Slave Latency * Conn Interval value that the
   hardware will use after the connection update instant. Before the instant, the
   connection interval in the register SL_CONN_INTERVAL will be used by hardware.
   @multiple */
#define BLELL_CONN_UPDATE_NEW_SL_INTERVAL_ADDR       0x000003b0
#define BLELL_CONN_UPDATE_NEW_SL_INTERVAL_MASK       0x00000000

#define BLELL_CONN_REQ_WORD0_ADDR                    0x000003c0
#define BLELL_CONN_REQ_WORD0_MASK                    0x0000ffff
/** This field defines the lower 16 bits of the access address that is to be sent
   in the connect request packet of the initiator. @multiple */
  #define BLELL_CONN_REQ_WORD0_ACCESS_ADDR_LOWER(v) ((v) << 0)
  #define BLELL_CONN_REQ_WORD0_ACCESS_ADDR_LOWER_SET(x, v) do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define BLELL_CONN_REQ_WORD0_ACCESS_ADDR_LOWER_GET(x) (((x) >> 0) & 0xffff)

#define BLELL_CONN_REQ_WORD1_ADDR                    0x000003c4
#define BLELL_CONN_REQ_WORD1_MASK                    0x0000ffff
/** This field defines the upper16 bits of the access address that is to be sent
   in the connect request packet of the initiator. @multiple */
  #define BLELL_CONN_REQ_WORD1_ACCESS_ADDR_UPPER(v) ((v) << 0)
  #define BLELL_CONN_REQ_WORD1_ACCESS_ADDR_UPPER_SET(x, v) do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define BLELL_CONN_REQ_WORD1_ACCESS_ADDR_UPPER_GET(x) (((x) >> 0) & 0xffff)

#define BLELL_CONN_REQ_WORD2_ADDR                    0x000003c8
#define BLELL_CONN_REQ_WORD2_MASK                    0x0000ffff
/** window_size along with the window_offset is used to calculate the first
   connection point anchor point for the master. This shall be a multiple of 1.25
   ms in the range of 1.25 ms to the lesser of 10 ms and (connInterval - 1.25
   ms). @multiple */
  #define BLELL_CONN_REQ_WORD2_TX_WINDOW_SIZE_VAL(v) ((v) << 0)
  #define BLELL_CONN_REQ_WORD2_TX_WINDOW_SIZE_VAL_SET(x, v) do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define BLELL_CONN_REQ_WORD2_TX_WINDOW_SIZE_VAL_GET(x) (((x) >> 0) & 0xff)
/** This field defines the lower byte [7:0] of the CRC initialization value.
   @multiple */
  #define BLELL_CONN_REQ_WORD2_CRC_INIT_LOWER(v)   ((v) << 8)
  #define BLELL_CONN_REQ_WORD2_CRC_INIT_LOWER_SET(x, v) do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define BLELL_CONN_REQ_WORD2_CRC_INIT_LOWER_GET(x) (((x) >> 8) & 0xff)

#define BLELL_CONN_REQ_WORD3_ADDR                    0x000003cc
#define BLELL_CONN_REQ_WORD3_MASK                    0x0000ffff
/** This field defines the upper byte [23:8] of the CRC initialization value that
   is to be sent in the con- nect request packet of the initiator. @multiple */
  #define BLELL_CONN_REQ_WORD3_CRC_INIT_UPPER(v)   ((v) << 0)
  #define BLELL_CONN_REQ_WORD3_CRC_INIT_UPPER_SET(x, v) do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define BLELL_CONN_REQ_WORD3_CRC_INIT_UPPER_GET(x) (((x) >> 0) & 0xffff)

#define BLELL_CONN_REQ_WORD4_ADDR                    0x000003d0
#define BLELL_CONN_REQ_WORD4_MASK                    0x0000ffff
/** This is used to determine the anchor point for the master transmission.
   Range: This shall be a multiple of 1.25 ms in the range of 0 ms to
   connInterval value. @multiple */
  #define BLELL_CONN_REQ_WORD4_TX_WINDOW_OFFSET(v) ((v) << 0)
  #define BLELL_CONN_REQ_WORD4_TX_WINDOW_OFFSET_SET(x, v) do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define BLELL_CONN_REQ_WORD4_TX_WINDOW_OFFSET_GET(x) (((x) >> 0) & 0xffff)

#define BLELL_CONN_REQ_WORD5_ADDR                    0x000003d4
#define BLELL_CONN_REQ_WORD5_MASK                    0x0000ffff
/** The value configured in this register determines the spacing between the
   connection events. This shall be a multiple of 1.25 ms in the range of 7.5 ms
   to 4.0 s. @multiple */
  #define BLELL_CONN_REQ_WORD5_CONN_INTERVAL_VAL(v) ((v) << 0)
  #define BLELL_CONN_REQ_WORD5_CONN_INTERVAL_VAL_SET(x, v) do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define BLELL_CONN_REQ_WORD5_CONN_INTERVAL_VAL_GET(x) (((x) >> 0) & 0xffff)

#define BLELL_CONN_REQ_WORD6_ADDR                    0x000003d8
#define BLELL_CONN_REQ_WORD6_MASK                    0x0000ffff
/** The value configured in this field defines the number of consecutive
   connection events that the slave device is not required to listen for master.
   The value of connSlaveLatency should not cause a Supervision Timeout. This
   shall be an integer in the range of 0 to ((connSupervision
   Timeout/connInterval)-1). connSlaveLatency @multiple */
  #define BLELL_CONN_REQ_WORD6_SLAVE_LATENCY_VAL(v) ((v) << 0)
  #define BLELL_CONN_REQ_WORD6_SLAVE_LATENCY_VAL_SET(x, v) do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define BLELL_CONN_REQ_WORD6_SLAVE_LATENCY_VAL_GET(x) (((x) >> 0) & 0xffff)

#define BLELL_CONN_REQ_WORD7_ADDR                    0x000003dc
#define BLELL_CONN_REQ_WORD7_MASK                    0x0000ffff
/** This field defines the maximum time between two received Data packet PDUs
   before the con- nection is considered lost. This shall be a multiple of 10 ms
   in the range of 100 ms to 32.0 s and it shall be larger than
   (1+connSlaveLatency)*connInterval. @multiple */
  #define BLELL_CONN_REQ_WORD7_SUPERVISION_TIMEOUT_VAL(v) ((v) << 0)
  #define BLELL_CONN_REQ_WORD7_SUPERVISION_TIMEOUT_VAL_SET(x, v) do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define BLELL_CONN_REQ_WORD7_SUPERVISION_TIMEOUT_VAL_GET(x) (((x) >> 0) & 0xffff)

#define BLELL_CONN_REQ_WORD8_ADDR                    0x000003e0
#define BLELL_CONN_REQ_WORD8_MASK                    0x0000ffff
/** This register field indicates which of the data channels are in use. This
   stores the information for the lower 16 (15:0) data channel indices. 1
   indicates the corresponding data channel is used and 0 indicates the channel
   is unused. @multiple */
  #define BLELL_CONN_REQ_WORD8_DATA_CHANNELS_LOWER(v) ((v) << 0)
  #define BLELL_CONN_REQ_WORD8_DATA_CHANNELS_LOWER_SET(x, v) do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define BLELL_CONN_REQ_WORD8_DATA_CHANNELS_LOWER_GET(x) (((x) >> 0) & 0xffff)

#define BLELL_CONN_REQ_WORD9_ADDR                    0x000003e4
#define BLELL_CONN_REQ_WORD9_MASK                    0x0000ffff
/** This register field indicates which of the data channels are in use. This
   stores the information for the middle 16 (31:16) data channel indices. 1
   indicates the corresponding data channel is used and 0 indicates the channel
   is unused. @multiple */
  #define BLELL_CONN_REQ_WORD9_DATA_CHANNELS_MID(v) ((v) << 0)
  #define BLELL_CONN_REQ_WORD9_DATA_CHANNELS_MID_SET(x, v) do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define BLELL_CONN_REQ_WORD9_DATA_CHANNELS_MID_GET(x) (((x) >> 0) & 0xffff)

#define BLELL_CONN_REQ_WORD10_ADDR                   0x000003e8
#define BLELL_CONN_REQ_WORD10_MASK                   0x0000001f
/** This register field indicates which of the data channels are in use. This
   stores the information for the upper 5 (36:32) data channel indices. 1
   indicates the corresponding data channel is used and 0 indicates the channel
   is unused. @multiple */
  #define BLELL_CONN_REQ_WORD10_DATA_CHANNELS_UPPER(v) ((v) << 0)
  #define BLELL_CONN_REQ_WORD10_DATA_CHANNELS_UPPER_SET(x, v) do { (x) = (((x) & ~0x1f) | ((v) << 0)); } while(0)
  #define BLELL_CONN_REQ_WORD10_DATA_CHANNELS_UPPER_GET(x) (((x) >> 0) & 0x1f)

#define BLELL_CONN_REQ_WORD11_ADDR                   0x000003ec
#define BLELL_CONN_REQ_WORD11_MASK                   0x000000ff
/** This field is used for the data channel selection process. @multiple */
  #define BLELL_CONN_REQ_WORD11_HOP_INCREMENT_2(v) ((v) << 0)
  #define BLELL_CONN_REQ_WORD11_HOP_INCREMENT_2_SET(x, v) do { (x) = (((x) & ~0x1f) | ((v) << 0)); } while(0)
  #define BLELL_CONN_REQ_WORD11_HOP_INCREMENT_2_GET(x) (((x) >> 0) & 0x1f)
/** This field defines the sleep clock accuracies given in ppm. @multiple */
  #define BLELL_CONN_REQ_WORD11_SCA_2(v)           ((v) << 5)
  #define BLELL_CONN_REQ_WORD11_SCA_2_SET(x, v)    do { (x) = (((x) & ~0xe0) | ((v) << 5)); } while(0)
  #define BLELL_CONN_REQ_WORD11_SCA_2_GET(x)       (((x) >> 5) & 0x7)

/** Lower 16-bits of the packet counter value passed as part of Nonce for the
   packet to be encrypted. @multiple */
#define BLELL_PACKET_COUNTER_LOWER_ADDR              0x00000400
#define BLELL_PACKET_COUNTER_LOWER_MASK              0x00000000

/** Middle 16-bits of the packet counter value passed as part of Nonce for the
   packet to be encrypted. @multiple */
#define BLELL_PACKET_COUNTER_MIDDLE_ADDR             0x00000404
#define BLELL_PACKET_COUNTER_MIDDLE_MASK             0x00000000

#define BLELL_PACKET_COUNTER_UPPER_ADDR              0x00000408
#define BLELL_PACKET_COUNTER_UPPER_MASK              0x000000ff
/** Upper 8 bits of the packet counter value passed as part of Nonce for the
   packet to be encrypted. @multiple */
  #define BLELL_PACKET_COUNTER_UPPER_PACKET_COUNTER_UPPER(v) ((v) << 0)
  #define BLELL_PACKET_COUNTER_UPPER_PACKET_COUNTER_UPPER_SET(x, v) do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define BLELL_PACKET_COUNTER_UPPER_PACKET_COUNTER_UPPER_GET(x) (((x) >> 0) & 0xff)

/** This is the IVm field. @multiple */
#define BLELL_IV_MASTER_ADDR(ridx)                   (0x00000410 + (ridx) * 4)
#define BLELL_IV_MASTER_COUNT                        2
#define BLELL_IV_MASTER_MASK                         0x00000000

/** This is the IVs field. @multiple */
#define BLELL_IV_SLAVE_ADDR(ridx)                    (0x00000418 + (ridx) * 4)
#define BLELL_IV_SLAVE_COUNT                         2
#define BLELL_IV_SLAVE_MASK                          0x00000000

/** The encryption key / session key which is used in ECB encryption, CCM
   encryption and CCM decryption. @multiple */
#define BLELL_ENC_KEY_ADDR(ridx)                     (0x00000420 + (ridx) * 4)
#define BLELL_ENC_KEY_COUNT                          8
#define BLELL_ENC_KEY_MASK                           0x00000000

#define BLELL_DATA_ADDR(ridx)                        (0x00000440 + (ridx) * 4)
#define BLELL_DATA_COUNT                             14
#define BLELL_DATA_MASK                              0x00000000

/** MIC field used for CCM decryption. @multiple */
#define BLELL_MIC_IN_ADDR(ridx)                      (0x00000478 + (ridx) * 4)
#define BLELL_MIC_IN_COUNT                           2
#define BLELL_MIC_IN_MASK                            0x00000000

/** MIC generated during CCM encryption. @multiple */
#define BLELL_MIC_OUT_ADDR(ridx)                     (0x00000480 + (ridx) * 4)
#define BLELL_MIC_OUT_COUNT                          2
#define BLELL_MIC_OUT_MASK                           0x00000000

#define BLELL_ENC_PARAMS_ADDR                        0x00000488
#define BLELL_ENC_PARAMS_MASK                        0x000000ff
/** LLID of the packet. @multiple */
  #define BLELL_ENC_PARAMS_DATA_PDU_HEADER(v)      ((v) << 0)
  #define BLELL_ENC_PARAMS_DATA_PDU_HEADER_SET(x, v) do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define BLELL_ENC_PARAMS_DATA_PDU_HEADER_GET(x)  (((x) >> 0) & 0x3)
/** Length of the input data. @multiple */
  #define BLELL_ENC_PARAMS_PAYLOAD_LENGTH(v)       ((v) << 2)
  #define BLELL_ENC_PARAMS_PAYLOAD_LENGTH_SET(x, v) do { (x) = (((x) & ~0x7c) | ((v) << 2)); } while(0)
  #define BLELL_ENC_PARAMS_PAYLOAD_LENGTH_GET(x)   (((x) >> 2) & 0x1f)
  #define BLELL_ENC_PARAMS_DIRECTION(v)            ((BLELL_ENC_PARAMS_DIRECTION_##v) << 7)
  #define BLELL_ENC_PARAMS_DIRECTION_SET(x, v)     do { (x) = (((x) & ~0x80) | ((BLELL_ENC_PARAMS_DIRECTION_##v) << 7)); } while(0)
  #define BLELL_ENC_PARAMS_DIRECTION_SETVAL(x, v)  do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
  #define BLELL_ENC_PARAMS_DIRECTION_GET(x)        (((x) >> 7) & 0x1)
/** PDU Sent by slave */
    #define BLELL_ENC_PARAMS_DIRECTION_FROM_SLAVE    0x00000000
/** PDU Sent by master */
    #define BLELL_ENC_PARAMS_DIRECTION_FROM_MASTER   0x00000001

#define BLELL_ENC_CONFIG_ADDR                        0x00000490
#define BLELL_ENC_CONFIG_MASK                        0x00000007
/** 1 Start the AES processing @multiple */
  #define BLELL_ENC_CONFIG_START_PROC              0x0001
  #define BLELL_ENC_CONFIG_MODE(v)                 ((BLELL_ENC_CONFIG_MODE_##v) << 1)
  #define BLELL_ENC_CONFIG_MODE_SET(x, v)          do { (x) = (((x) & ~0x2) | ((BLELL_ENC_CONFIG_MODE_##v) << 1)); } while(0)
  #define BLELL_ENC_CONFIG_MODE_SETVAL(x, v)       do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define BLELL_ENC_CONFIG_MODE_GET(x)             (((x) >> 1) & 0x1)
/** CCM */
    #define BLELL_ENC_CONFIG_MODE_CCM                0x00000000
/** ECB */
    #define BLELL_ENC_CONFIG_MODE_ECB                0x00000001
/** Decryption / Encryption @multiple */
  #define BLELL_ENC_CONFIG_DECRYPT                 0x0004

#define BLELL_ENC_INTR_EN_ADDR                       0x00000498
#define BLELL_ENC_INTR_EN_MASK                       0x00000007
/** Authentication interrupt enable @multiple */
  #define BLELL_ENC_INTR_EN_AUTH_PASS_INTR_EN      0x0001
/** ECB processed interrupt enable @multiple */
  #define BLELL_ENC_INTR_EN_ECB_PROC_INTR_EN       0x0002
/** CCM processed interupt enable @multiple */
  #define BLELL_ENC_INTR_EN_CCM_PROC_INTR_EN       0x0004

#define BLELL_ENC_INTR_ADDR                          0x000004a0
#define BLELL_ENC_INTR_MASK                          0x0000000f
/** Authentication interrupt. Write 1 to clear @multiple */
  #define BLELL_ENC_INTR_AUTH_PASS_INTR(v)         ((BLELL_ENC_INTR_AUTH_PASS_INTR_##v) << 0)
  #define BLELL_ENC_INTR_AUTH_PASS_INTR_SET(x, v)  do { (x) = (((x) & ~0x1) | ((BLELL_ENC_INTR_AUTH_PASS_INTR_##v) << 0)); } while(0)
  #define BLELL_ENC_INTR_AUTH_PASS_INTR_SETVAL(x, v) do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define BLELL_ENC_INTR_AUTH_PASS_INTR_GET(x)     (((x) >> 0) & 0x1)
/** indicated MIC mismatched */
    #define BLELL_ENC_INTR_AUTH_PASS_INTR_MIC_FAILED 0x00000000
/** indicates MIC matched */
    #define BLELL_ENC_INTR_AUTH_PASS_INTR_MIC_MATCHED 0x00000001
/** ECB processed interrupt. Write 1 to clear @multiple */
  #define BLELL_ENC_INTR_ECB_PROC_INTR             0x0002
/** CCM processed interrupt. Write 1 to clear @multiple */
  #define BLELL_ENC_INTR_CCM_PROC_INTR             0x0004
/** Clears the input data. Used for Zero padding of encryption for less than
   block sized data. @multiple */
  #define BLELL_ENC_INTR_IN_DATA_CLEAR             0x0008

/** Data values written to Tx memory are written as 16-bit wide data. @multiple
   */
#define BLELL_CONN_TXMEM_BASE_ADDR_ADDR              0x00000600
#define BLELL_CONN_TXMEM_BASE_ADDR_MASK              0x00000000

/** Data values written to Rx memory are written as 16-bit wide data @multiple */
#define BLELL_CONN_RXMEM_BASE_ADDR_ADDR              0x00000800
#define BLELL_CONN_RXMEM_BASE_ADDR_MASK              0x00000000

/** This register is loaded with the count value to monitor the time to get a
   response for a PDU from peer device. Firmware starts the timer by issuing the
   command, RESP_TIMER_ON, after it has queued a PDU for transmission, that
   requires a response. If a response is received, firmware stops and clears the
   timer by issuing the command RESP_TIMER_OFF. If this timer expires, it results
   in hardware closing the connection and triggering a conn_closed interrupt. The
   discon_status field in the Connection status register is set with the
   appropriate reason. Units : Milliseconds. Resolution : 1.25 ms @multiple */
#define BLELL_PDU_RESP_TIMER_ADDR                    0x00000a04
#define BLELL_PDU_RESP_TIMER_MASK                    0x00000000

/** This field defines the clock instant at which the next PDU response timeout
   event will occur on a connection. This is with reference to the 16-bit
   internal reference clock. @multiple */
#define BLELL_NEXT_RESP_TIMER_EXP_ADDR               0x00000a08
#define BLELL_NEXT_RESP_TIMER_EXP_MASK               0x00000000

/** This field defines the clock instant at which the next connection supervision
   timeout event will occur on a connection This is with reference to the 16-bit
   internal reference clock. @multiple */
#define BLELL_NEXT_SUP_TO_ADDR                       0x00000a0c
#define BLELL_NEXT_SUP_TO_MASK                       0x00000000

#define BLELL_LLH_FEATURE_CONFIG_ADDR                0x00000a10
#define BLELL_LLH_FEATURE_CONFIG_MASK                0x00000003
/** Quick transmit feature in slave latency is enabled by setting this bit. When
   slave latency is enabled, this feature enables the slave to transmit in the
   immediate con- nection interval, in case required, instead of waiting till the
   end of slave latency @multiple */
  #define BLELL_LLH_FEATURE_CONFIG_QUICK_TRANSMIT  0x0001
/** Enable/Disable Slave Latency Period DSM. @multiple */
  #define BLELL_LLH_FEATURE_CONFIG_SL_DSM_EN       0x0002

#define BLELL_WIN_MIN_STEP_SIZE_ADDR                 0x00000a14
#define BLELL_WIN_MIN_STEP_SIZE_MASK                 0x0000ffff
/** After receiving 2 consecutive good packets the reference window is gradually
   decremented by step down size until it reaches window minimum. The unit is in
   microseconds @multiple */
  #define BLELL_WIN_MIN_STEP_SIZE_STEPDN(v)        ((v) << 0)
  #define BLELL_WIN_MIN_STEP_SIZE_STEPDN_SET(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define BLELL_WIN_MIN_STEP_SIZE_STEPDN_GET(x)    (((x) >> 0) & 0xf)
/** If packets are missed, the reference window is gradually increased by step up
   size, until it re- ceives 2 consecutive good packets. The unit is in
   microseconds @multiple */
  #define BLELL_WIN_MIN_STEP_SIZE_STEPUP(v)        ((v) << 4)
  #define BLELL_WIN_MIN_STEP_SIZE_STEPUP_SET(x, v) do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define BLELL_WIN_MIN_STEP_SIZE_STEPUP_GET(x)    (((x) >> 4) & 0xf)
/** Minimum window interval value programmed by firmware. While the slave receive
   window is decremented, the windows_min_fw sets the lowest value of the window
   widen value to ensure packets are not missed. The unit is in microseconds.
   @multiple */
  #define BLELL_WIN_MIN_STEP_SIZE_WINDOW_MIN_FW(v) ((v) << 8)
  #define BLELL_WIN_MIN_STEP_SIZE_WINDOW_MIN_FW_SET(x, v) do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define BLELL_WIN_MIN_STEP_SIZE_WINDOW_MIN_FW_GET(x) (((x) >> 8) & 0xff)

/** Window Adjust value. This value is added to the calculated slave window
   widening value to be used as final window widen value. @multiple */
#define BLELL_SLV_WIN_ADJ_ADDR                       0x00000a18
#define BLELL_SLV_WIN_ADJ_MASK                       0x00000000

/** This field defines the (SL*CI) product for the ongoing connection. This value
   is used in calculation of next connection instant during slave latency.
   @multiple */
#define BLELL_SL_CONN_INTERVAL_ADDR                  0x00000a1c
#define BLELL_SL_CONN_INTERVAL_MASK                  0x00000000

/** The register used to configure the LE Au-thenticated payload Timeout (LE
   APTO) which is the Maximum amount of time specified between packets
   authenticated by a MIC. This value of ping timer is in the order of 10ms,
   valid range 0x1 ~ 0xFFFF @multiple */
#define BLELL_LE_PING_TIMER_ADDR_ADDR                0x00000a20
#define BLELL_LE_PING_TIMER_ADDR_MASK                0x00000000

/** The value of ping timer nearly expired offset in the order of 10ms, valid
   range 0x0 ~ 0xFFFF. This is the time period after which the ping timer nearly
   expired interrupt is generated. @multiple */
#define BLELL_LE_PING_TIMER_OFFSET_ADDR              0x00000a24
#define BLELL_LE_PING_TIMER_OFFSET_MASK              0x00000000

/** The value of ping timer next expiry instant in the terms of native clock
   value (least 16 bit value of the 17 bit ping counter). This together with
   CONN_PING_TIMER_NEXT_EXP_WRAP will provide the correct status of ping timer
   duration. @multiple */
#define BLELL_LE_PING_TIMER_NEXT_EXP_ADDR            0x00000a28
#define BLELL_LE_PING_TIMER_NEXT_EXP_MASK            0x00000000

/** This register holds the current position of the Ping timer. @multiple */
#define BLELL_LE_PING_TIMER_WRAP_COUNT_ADDR          0x00000a2c
#define BLELL_LE_PING_TIMER_WRAP_COUNT_MASK          0x00000000

/** Transmit enable extension delay. This is to extend the active state (high) of
   rif_tx_en signal after the last bit is sent out from LLH. The unit is in
   microsecond and the supported range is 00 31 us. @multiple */
#define BLELL_TX_EN_EXT_DELAY_ADDR                   0x00000e00
#define BLELL_TX_EN_EXT_DELAY_MASK                   0x00000000

#define BLELL_TX_RX_SYNTH_DELAY_ADDR                 0x00000e04
#define BLELL_TX_RX_SYNTH_DELAY_MASK                 0x0000ffff
/** The delay used to assert rif_rx_en, Rx_tRamp micro-seconds, ahead of first
   bit of the expected rx_data, which can be used to turn on the Radio receiver.
   The value to be programmed to the Rx_en_delay [7:0] = rx_on_delay - Rx_tRamp
   rx_on_delay[7:0] = TX_RX_ON_DELAY[7:0]) Rx_tRamp = Radio receiver rampup time
   @multiple */
  #define BLELL_TX_RX_SYNTH_DELAY_RX_EN_DELAY(v)   ((v) << 0)
  #define BLELL_TX_RX_SYNTH_DELAY_RX_EN_DELAY_SET(x, v) do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define BLELL_TX_RX_SYNTH_DELAY_RX_EN_DELAY_GET(x) (((x) >> 0) & 0xff)
/** The delay used to assert rif_tx_en exactly Tx_tRamp micro-seconds ahead of
   the first bit of the tx_data, which can be used to turn on the Radio
   transmitter. The value to be programmed to the Tx_en_delay [7:0] = tx_on_delay
   - Tx_tRamp tx_on_delay[7:0] = TX_RX_ON_DELAY[15:8]) Tx_tRamp = Radio
   transmitter ramp_up @multiple */
  #define BLELL_TX_RX_SYNTH_DELAY_TX_EN_DELAY(v)   ((v) << 8)
  #define BLELL_TX_RX_SYNTH_DELAY_TX_EN_DELAY_SET(x, v) do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define BLELL_TX_RX_SYNTH_DELAY_TX_EN_DELAY_GET(x) (((x) >> 8) & 0xff)

#endif

