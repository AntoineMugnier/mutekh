/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -I srss.bf -O srss.h -o cdefs cdefs_use_reg_mask=1                    \
     cdefs_use_field_setval=1
*/

#ifndef _SRSS_BFGEN_DEFS_
#define _SRSS_BFGEN_DEFS_

/** Power Mode Control @multiple */
#define SRSS_PWR_CONTROL_ADDR                        0x00000000
#define SRSS_PWR_CONTROL_MASK                        0xbb80003f
/** Current power mode of the device. Note that this field cannot be read in all
   power modes on actual silicon. @multiple */
  #define SRSS_PWR_CONTROL_POWER_MODE(v)           ((SRSS_PWR_CONTROL_POWER_MODE_##v) << 0)
  #define SRSS_PWR_CONTROL_POWER_MODE_SET(x, v)    do { (x) = (((x) & ~0xf) | ((SRSS_PWR_CONTROL_POWER_MODE_##v) << 0)); } while(0)
  #define SRSS_PWR_CONTROL_POWER_MODE_SETVAL(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SRSS_PWR_CONTROL_POWER_MODE_GET(x)       (((x) >> 0) & 0xf)
/** RESET state */
    #define SRSS_PWR_CONTROL_POWER_MODE_RESET        0x00000000
/** ACTIVE state */
    #define SRSS_PWR_CONTROL_POWER_MODE_ACTIVE       0x00000001
/** SLEEP state */
    #define SRSS_PWR_CONTROL_POWER_MODE_SLEEP        0x00000002
/** DEEP_SLEEP state */
    #define SRSS_PWR_CONTROL_POWER_MODE_DEEP_SLEEP   0x00000003
/** HIBERNATE state */
    #define SRSS_PWR_CONTROL_POWER_MODE_HIBERNATE    0x00000004
/** Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)
   @multiple */
  #define SRSS_PWR_CONTROL_DEBUG_SESSION           0x00000010
/** Indicates whether the low power mode regulators are ready to enter DEEPSLEEP
   or HIBERNATE mode. When 1, DEEPSLEEP and HIBERNATE work as described, else,
   device will wait before sleep. @multiple */
  #define SRSS_PWR_CONTROL_LPM_READY               0x00000020
/** Should be set by firmware if Vccd is provided externally (on Vccd pin).
   Setting this bit turns off the active regulator and will lead to system reset
   (PBOD) unless both Vddd and Vccd pins are supplied externally. @multiple */
  #define SRSS_PWR_CONTROL_EXT_VCCD                0x00800000
/** HV State Monitoring is automatically enable by sleep controller @multiple */
  #define SRSS_PWR_CONTROL_HVMON_ENABLE            0x01000000
/** Firmware writes 1 to reload HV State in hibernate shadow copy. Hardware
   clears this bit after reload was successful. Wait at least 9 cycles after
   writing/recalling NVL before reloading the HVMON. @multiple */
  #define SRSS_PWR_CONTROL_HVMON_RELOAD            0x02000000
/** This bit is asserted during the boot process. If low, forces IMO to operate
   at 12MHz, ignore its frequency and trim settings and operate independent on
   its external references. @multiple */
  #define SRSS_PWR_CONTROL_IMO_NORMAL              0x08000000
/** HIBERNATE bit is ignored, Hibernate mode is permanently disabled (part will
   go to DeepSleep instead. Note: This bit is a write-once bit until the next
   reset. @multiple */
  #define SRSS_PWR_CONTROL_HIBERNATE_DISABLE       0x10000000
/** Short Vcclfclk and Vccdpslp power rails in DeepSleep power mode. This mode
   selection affects the accuracy specifications of the ILO oscillator due to
   supply noise. See Datasheet for more details. @multiple */
  #define SRSS_PWR_CONTROL_LFCLK_SHORT             0x20000000
/** Selects between HIBERNATE(1)/DEEPSLEEP(0) modes when Cortex-M0 enters low
   power mode (SleepDeep). Note: this bit is ignored when HIBERNATE_DISABLE=1.
   @multiple */
  #define SRSS_PWR_CONTROL_HIBERNATE               0x80000000

#define SRSS_PWR_INTR_ADDR                           0x00000004
#define SRSS_PWR_INTR_MASK                           0x00000002
/** Indicates an Low Voltage Detect interrupt Write 1 to clear. @multiple */
  #define SRSS_PWR_INTR_LVD                        0x00000002

#define SRSS_PWR_INTR_MASK_ADDR                      0x00000008
#define SRSS_PWR_INTR_MASK_MASK                      0x00000002
/** Enable Low Voltage Detect interrupt @multiple */
  #define SRSS_PWR_INTR_MASK_LVD                   0x00000002

#define SRSS_PWR_KEY_DELAY_ADDR                      0x0000000c
#define SRSS_PWR_KEY_DELAY_MASK                      0x000003ff
/** Delay (in 12MHz IMO clock cycles) to wait for references to settle on wakeup
   from hibernate/deepsleep. PBOD is ignored and system does not resume until
   this delay expires. Note that the same delay on POR is hard-coded. @multiple
   */
  #define SRSS_PWR_KEY_DELAY_WAKEUP_HOLDOFF(v)     ((v) << 0)
  #define SRSS_PWR_KEY_DELAY_WAKEUP_HOLDOFF_SET(x, v) do { (x) = (((x) & ~0x3ff) | ((v) << 0)); } while(0)
  #define SRSS_PWR_KEY_DELAY_WAKEUP_HOLDOFF_GET(x) (((x) >> 0) & 0x3ff)

/** Bandgap Trim and Configuration @multiple */
#define SRSS_PWR_BG_CONFIG_ADDR                      0x00000014
#define SRSS_PWR_BG_CONFIG_MASK                      0x000701ff
/** Enables DFT capability for Bandgap (engineering only) @multiple */
  #define SRSS_PWR_BG_CONFIG_BG_DFT_EN             0x00000001
/** ADFT mux select for Reference System characterization (engineering only).
   Select a voltage reference to output on adft_bg_ref @multiple */
  #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL(v)    ((SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_##v) << 1)
  #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_SET(x, v) do { (x) = (((x) & ~0x1e) | ((SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_##v) << 1)); } while(0)
  #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x1e) | ((v) << 1)); } while(0)
  #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_GET(x) (((x) >> 1) & 0xf)
/** vgnd */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VGND  0x00000000
/** vref_fast[0] */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST0 0x00000001
/** vref_fast[1] */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST1 0x00000002
/** vref_fast[2] */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST2 0x00000003
/** vref_fast[3] */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST3 0x00000004
/** vref_fast[4] */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST4 0x00000005
/** vref_fast[5] */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST5 0x00000006
/** vref_fast[6] */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST6 0x00000007
/** vref_fast[7] */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF_FAST7 0x00000008
/** vref[0] */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF0 0x00000009
/** vref[1] */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF1 0x0000000a
/** vref[2] */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VREF2 0x0000000b
/** vctat */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_VCTAT 0x0000000c
/** see BG_DFT_ICORE_SEL */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_IREF_DFT 0x0000000d
/** current */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_IMO_IREF 0x0000000e
/** voltage */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_VREF_SEL_INL_IMOREF 0x0000000f
/** ADFT mux select for Bandgap characterization (engineering only). Selects
   which BG core signal to output on adft_bg_core @multiple */
  #define SRSS_PWR_BG_CONFIG_BG_DFT_CORE_SEL(v)    ((SRSS_PWR_BG_CONFIG_BG_DFT_CORE_SEL_##v) << 5)
  #define SRSS_PWR_BG_CONFIG_BG_DFT_CORE_SEL_SET(x, v) do { (x) = (((x) & ~0x20) | ((SRSS_PWR_BG_CONFIG_BG_DFT_CORE_SEL_##v) << 5)); } while(0)
  #define SRSS_PWR_BG_CONFIG_BG_DFT_CORE_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define SRSS_PWR_BG_CONFIG_BG_DFT_CORE_SEL_GET(x) (((x) >> 5) & 0x1)
/** mux2out */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_CORE_SEL_VCORE 0x00000000
/** mux1out */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_CORE_SEL_ICORE 0x00000001
/** ADFT mux select for Bandgap characterization (engineering only). Selects a BG
   core current to output on mux1out @multiple */
  #define SRSS_PWR_BG_CONFIG_BG_DFT_ICORE_SEL(v)   ((SRSS_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_##v) << 6)
  #define SRSS_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_SET(x, v) do { (x) = (((x) & ~0xc0) | ((SRSS_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_##v) << 6)); } while(0)
  #define SRSS_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_SETVAL(x, v) do { (x) = (((x) & ~0xc0) | ((v) << 6)); } while(0)
  #define SRSS_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_GET(x) (((x) >> 6) & 0x3)
/** current */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_IPTAT 0x00000000
/** current */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_ICTAT 0x00000001
/** voltage */
    #define SRSS_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_INL_CROSS_OVER_DETECT 0x00000002
    #define SRSS_PWR_BG_CONFIG_BG_DFT_ICORE_SEL_IREF9P6U_DFT_DEDICATED_OUTPUT_FOR_DFT_ 0x00000003
/** ADFT mux select for Bandgap characterization (engineering only). Selects a BG
   core voltage to output on mux2out 0: VOUT 1: VGND @multiple */
  #define SRSS_PWR_BG_CONFIG_BG_DFT_VCORE_SEL      0x00000100
/** Enables SRSS.VREF[x] to 1.024V (1.2V for no 2) These references require 40us
   to settle after enabling them and 30us to settle after wakng from DeepSleep.
   @multiple */
  #define SRSS_PWR_BG_CONFIG_VREF_EN_COUNT         3
  #define SRSS_PWR_BG_CONFIG_VREF_EN(fidx)         (0x00010000 << ((fidx)))

/** Voltage Monitoring Trim and Configuration @multiple */
#define SRSS_PWR_VMON_CONFIG_ADDR                    0x00000018
#define SRSS_PWR_VMON_CONFIG_MASK                    0x000003ff
/** Enable Low Voltage Detect circuit. @multiple */
  #define SRSS_PWR_VMON_CONFIG_LVD_EN              0x00000001
/** Threshold selection for Low Voltage Detect circuit. Disable the LVD
   (LVD_EN=0) before chang- ing the threshold. Threshold variation is +/- 2.5%
   from these typical voltage choices: @multiple */
  #define SRSS_PWR_VMON_CONFIG_LVD_SEL(v)          ((SRSS_PWR_VMON_CONFIG_LVD_SEL_##v) << 1)
  #define SRSS_PWR_VMON_CONFIG_LVD_SEL_SET(x, v)   do { (x) = (((x) & ~0x1e) | ((SRSS_PWR_VMON_CONFIG_LVD_SEL_##v) << 1)); } while(0)
  #define SRSS_PWR_VMON_CONFIG_LVD_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x1e) | ((v) << 1)); } while(0)
  #define SRSS_PWR_VMON_CONFIG_LVD_SEL_GET(x)      (((x) >> 1) & 0xf)
/** 1.75 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_1_75V       0x00000000
/** 1.8 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_1_8V        0x00000001
/** 1.9 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_1_9V        0x00000002
/** 2.7 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_2_7V        0x00000002
/** 2.0 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_2_0V        0x00000003
/** 2.8 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_2_8V        0x00000003
/** 2.1 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_2_1V        0x00000004
/** 2.2 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_2_2V        0x00000005
/** 2.3 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_2_3V        0x00000006
/** 2.4 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_2_4V        0x00000007
/** 2.5 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_2_5V        0x00000008
/** 2.6 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_2_6V        0x00000009
/** 2.9 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_2_9V        0x0000000c
/** 3.0 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_3_0V        0x0000000d
/** 3.2 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_3_2V        0x0000000e
/** 4.5 V */
    #define SRSS_PWR_VMON_CONFIG_LVD_SEL_4_5V        0x0000000f
/** DDFT mux select for HVPOR, PBOD, and LVD circuits (engineering only). Selects
   a signal to output on adft_vmon @multiple */
  #define SRSS_PWR_VMON_CONFIG_VMON_DDFT_SEL(v)    ((SRSS_PWR_VMON_CONFIG_VMON_DDFT_SEL_##v) << 5)
  #define SRSS_PWR_VMON_CONFIG_VMON_DDFT_SEL_SET(x, v) do { (x) = (((x) & ~0xe0) | ((SRSS_PWR_VMON_CONFIG_VMON_DDFT_SEL_##v) << 5)); } while(0)
  #define SRSS_PWR_VMON_CONFIG_VMON_DDFT_SEL_SETVAL(x, v) do { (x) = (((x) & ~0xe0) | ((v) << 5)); } while(0)
  #define SRSS_PWR_VMON_CONFIG_VMON_DDFT_SEL_GET(x) (((x) >> 5) & 0x7)
/** 0 */
    #define SRSS_PWR_VMON_CONFIG_VMON_DDFT_SEL_0     0x00000000
/** pbod_out */
    #define SRSS_PWR_VMON_CONFIG_VMON_DDFT_SEL_PBOD_OUT 0x00000001
/** Pulse Strecher output of pbod Monitor */
    #define SRSS_PWR_VMON_CONFIG_VMON_DDFT_SEL_PBOD_PS 0x00000002
/** hvpbod_out */
    #define SRSS_PWR_VMON_CONFIG_VMON_DDFT_SEL_HVPBOD_OUT 0x00000003
/** Pulse Strecher output of hvpbod Monitor */
    #define SRSS_PWR_VMON_CONFIG_VMON_DDFT_SEL_HVPBOD_PS 0x00000004
/** lvi_out */
    #define SRSS_PWR_VMON_CONFIG_VMON_DDFT_SEL_LVI_OUT 0x00000005
/** Pulse Strecher output of lvi Monitor */
    #define SRSS_PWR_VMON_CONFIG_VMON_DDFT_SEL_LVI_PS 0x00000006
/** ADFT mux select for HVPOR, PBOD, and LVD circuits (engineering only). Selects
   a signal to output on adft_vmon @multiple */
  #define SRSS_PWR_VMON_CONFIG_VMON_ADFT_SEL(v)    ((SRSS_PWR_VMON_CONFIG_VMON_ADFT_SEL_##v) << 8)
  #define SRSS_PWR_VMON_CONFIG_VMON_ADFT_SEL_SET(x, v) do { (x) = (((x) & ~0x300) | ((SRSS_PWR_VMON_CONFIG_VMON_ADFT_SEL_##v) << 8)); } while(0)
  #define SRSS_PWR_VMON_CONFIG_VMON_ADFT_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x300) | ((v) << 8)); } while(0)
  #define SRSS_PWR_VMON_CONFIG_VMON_ADFT_SEL_GET(x) (((x) >> 8) & 0x3)
/** Hi-Z */
    #define SRSS_PWR_VMON_CONFIG_VMON_ADFT_SEL_HI_Z  0x00000000
/** Comparator Input of pbod Monitor */
    #define SRSS_PWR_VMON_CONFIG_VMON_ADFT_SEL_PBOD  0x00000001
/** Comparator Input of hvpbod Monitor */
    #define SRSS_PWR_VMON_CONFIG_VMON_ADFT_SEL_HVPBOD 0x00000002
/** Comparator Input of lvi Monitor */
    #define SRSS_PWR_VMON_CONFIG_VMON_ADFT_SEL_LVI   0x00000003

/** Digital DFT Select @multiple */
#define SRSS_PWR_DDFT_SELECT_ADDR                    0x00000020
#define SRSS_PWR_DDFT_SELECT_MASK                    0x000000ff
/** Signal select for ddft1 output: @multiple */
  #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL(v)        ((SRSS_PWR_DDFT_SELECT_DDFT1_SEL_##v) << 0)
  #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_SET(x, v) do { (x) = (((x) & ~0xf) | ((SRSS_PWR_DDFT_SELECT_DDFT1_SEL_##v) << 0)); } while(0)
  #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_SETVAL(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_GET(x)    (((x) >> 0) & 0xf)
/** wakeup_a */
    #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_WAKEUP_A  0x00000000
/** ipor_reset */
    #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_IPOR_RESET 0x00000001
/** hbod_reset_raw_n */
    #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_HBOD_RESET_RAW_N 0x00000002
/** io_disable_req_lv (excluding por_force_in_hv) */
    #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_IO_DISABLE_REQ_LV 0x00000002
/** lpcomp_dis */
    #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_LPCOMP_DIS 0x00000003
/** bootref_en */
    #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_BOOTREF_EN 0x00000003
/** power_up_delayed */
    #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_POWER_UP_DELAYED 0x00000004
/** awake */
    #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_AWAKE     0x00000005
/** hvmon_out_of_sync */
    #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_HVMON_OUT_OF_SYNC 0x00000006
/** pbod_reset */
    #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_PBOD_RESET 0x00000007
/** hvbod_reset */
    #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_HVBOD_RESET 0x00000008
/** lpm_ready */
    #define SRSS_PWR_DDFT_SELECT_DDFT1_SEL_LPM_READY 0x00000009
/** Signal select for ddft2 output: @multiple */
  #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL(v)        ((SRSS_PWR_DDFT_SELECT_DDFT2_SEL_##v) << 4)
  #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_SET(x, v) do { (x) = (((x) & ~0xf0) | ((SRSS_PWR_DDFT_SELECT_DDFT2_SEL_##v) << 4)); } while(0)
  #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_SETVAL(x, v) do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_GET(x)    (((x) >> 4) & 0xf)
/** act_power_en_a */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_ACT_POWER_EN_A 0x00000000
/** power_up_raw */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_POWER_UP_RAW 0x00000001
/** act_power_good_a */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_ACT_POWER_GOOD_A 0x00000002
/** lpcomp_dis */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_LPCOMP_DIS 0x00000002
/** fastrefs_valid */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_FASTREFS_VALID 0x00000003
/** wakeup_a */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_WAKEUP_A  0x00000003
/** vmon */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_VMON      0x00000004
/** bootref_outen */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_BOOTREF_OUTEN 0x00000005
/** bootref_refsw */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_BOOTREF_REFSW 0x00000006
/** active_inrush_dis */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_ACTIVE_INRUSH_DIS 0x00000007
/** awake */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_AWAKE     0x00000008
/** hvpor_reset_n */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_HVPOR_RESET_N 0x00000009
/** vmon_valid */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_VMON_VALID 0x0000000c
/** block_rst_awake */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_BLOCK_RST_AWAKE 0x0000000d
/** slpholdreq_n */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_SLPHOLDREQ_N 0x0000000e
/** io_disable_delayed */
    #define SRSS_PWR_DDFT_SELECT_DDFT2_SEL_IO_DISABLE_DELAYED 0x0000000f

/** DFT Safety Override @multiple */
#define SRSS_PWR_DFT_KEY_ADDR                        0x00000024
#define SRSS_PWR_DFT_KEY_MASK                        0x001fffff
/** This field must be set to 0xE4C5 for any of the other fields in this register
   to have effect and for scan_mode to be allowed. When this fields has any other
   value, all other fields in this register are ignored and assumed to be 0 by
   the hardware, and scan_mode is ignored inside the power generation system. It
   is assumed that this register will always be set to 0xE4C5 before entering
   scan. @multiple */
  #define SRSS_PWR_DFT_KEY_KEY16(v)                ((v) << 0)
  #define SRSS_PWR_DFT_KEY_KEY16_SET(x, v)         do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SRSS_PWR_DFT_KEY_KEY16_GET(x)            (((x) >> 0) & 0xffff)
/** Forces the output of the HBOD to be blocked (ignored) while in Active or
   Sleep mode (i.e. when under the umbrella of PBOD). @multiple */
  #define SRSS_PWR_DFT_KEY_HBOD_OFF_AWAKE          0x00010000
/** Forces all outputs of BOD detectors to be ignored, effectively disabling all
   brown-out detection. Can be used in conjunction with DDFT to test the
   detectors without triggering reset. @multiple */
  #define SRSS_PWR_DFT_KEY_BODS_OFF                0x00020000
/** Enable DfT modes other than the above. Currently gates power_up comparator
   for characterization. @multiple */
  #define SRSS_PWR_DFT_KEY_DFT_MODE                0x00040000
/** Bypasses the IO disable logic for testing the delay-line that is part of the
   glitch-free IO reset cir- cuitry. Internally, prevents the outputs from
   getting disabled (io_disable_req_hv=0) and blocks resets
   (io_disable_ack_hv=0). The delay-line continues to function and can be routed
   to DDFT for testing. @multiple */
  #define SRSS_PWR_DFT_KEY_IO_DISABLE_BYPASS       0x00080000
/** Disables the VMON block, which includes PBOD, HVBOD, and LVD circuits. Set
   BODS_OFF=1 in a previous write cycle to prevent an unintended reset. @multiple
   */
  #define SRSS_PWR_DFT_KEY_VMON_PD                 0x00100000

/** BOD Detection Key @multiple */
#define SRSS_PWR_BOD_KEY_ADDR                        0x00000028
#define SRSS_PWR_BOD_KEY_MASK                        0x0000ffff
/** To detect brown-outs firmware should do this on boot: Read value, set value
   to 0x3A71, if read value was, 0x3A71 this was a brown-out event. @multiple */
  #define SRSS_PWR_BOD_KEY_KEY16(v)                ((SRSS_PWR_BOD_KEY_KEY16_##v) << 0)
  #define SRSS_PWR_BOD_KEY_KEY16_SET(x, v)         do { (x) = (((x) & ~0xffff) | ((SRSS_PWR_BOD_KEY_KEY16_##v) << 0)); } while(0)
  #define SRSS_PWR_BOD_KEY_KEY16_SETVAL(x, v)      do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SRSS_PWR_BOD_KEY_KEY16_GET(x)            (((x) >> 0) & 0xffff)
/** Browout check value to write/read */
    #define SRSS_PWR_BOD_KEY_KEY16_BROWNOUT          0x00003a71

#define SRSS_PWR_STOP_ADDR                           0x0000002c
#define SRSS_PWR_STOP_MASK                           0x8003ffff
/** Contains a 8-bit token that is retained through a STOP/WAKEUP sequence that
   can be used by firmware to differentiate WAKEUP from a general RESET event.
   Note that waking up from STOP using XRES will reset this register. @multiple
   */
  #define SRSS_PWR_STOP_TOKEN(v)                   ((v) << 0)
  #define SRSS_PWR_STOP_TOKEN_SET(x, v)            do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define SRSS_PWR_STOP_TOKEN_GET(x)               (((x) >> 0) & 0xff)
/** This byte must be set to 0x3A for FREEZE or STOP fields to operate. Any other
   value in this register will cause FREEZE/STOP to have no effect, except as
   noted in the FREEZE description. @multiple */
  #define SRSS_PWR_STOP_UNLOCK(v)                  ((SRSS_PWR_STOP_UNLOCK_##v) << 8)
  #define SRSS_PWR_STOP_UNLOCK_SET(x, v)           do { (x) = (((x) & ~0xff00) | ((SRSS_PWR_STOP_UNLOCK_##v) << 8)); } while(0)
  #define SRSS_PWR_STOP_UNLOCK_SETVAL(x, v)        do { (x) = (((x) & ~0xff00) | ((v) << 8)); } while(0)
  #define SRSS_PWR_STOP_UNLOCK_GET(x)              (((x) >> 8) & 0xff)
/** Unlock key */
    #define SRSS_PWR_STOP_UNLOCK_KEY                 0x0000003a
/** WAKEUP value that will wakeup the part from STOP @multiple */
  #define SRSS_PWR_STOP_POLARITY                   0x00010000
/** Firmware sets this bit to freeze the configuration, mode and state of all
   GPIOs and SIOs in the system. Two identical write cycles are required to
   freeze the IO explicitly. The first cycle in- structs DEEPSLEEP and HIBERNATE
   peripherals whether they can override upcoming freeze command(s). UNLOCK
   setting does not affect this. If firmware writes FREEZE=1 and STOP=0,
   peripherals can override the freeze and remain functional according to their
   configuration. If firm- ware writes FREEZE=1 and STOP=1, peripherals cannot
   override the next freeze command. The second write cycle freezes the IO if
   UNLOCK is set and the peripheral does not override the freeze. While FREEZE=1,
   peripherals will automatically freeze according to the override direc- tive
   when entering DEEPSLEEP or HIBERNATE, regardless of the UNLOCK setting.
   @multiple */
  #define SRSS_PWR_STOP_FREEZE                     0x00020000
/** Firmware sets this bit to enter STOP mode. Both UNLOCK and FREEZE must have
   been set correctly in a previous write operation. Otherwise, writes to this
   bit will affect the freeze override but will not actually set the STOP bit.
   The system will enter STOP mode immediately after writing to this bit and will
   wakeup only in response to XRES or WAKEUP event. @multiple */
  #define SRSS_PWR_STOP_STOP                       0x80000000

#define SRSS_CLK_SELECT_ADDR                         0x00000100
#define SRSS_CLK_SELECT_MASK                         0x003fffff
/** Selects a source for HFCLK (when HFCLK_SEL=0) and DSI_IN[0]. @multiple */
  #define SRSS_CLK_SELECT_DIRECT_SEL(v)            ((SRSS_CLK_SELECT_DIRECT_SEL_##v) << 0)
  #define SRSS_CLK_SELECT_DIRECT_SEL_SET(x, v)     do { (x) = (((x) & ~0x7) | ((SRSS_CLK_SELECT_DIRECT_SEL_##v) << 0)); } while(0)
  #define SRSS_CLK_SELECT_DIRECT_SEL_SETVAL(x, v)  do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define SRSS_CLK_SELECT_DIRECT_SEL_GET(x)        (((x) >> 0) & 0x7)
/** Internal R/C Oscillator */
    #define SRSS_CLK_SELECT_DIRECT_SEL_IMO           0x00000000
/** External Clock Pin */
    #define SRSS_CLK_SELECT_DIRECT_SEL_EXTCLK        0x00000001
/** External Crystal */
    #define SRSS_CLK_SELECT_DIRECT_SEL_ECO           0x00000002
/** DSI_OUT[0] */
    #define SRSS_CLK_SELECT_DIRECT_SEL_DSI0          0x00000004
/** DSI_OUT[1] */
    #define SRSS_CLK_SELECT_DIRECT_SEL_DSI1          0x00000005
/** DSI_OUT[2] */
    #define SRSS_CLK_SELECT_DIRECT_SEL_DSI2          0x00000006
/** DSI_OUT[3] */
    #define SRSS_CLK_SELECT_DIRECT_SEL_DSI3          0x00000007
/** Selects a source the input of EXCO PLL1, if supported. @multiple */
  #define SRSS_CLK_SELECT_DBL_SEL(v)               ((SRSS_CLK_SELECT_DBL_SEL_##v) << 3)
  #define SRSS_CLK_SELECT_DBL_SEL_SET(x, v)        do { (x) = (((x) & ~0x38) | ((SRSS_CLK_SELECT_DBL_SEL_##v) << 3)); } while(0)
  #define SRSS_CLK_SELECT_DBL_SEL_SETVAL(x, v)     do { (x) = (((x) & ~0x38) | ((v) << 3)); } while(0)
  #define SRSS_CLK_SELECT_DBL_SEL_GET(x)           (((x) >> 3) & 0x7)
/** Internal R/C Oscillator */
    #define SRSS_CLK_SELECT_DBL_SEL_IMO              0x00000000
/** External Clock Pin */
    #define SRSS_CLK_SELECT_DBL_SEL_EXTCLK           0x00000001
/** External Crystal */
    #define SRSS_CLK_SELECT_DBL_SEL_ECO              0x00000002
/** DSI_OUT[0] */
    #define SRSS_CLK_SELECT_DBL_SEL_DSI0             0x00000004
/** DSI_OUT[1] */
    #define SRSS_CLK_SELECT_DBL_SEL_DSI1             0x00000005
/** DSI_OUT[2] */
    #define SRSS_CLK_SELECT_DBL_SEL_DSI2             0x00000006
/** DSI_OUT[3] */
    #define SRSS_CLK_SELECT_DBL_SEL_DSI3             0x00000007
/** Selects a source the input of EXCO PLL0, if supported. @multiple */
  #define SRSS_CLK_SELECT_PLL_SEL(v)               ((SRSS_CLK_SELECT_PLL_SEL_##v) << 6)
  #define SRSS_CLK_SELECT_PLL_SEL_SET(x, v)        do { (x) = (((x) & ~0x1c0) | ((SRSS_CLK_SELECT_PLL_SEL_##v) << 6)); } while(0)
  #define SRSS_CLK_SELECT_PLL_SEL_SETVAL(x, v)     do { (x) = (((x) & ~0x1c0) | ((v) << 6)); } while(0)
  #define SRSS_CLK_SELECT_PLL_SEL_GET(x)           (((x) >> 6) & 0x7)
/** Internal R/C Oscillator */
    #define SRSS_CLK_SELECT_PLL_SEL_IMO              0x00000000
/** External Clock Pin */
    #define SRSS_CLK_SELECT_PLL_SEL_EXTCLK           0x00000001
/** External Crystal */
    #define SRSS_CLK_SELECT_PLL_SEL_ECO              0x00000002
/** DPLL Output */
    #define SRSS_CLK_SELECT_PLL_SEL_DPLL             0x00000003
/** DSI_OUT[0] */
    #define SRSS_CLK_SELECT_PLL_SEL_DSI0             0x00000004
/** DSI_OUT[1] */
    #define SRSS_CLK_SELECT_PLL_SEL_DSI1             0x00000005
/** DSI_OUT[2] */
    #define SRSS_CLK_SELECT_PLL_SEL_DSI2             0x00000006
/** DSI_OUT[3] */
    #define SRSS_CLK_SELECT_PLL_SEL_DSI3             0x00000007
/** Selects a source for the input of DPLL. Note that not all products support
   all clock sources. Selecting a clock source that is not supported will result
   in undefined behavior. @multiple */
  #define SRSS_CLK_SELECT_DPLLIN_SEL(v)            ((SRSS_CLK_SELECT_DPLLIN_SEL_##v) << 9)
  #define SRSS_CLK_SELECT_DPLLIN_SEL_SET(x, v)     do { (x) = (((x) & ~0xe00) | ((SRSS_CLK_SELECT_DPLLIN_SEL_##v) << 9)); } while(0)
  #define SRSS_CLK_SELECT_DPLLIN_SEL_SETVAL(x, v)  do { (x) = (((x) & ~0xe00) | ((v) << 9)); } while(0)
  #define SRSS_CLK_SELECT_DPLLIN_SEL_GET(x)        (((x) >> 9) & 0x7)
/** Internal R/C Oscillator */
    #define SRSS_CLK_SELECT_DPLLIN_SEL_IMO           0x00000000
/** External Clock Pin */
    #define SRSS_CLK_SELECT_DPLLIN_SEL_EXTCLK        0x00000001
/** External Crystal */
    #define SRSS_CLK_SELECT_DPLLIN_SEL_ECO           0x00000002
/** DSI_OUT[0] */
    #define SRSS_CLK_SELECT_DPLLIN_SEL_DSI0          0x00000004
/** DSI_OUT[1] */
    #define SRSS_CLK_SELECT_DPLLIN_SEL_DSI1          0x00000005
/** DSI_OUT[2] */
    #define SRSS_CLK_SELECT_DPLLIN_SEL_DSI2          0x00000006
/** DSI_OUT[3] */
    #define SRSS_CLK_SELECT_DPLLIN_SEL_DSI3          0x00000007
/** Selects a source for the reference (tracking) input of DPLL: @multiple */
  #define SRSS_CLK_SELECT_DPLLREF_SEL(v)           ((SRSS_CLK_SELECT_DPLLREF_SEL_##v) << 12)
  #define SRSS_CLK_SELECT_DPLLREF_SEL_SET(x, v)    do { (x) = (((x) & ~0x3000) | ((SRSS_CLK_SELECT_DPLLREF_SEL_##v) << 12)); } while(0)
  #define SRSS_CLK_SELECT_DPLLREF_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x3000) | ((v) << 12)); } while(0)
  #define SRSS_CLK_SELECT_DPLLREF_SEL_GET(x)       (((x) >> 12) & 0x3)
/** DSI_OUT[0] */
    #define SRSS_CLK_SELECT_DPLLREF_SEL_DSI0         0x00000000
/** DSI_OUT[1] */
    #define SRSS_CLK_SELECT_DPLLREF_SEL_DSI1         0x00000001
/** DSI_OUT[2] */
    #define SRSS_CLK_SELECT_DPLLREF_SEL_DSI2         0x00000002
/** DSI_OUT[3] */
    #define SRSS_CLK_SELECT_DPLLREF_SEL_DSI3         0x00000003
/** Prohibits writing to WDT_* registers and CLK_ILO register when not equal 0.
   Requires at least two different writes to unlock. Note that this field is 2
   bits to force multiple writes only. It represents only a single write protect
   signal protecting all WATCHDOG registers at the same time. @multiple */
  #define SRSS_CLK_SELECT_WDT_LOCK(v)              ((SRSS_CLK_SELECT_WDT_LOCK_##v) << 14)
  #define SRSS_CLK_SELECT_WDT_LOCK_SET(x, v)       do { (x) = (((x) & ~0xc000) | ((SRSS_CLK_SELECT_WDT_LOCK_##v) << 14)); } while(0)
  #define SRSS_CLK_SELECT_WDT_LOCK_SETVAL(x, v)    do { (x) = (((x) & ~0xc000) | ((v) << 14)); } while(0)
  #define SRSS_CLK_SELECT_WDT_LOCK_GET(x)          (((x) >> 14) & 0x3)
/** No effect */
    #define SRSS_CLK_SELECT_WDT_LOCK_NO_CHG          0x00000000
/** Clears bit 0 */
    #define SRSS_CLK_SELECT_WDT_LOCK_CLR0            0x00000001
/** Clears bit 1 */
    #define SRSS_CLK_SELECT_WDT_LOCK_CLR1            0x00000002
/** Sets both bits 0 and 1 */
    #define SRSS_CLK_SELECT_WDT_LOCK_SET01           0x00000003
/** Selects the source for HFCLK. @multiple */
  #define SRSS_CLK_SELECT_HFCLK_SEL(v)             ((SRSS_CLK_SELECT_HFCLK_SEL_##v) << 16)
  #define SRSS_CLK_SELECT_HFCLK_SEL_SET(x, v)      do { (x) = (((x) & ~0x30000) | ((SRSS_CLK_SELECT_HFCLK_SEL_##v) << 16)); } while(0)
  #define SRSS_CLK_SELECT_HFCLK_SEL_SETVAL(x, v)   do { (x) = (((x) & ~0x30000) | ((v) << 16)); } while(0)
  #define SRSS_CLK_SELECT_HFCLK_SEL_GET(x)         (((x) >> 16) & 0x3)
/** Source selected by DIRECT_SEL */
    #define SRSS_CLK_SELECT_HFCLK_SEL_DIRECT         0x00000000
/** Output of DBL */
    #define SRSS_CLK_SELECT_HFCLK_SEL_DBL            0x00000001
/** Output of PLL */
    #define SRSS_CLK_SELECT_HFCLK_SEL_PLL            0x00000002
/** FLASH Wait-state selection. This must be set to 1 when clk_sys is set to a
   frequency greater than 24MHz. When 1, access FLASH using 1 wait-state. CPUSSv1
   only. @multiple */
  #define SRSS_CLK_SELECT_HALF_EN                  0x00040000
/** SYSCLK Pre-Scaler Value. SYSCLK = HFCLK * 2 ^ -SYSCLK_DIV @multiple */
  #define SRSS_CLK_SELECT_SYSCLK_DIV(v)            ((v) << 19)
  #define SRSS_CLK_SELECT_SYSCLK_DIV_SET(x, v)     do { (x) = (((x) & ~0x380000) | ((v) << 19)); } while(0)
  #define SRSS_CLK_SELECT_SYSCLK_DIV_GET(x)        (((x) >> 19) & 0x7)

/** ILO Configuration @multiple */
#define SRSS_CLK_ILO_CONFIG_ADDR                     0x00000104
#define SRSS_CLK_ILO_CONFIG_MASK                     0x80000007
/** Power down mode. Note: this bit must always be set to 0 and never changed.
   Behavior is un- defined when set to 1. @multiple */
  #define SRSS_CLK_ILO_CONFIG_PD_MODE(v)           ((SRSS_CLK_ILO_CONFIG_PD_MODE_##v) << 0)
  #define SRSS_CLK_ILO_CONFIG_PD_MODE_SET(x, v)    do { (x) = (((x) & ~0x1) | ((SRSS_CLK_ILO_CONFIG_PD_MODE_##v) << 0)); } while(0)
  #define SRSS_CLK_ILO_CONFIG_PD_MODE_SETVAL(x, v) do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define SRSS_CLK_ILO_CONFIG_PD_MODE_GET(x)       (((x) >> 0) & 0x1)
/** Sleep (faster startup - enables pulsegen block) */
    #define SRSS_CLK_ILO_CONFIG_PD_MODE_SLEEP        0x00000000
/** Coma (slower startup) */
    #define SRSS_CLK_ILO_CONFIG_PD_MODE_COMA         0x00000001
/** Turbo mode for faster startup from coma power down. Leave this bit at the
   default setting for normal operation. Engineering only. @multiple */
  #define SRSS_CLK_ILO_CONFIG_TURBO_EN             0x00000002
/** PFET bias. Leave this bit at the default setting for normal operation.
   Engineering only. @multiple */
  #define SRSS_CLK_ILO_CONFIG_SATBIAS(v)           ((SRSS_CLK_ILO_CONFIG_SATBIAS_##v) << 2)
  #define SRSS_CLK_ILO_CONFIG_SATBIAS_SET(x, v)    do { (x) = (((x) & ~0x4) | ((SRSS_CLK_ILO_CONFIG_SATBIAS_##v) << 2)); } while(0)
  #define SRSS_CLK_ILO_CONFIG_SATBIAS_SETVAL(x, v) do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define SRSS_CLK_ILO_CONFIG_SATBIAS_GET(x)       (((x) >> 2) & 0x1)
/** Enable saturated PFET bias */
    #define SRSS_CLK_ILO_CONFIG_SATBIAS_SATURATED    0x00000000
/** Enable subthreshold PFET bias */
    #define SRSS_CLK_ILO_CONFIG_SATBIAS_SUBTHRESHOLD 0x00000001
/** Master enable for ILO oscillator @multiple */
  #define SRSS_CLK_ILO_CONFIG_ENABLE               0x80000000

/** IMO Configuration @multiple */
#define SRSS_CLK_IMO_CONFIG_ADDR                     0x00000108
#define SRSS_CLK_IMO_CONFIG_MASK                     0xffc00000
/** Selects operating source for SPCIF Timer/Flash Pump clock. @multiple */
  #define SRSS_CLK_IMO_CONFIG_FLASHPUMP_SEL(v)     ((SRSS_CLK_IMO_CONFIG_FLASHPUMP_SEL_##v) << 22)
  #define SRSS_CLK_IMO_CONFIG_FLASHPUMP_SEL_SET(x, v) do { (x) = (((x) & ~0x400000) | ((SRSS_CLK_IMO_CONFIG_FLASHPUMP_SEL_##v) << 22)); } while(0)
  #define SRSS_CLK_IMO_CONFIG_FLASHPUMP_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x400000) | ((v) << 22)); } while(0)
  #define SRSS_CLK_IMO_CONFIG_FLASHPUMP_SEL_GET(x) (((x) >> 22) & 0x1)
/** No clock, connect to gnd */
    #define SRSS_CLK_IMO_CONFIG_FLASHPUMP_SEL_GND    0x00000000
/** Use 36MHz oscillator */
    #define SRSS_CLK_IMO_CONFIG_FLASHPUMP_SEL_CLK36  0x00000001
/** Forces the FIMO's fast bias circuits to remain powered (engineering only).
   This bit must be cleared by BootROM after FIMO is no longer required.
   @multiple */
  #define SRSS_CLK_IMO_CONFIG_EN_FASTBIAS          0x00800000
/** Forces the IMO into FIMO mode (engineering only). Only works when
   EN_FASTBIAS=1. @multiple */
  #define SRSS_CLK_IMO_CONFIG_TEST_FASTBIAS        0x01000000
/** Selects operating source for Pump clock. This clock is not guaranteed to be
   glitch free when changing IMO parameters or clock divider settings. Note:
   always set EN_CLK36 when selecting CLK36 for PUMP_SEL. Flash program/erase
   operations will set EN_CLK36=0 when PUMP_SEL!=CLK36. @multiple */
  #define SRSS_CLK_IMO_CONFIG_PUMP_SEL(v)          ((SRSS_CLK_IMO_CONFIG_PUMP_SEL_##v) << 25)
  #define SRSS_CLK_IMO_CONFIG_PUMP_SEL_SET(x, v)   do { (x) = (((x) & ~0xe000000) | ((SRSS_CLK_IMO_CONFIG_PUMP_SEL_##v) << 25)); } while(0)
  #define SRSS_CLK_IMO_CONFIG_PUMP_SEL_SETVAL(x, v) do { (x) = (((x) & ~0xe000000) | ((v) << 25)); } while(0)
  #define SRSS_CLK_IMO_CONFIG_PUMP_SEL_GET(x)      (((x) >> 25) & 0x7)
/** No clock, connect to gnd */
    #define SRSS_CLK_IMO_CONFIG_PUMP_SEL_GND         0x00000000
/** Main IMO output */
    #define SRSS_CLK_IMO_CONFIG_PUMP_SEL_IMO         0x00000001
/** Doubler output */
    #define SRSS_CLK_IMO_CONFIG_PUMP_SEL_DBL         0x00000002
/** 36MHz oscillator */
    #define SRSS_CLK_IMO_CONFIG_PUMP_SEL_CLK36       0x00000003
/** Divided clock FF1 */
    #define SRSS_CLK_IMO_CONFIG_PUMP_SEL_FF1         0x00000004
/** Forces IMO into USB mode. Engineering only. When 1, software can write
   FSOFFSET, OFFSET, and GAIN settings for characterization. Hardware updates to
   these registers are not blocked, so disable USB peripheral updates if they are
   not desired. @multiple */
  #define SRSS_CLK_IMO_CONFIG_TEST_USB_MODE        0x10000000
/** Enable 36MHz secondary oscillator that can be used for Pump or Flash Pump.
   @multiple */
  #define SRSS_CLK_IMO_CONFIG_EN_CLK36             0x20000000
/** Enables main oscillator doubler circuit that can be used for TSS Charge
   Pumps. This circuit is not available to generate any digital clocks. @multiple
   */
  #define SRSS_CLK_IMO_CONFIG_EN_CLK2X             0x40000000
/** Master enable for IMO oscillator. Clearing this bit will disable the IMO but
   not disconnect it from the power rail. This bit can also be used during IDDQ
   testing. @multiple */
  #define SRSS_CLK_IMO_CONFIG_ENABLE               0x80000000

/** IMO Spread Spectrum Configuration @multiple */
#define SRSS_CLK_IMO_SPREAD_ADDR                     0x0000010c
#define SRSS_CLK_IMO_SPREAD_MASK                     0xf0001f1f
/** Current offset value for spread spectrum modulation. IMO supports values
   0..16. Step size is determined by SS_RANGE. Value is encoded in proper
   thermometric format for IMO in hard- ware. Value can be modified in firmware
   only when SS_MODE=0. @multiple */
  #define SRSS_CLK_IMO_SPREAD_SS_VALUE(v)          ((v) << 0)
  #define SRSS_CLK_IMO_SPREAD_SS_VALUE_SET(x, v)   do { (x) = (((x) & ~0x1f) | ((v) << 0)); } while(0)
  #define SRSS_CLK_IMO_SPREAD_SS_VALUE_GET(x)      (((x) >> 0) & 0x1f)
/** Maximum counter value for spread spectrum. Counter will count from
   0..SS_MAX..0 and keep repeating this indefinitely. Only works when SS_MODE=1.
   @multiple */
  #define SRSS_CLK_IMO_SPREAD_SS_MAX(v)            ((v) << 8)
  #define SRSS_CLK_IMO_SPREAD_SS_MAX_SET(x, v)     do { (x) = (((x) & ~0x1f00) | ((v) << 8)); } while(0)
  #define SRSS_CLK_IMO_SPREAD_SS_MAX_GET(x)        (((x) >> 8) & 0x1f)
/** Spread spectrum range (downspread when SS_VALUE=16). @multiple */
  #define SRSS_CLK_IMO_SPREAD_SS_RANGE(v)          ((SRSS_CLK_IMO_SPREAD_SS_RANGE_##v) << 28)
  #define SRSS_CLK_IMO_SPREAD_SS_RANGE_SET(x, v)   do { (x) = (((x) & ~0x30000000) | ((SRSS_CLK_IMO_SPREAD_SS_RANGE_##v) << 28)); } while(0)
  #define SRSS_CLK_IMO_SPREAD_SS_RANGE_SETVAL(x, v) do { (x) = (((x) & ~0x30000000) | ((v) << 28)); } while(0)
  #define SRSS_CLK_IMO_SPREAD_SS_RANGE_GET(x)      (((x) >> 28) & 0x3)
/** 0 .. -1% */
    #define SRSS_CLK_IMO_SPREAD_SS_RANGE_Z_1         0x00000000
/** 0 .. -3% */
    #define SRSS_CLK_IMO_SPREAD_SS_RANGE_Z_3         0x00000001
/** 0 .. -4% */
    #define SRSS_CLK_IMO_SPREAD_SS_RANGE_Z_4         0x00000002
/** Spread Spectrum Mode. @multiple */
  #define SRSS_CLK_IMO_SPREAD_SS_MODE(v)           ((SRSS_CLK_IMO_SPREAD_SS_MODE_##v) << 30)
  #define SRSS_CLK_IMO_SPREAD_SS_MODE_SET(x, v)    do { (x) = (((x) & ~0xc0000000) | ((SRSS_CLK_IMO_SPREAD_SS_MODE_##v) << 30)); } while(0)
  #define SRSS_CLK_IMO_SPREAD_SS_MODE_SETVAL(x, v) do { (x) = (((x) & ~0xc0000000) | ((v) << 30)); } while(0)
  #define SRSS_CLK_IMO_SPREAD_SS_MODE_GET(x)       (((x) >> 30) & 0x3)
/** Off, do not change SS_VALUE */
    #define SRSS_CLK_IMO_SPREAD_SS_MODE_OFF          0x00000000
/** Modulate using triangle wave (see SS_MAX) */
    #define SRSS_CLK_IMO_SPREAD_SS_MODE_TRIANGLE     0x00000001
/** Modulate using pseudo random sequence (using LFSR) */
    #define SRSS_CLK_IMO_SPREAD_SS_MODE_LFSR         0x00000002
/** Take value directly from DSI (synchronized by divided clock FF1) */
    #define SRSS_CLK_IMO_SPREAD_SS_MODE_DSI          0x00000003

#define SRSS_CLK_DFT_SELECT_ADDR                     0x00000110
#define SRSS_CLK_DFT_SELECT_MASK                     0x00003f3f
/** Select signal for DFT output #1. @multiple */
  #define SRSS_CLK_DFT_SELECT_DFT_SEL1(v)          ((SRSS_CLK_DFT_SELECT_DFT_SEL1_##v) << 0)
  #define SRSS_CLK_DFT_SELECT_DFT_SEL1_SET(x, v)   do { (x) = (((x) & ~0xf) | ((SRSS_CLK_DFT_SELECT_DFT_SEL1_##v) << 0)); } while(0)
  #define SRSS_CLK_DFT_SELECT_DFT_SEL1_SETVAL(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SRSS_CLK_DFT_SELECT_DFT_SEL1_GET(x)      (((x) >> 0) & 0xf)
/** Disabled - output is not connected */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_NC          0x00000000
/** ILO output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_ILO         0x00000001
/** WCO output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_WCO         0x00000002
/** IMO primary output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_IMO         0x00000003
/** ECO output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_ECO         0x00000004
/** PLL output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_PLL         0x00000005
/** DPLL output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_DPLL_OUT    0x00000006
/** DPLL reference input */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_DPLL_REF    0x00000007
/** DBL output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_DBL         0x00000008
/** IMO 2x Clock Output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_IMO2X       0x00000009
/** IMO 36MHz Clock Output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_IMO36       0x0000000a
/** HFCLK */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_HFCLK       0x0000000b
/** LFCLK */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_LFCLK       0x0000000c
/** SYSCLK */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_SYSCLK      0x0000000d
/** EXTCLK */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_EXTCLK      0x0000000e
/** 0 - removed */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL1_HALFSYSCLK  0x0000000f
/** DFT Output Divide Down. @multiple */
  #define SRSS_CLK_DFT_SELECT_DFT_DIV1(v)          ((SRSS_CLK_DFT_SELECT_DFT_DIV1_##v) << 4)
  #define SRSS_CLK_DFT_SELECT_DFT_DIV1_SET(x, v)   do { (x) = (((x) & ~0x30) | ((SRSS_CLK_DFT_SELECT_DFT_DIV1_##v) << 4)); } while(0)
  #define SRSS_CLK_DFT_SELECT_DFT_DIV1_SETVAL(x, v) do { (x) = (((x) & ~0x30) | ((v) << 4)); } while(0)
  #define SRSS_CLK_DFT_SELECT_DFT_DIV1_GET(x)      (((x) >> 4) & 0x3)
/** Direct Output */
    #define SRSS_CLK_DFT_SELECT_DFT_DIV1_NO_DIV      0x00000000
/** Divide by 2 */
    #define SRSS_CLK_DFT_SELECT_DFT_DIV1_DIV_BY_2    0x00000001
/** Divide by 4 */
    #define SRSS_CLK_DFT_SELECT_DFT_DIV1_DIV_BY_4    0x00000002
/** Divide by 8 */
    #define SRSS_CLK_DFT_SELECT_DFT_DIV1_DIV_BY_8    0x00000003
/** Select signal for DFT output #2. @multiple */
  #define SRSS_CLK_DFT_SELECT_DFT_SEL2(v)          ((SRSS_CLK_DFT_SELECT_DFT_SEL2_##v) << 8)
  #define SRSS_CLK_DFT_SELECT_DFT_SEL2_SET(x, v)   do { (x) = (((x) & ~0xf00) | ((SRSS_CLK_DFT_SELECT_DFT_SEL2_##v) << 8)); } while(0)
  #define SRSS_CLK_DFT_SELECT_DFT_SEL2_SETVAL(x, v) do { (x) = (((x) & ~0xf00) | ((v) << 8)); } while(0)
  #define SRSS_CLK_DFT_SELECT_DFT_SEL2_GET(x)      (((x) >> 8) & 0xf)
/** Disabled - output is not connected */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_NC          0x00000000
/** ILO output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_ILO         0x00000001
/** WCO output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_WCO         0x00000002
/** IMO primary output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_IMO         0x00000003
/** ECO output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_ECO         0x00000004
/** PLL output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_PLL         0x00000005
/** DPLL output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_DPLL_OUT    0x00000006
/** DPLL reference input */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_DPLL_REF    0x00000007
/** DBL output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_DBL         0x00000008
/** IMO 2x Clock Output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_IMO2X       0x00000009
/** IMO 36MHz Clock Output */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_IMO36       0x0000000a
/** HFCLK */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_HFCLK       0x0000000b
/** LFCLK */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_LFCLK       0x0000000c
/** SYSCLK */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_SYSCLK      0x0000000d
/** EXTCLK */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_EXTCLK      0x0000000e
/** 0 - removed */
    #define SRSS_CLK_DFT_SELECT_DFT_SEL2_HALFSYSCLK  0x0000000f
/** DFT Output Divide Down. Divisor is 2 ^ DFT_DIV2 @multiple */
  #define SRSS_CLK_DFT_SELECT_DFT_DIV2(v)          ((v) << 12)
  #define SRSS_CLK_DFT_SELECT_DFT_DIV2_SET(x, v)   do { (x) = (((x) & ~0x3000) | ((v) << 12)); } while(0)
  #define SRSS_CLK_DFT_SELECT_DFT_DIV2_GET(x)      (((x) >> 12) & 0x3)

/** Watchdog Counters 0/1 @multiple */
#define SRSS_WDT_CTRLOW_ADDR                         0x00000200
#define SRSS_WDT_CTRLOW_MASK                         0xffffffff
/** Current value of WDT Counter 0 @multiple */
  #define SRSS_WDT_CTRLOW_CTR0(v)                  ((v) << 0)
  #define SRSS_WDT_CTRLOW_CTR0_SET(x, v)           do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SRSS_WDT_CTRLOW_CTR0_GET(x)              (((x) >> 0) & 0xffff)
/** Current value of WDT Counter 1 @multiple */
  #define SRSS_WDT_CTRLOW_CTR1(v)                  ((v) << 16)
  #define SRSS_WDT_CTRLOW_CTR1_SET(x, v)           do { (x) = (((x) & ~0xffff0000) | ((v) << 16)); } while(0)
  #define SRSS_WDT_CTRLOW_CTR1_GET(x)              (((x) >> 16) & 0xffff)

/** Watchdog Counter 2 @multiple */
#define SRSS_WDT_CTRHIGH_ADDR                        0x00000204
#define SRSS_WDT_CTRHIGH_MASK                        0xffffffff
/** Current value of WDT Counter 2 @multiple */
  #define SRSS_WDT_CTRHIGH_CTR2(v)                 ((v) << 0)
  #define SRSS_WDT_CTRHIGH_CTR2_SET(x, v)          do { (x) = (((x) & ~0xffffffff) | ((v) << 0)); } while(0)
  #define SRSS_WDT_CTRHIGH_CTR2_GET(x)             (((x) >> 0) & 0xffffffff)

/** Watchdog counter match values @multiple */
#define SRSS_WDT_MATCH_ADDR                          0x00000208
#define SRSS_WDT_MATCH_MASK                          0xffffffff
/** Match value for Watchdog Counter 0 @multiple */
  #define SRSS_WDT_MATCH_COUNTER0(v)               ((v) << 0)
  #define SRSS_WDT_MATCH_COUNTER0_SET(x, v)        do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define SRSS_WDT_MATCH_COUNTER0_GET(x)           (((x) >> 0) & 0xffff)
/** Match value for Watchdog Counter 1 @multiple */
  #define SRSS_WDT_MATCH_COUNTER1(v)               ((v) << 16)
  #define SRSS_WDT_MATCH_COUNTER1_SET(x, v)        do { (x) = (((x) & ~0xffff0000) | ((v) << 16)); } while(0)
  #define SRSS_WDT_MATCH_COUNTER1_GET(x)           (((x) >> 16) & 0xffff)

/** Watchdog Counters Configuration @multiple */
#define SRSS_WDT_CONFIG_ADDR                         0x0000020c
#define SRSS_WDT_CONFIG_MASK                         0xdf010f0f
/** Watchdog Counter Action on Match (WDT_CTR0 = WDT_MATCH0). @multiple */
  #define SRSS_WDT_CONFIG_MODE0(v)                 ((SRSS_WDT_CONFIG_MODE0_##v) << 0)
  #define SRSS_WDT_CONFIG_MODE0_SET(x, v)          do { (x) = (((x) & ~0x3) | ((SRSS_WDT_CONFIG_MODE0_##v) << 0)); } while(0)
  #define SRSS_WDT_CONFIG_MODE0_SETVAL(x, v)       do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define SRSS_WDT_CONFIG_MODE0_GET(x)             (((x) >> 0) & 0x3)
/** Do nothing */
    #define SRSS_WDT_CONFIG_MODE0_NOTHING            0x00000000
/** Assert WDT_INTx */
    #define SRSS_WDT_CONFIG_MODE0_INT                0x00000001
/** Assert WDT Reset */
    #define SRSS_WDT_CONFIG_MODE0_RESET              0x00000002
/** Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt */
    #define SRSS_WDT_CONFIG_MODE0_INT_THEN_RESET     0x00000003
/** Clear Watchdog Counter when WDT_CTR0 = WDT_MATCH0. In other words WDT_CTR0
   divides LFCLK by (WDT_MATCH0 + 1). @multiple */
  #define SRSS_WDT_CONFIG_CLEAR0                   0x00000004
/** Cascade Watchdog Counters 0,1. Counter 1 increments the cycle after WDT_CTR0
   = WDT_MATCH0. @multiple */
  #define SRSS_WDT_CONFIG_CASCADE0_1               0x00000008
/** Watchdog Counter Action on Match (WDT_CTR1 = WDT_MATCH1). @multiple */
  #define SRSS_WDT_CONFIG_MODE1(v)                 ((SRSS_WDT_CONFIG_MODE1_##v) << 8)
  #define SRSS_WDT_CONFIG_MODE1_SET(x, v)          do { (x) = (((x) & ~0x300) | ((SRSS_WDT_CONFIG_MODE1_##v) << 8)); } while(0)
  #define SRSS_WDT_CONFIG_MODE1_SETVAL(x, v)       do { (x) = (((x) & ~0x300) | ((v) << 8)); } while(0)
  #define SRSS_WDT_CONFIG_MODE1_GET(x)             (((x) >> 8) & 0x3)
/** Do nothing */
    #define SRSS_WDT_CONFIG_MODE1_NOTHING            0x00000000
/** Assert WDT_INTx */
    #define SRSS_WDT_CONFIG_MODE1_INT                0x00000001
/** Assert WDT Reset */
    #define SRSS_WDT_CONFIG_MODE1_RESET              0x00000002
/** Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt */
    #define SRSS_WDT_CONFIG_MODE1_INT_THEN_RESET     0x00000003
/** Clear Watchdog Counter when WDT_CTR1 = WDT_MATCH1. In other words WDT_CTR1
   divides LFCLK by (WDT_MATCH1 + 1). @multiple */
  #define SRSS_WDT_CONFIG_CLEAR1                   0x00000400
/** Cascade Watchdog Counters 1,2. Counter 2 increments the cycle after
   WDT_CTR1=WDT_MATCH1. @multiple */
  #define SRSS_WDT_CONFIG_CASCADE1_2               0x00000800
/** Watchdog Counter Action on CTR2 selected bit flip @multiple */
  #define SRSS_WDT_CONFIG_MODE2(v)                 ((SRSS_WDT_CONFIG_MODE2_##v) << 16)
  #define SRSS_WDT_CONFIG_MODE2_SET(x, v)          do { (x) = (((x) & ~0x10000) | ((SRSS_WDT_CONFIG_MODE2_##v) << 16)); } while(0)
  #define SRSS_WDT_CONFIG_MODE2_SETVAL(x, v)       do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define SRSS_WDT_CONFIG_MODE2_GET(x)             (((x) >> 16) & 0x1)
/** Do nothing */
    #define SRSS_WDT_CONFIG_MODE2_NOTHING            0x00000000
/** Assert WDT_INTx */
    #define SRSS_WDT_CONFIG_MODE2_INT                0x00000001
/** Bit to observe for WDT_INT2, makes one interrupt every 2 ^ WDT_BITS2 tick.
   @multiple */
  #define SRSS_WDT_CONFIG_BITS2(v)                 ((v) << 24)
  #define SRSS_WDT_CONFIG_BITS2_SET(x, v)          do { (x) = (((x) & ~0x1f000000) | ((v) << 24)); } while(0)
  #define SRSS_WDT_CONFIG_BITS2_GET(x)             (((x) >> 24) & 0x1f)
/** Select source for LFCLK. @multiple */
  #define SRSS_WDT_CONFIG_LFCLK_SEL(v)             ((SRSS_WDT_CONFIG_LFCLK_SEL_##v) << 30)
  #define SRSS_WDT_CONFIG_LFCLK_SEL_SET(x, v)      do { (x) = (((x) & ~0xc0000000) | ((SRSS_WDT_CONFIG_LFCLK_SEL_##v) << 30)); } while(0)
  #define SRSS_WDT_CONFIG_LFCLK_SEL_SETVAL(x, v)   do { (x) = (((x) & ~0xc0000000) | ((v) << 30)); } while(0)
  #define SRSS_WDT_CONFIG_LFCLK_SEL_GET(x)         (((x) >> 30) & 0x3)
/** Internal R/C Oscillator */
    #define SRSS_WDT_CONFIG_LFCLK_SEL_ILO            0x00000000
/** Internal Crystal Oscillator */
    #define SRSS_WDT_CONFIG_LFCLK_SEL_WCO            0x00000001

/** Watchdog Counters Control @multiple */
#define SRSS_WDT_CONTROL_ADDR                        0x00000210
#define SRSS_WDT_CONTROL_MASK                        0x000f0f0f
/** Enable Counter Note: This field takes considerable time (up to 3 LFCLK
   cycles) to take effect. It must not be changed more than once in that period.
   @multiple */
  #define SRSS_WDT_CONTROL_ENABLE_COUNT            3
  #define SRSS_WDT_CONTROL_ENABLE(fidx)            (0x00000001 << ((fidx) * 8))
/** Indicates actual state of counter. May lag WDT_ENABLE by up to 3 LFCLK
   cycles. After changing WDT_ENABLE, do not enter DEEPSLEEP mode until this
   field acknowledges the change. @multiple */
  #define SRSS_WDT_CONTROL_ENABLED_COUNT           3
  #define SRSS_WDT_CONTROL_ENABLED(fidx)           (0x00000002 << ((fidx) * 8))
/** WDT Interrupt Request. This bit is set by hardware as configured by this
   registers. This bit must be cleared by firmware. Clearing this bit also
   prevents Reset from happening when WDT_MODE=3. After W1C, WDT_CONTROL must be
   read for the hardware to internally remove the clear flag. Failure to do this
   may result in missing the next interrupt. @multiple */
  #define SRSS_WDT_CONTROL_INT_COUNT               3
  #define SRSS_WDT_CONTROL_INT(fidx)               (0x00000004 << ((fidx) * 8))
/** Resets counter back to 0. Hardware will reset this bit after counter was
   reset. This will take several LFCLK cycles to take effect. Wait until the
   reset completes before enabling the WDT. @multiple */
  #define SRSS_WDT_CONTROL_RESET_COUNT             3
  #define SRSS_WDT_CONTROL_RESET(fidx)             (0x00000008 << ((fidx) * 8))

#define SRSS_RES_CAUSE_ADDR                          0x00000300
#define SRSS_RES_CAUSE_MASK                          0x000000ff
/** A WatchDog Timer reset has occurred since last power cycle. Write 1 to clear.
   @multiple */
  #define SRSS_RES_CAUSE_RESET_WDT                 0x00000001
/** This field is deprecated and will always read 0. Write 1 to clear. @multiple
   */
  #define SRSS_RES_CAUSE_RESET_DSBOD               0x00000002
/** This field is deprecated and will always read 0. Cortex-M0 LOCKUP is no
   longer a reset source. Write 1 to clear. @multiple */
  #define SRSS_RES_CAUSE_RESET_LOCKUP              0x00000004
/** A protection violation occurred that requires a RESET. This includes, but is
   not limited to, hitting a debug breakpoint while in Privileged Mode. Write 1
   to clear. @multiple */
  #define SRSS_RES_CAUSE_RESET_PROT_FAULT          0x00000008
/** Cortex-M0 requested a system reset through it's SYSRESETREQ. This can be done
   via a debugger probe or in firmware. Write 1 to clear. @multiple */
  #define SRSS_RES_CAUSE_RESET_SOFT                0x00000010
/** This field is deprecated and will always read 0. Write 1 to clear. @multiple
   */
  #define SRSS_RES_CAUSE_RESET_HVBOD               0x00000020
/** This field is deprecated and will always read 0. Write 1 to clear. @multiple
   */
  #define SRSS_RES_CAUSE_RESET_PBOD                0x00000040
/** This field is deprecated and will always read 0. Write 1 to clear. @multiple
   */
  #define SRSS_RES_CAUSE_RESET_XRES                0x00000080

#define SRSS_PWR_BG_TRIM3_ADDR                       0x0000ff18
#define SRSS_PWR_BG_TRIM3_MASK                       0x0000007f
/** IMO Irefgen nonlinear current trim for curvature correction. @multiple */
  #define SRSS_PWR_BG_TRIM3_INL_TRIM_IMO(v)        ((v) << 0)
  #define SRSS_PWR_BG_TRIM3_INL_TRIM_IMO_SET(x, v) do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define SRSS_PWR_BG_TRIM3_INL_TRIM_IMO_GET(x)    (((x) >> 0) & 0x7)
/** IMO Irefgen INL cross-over point control for centering curve at 30C.
   @multiple */
  #define SRSS_PWR_BG_TRIM3_INL_CROSS_IMO(v)       ((v) << 3)
  #define SRSS_PWR_BG_TRIM3_INL_CROSS_IMO_SET(x, v) do { (x) = (((x) & ~0x78) | ((v) << 3)); } while(0)
  #define SRSS_PWR_BG_TRIM3_INL_CROSS_IMO_GET(x)   (((x) >> 3) & 0xf)

#define SRSS_PWR_BG_TRIM4_ADDR                       0x0000ff1c
#define SRSS_PWR_BG_TRIM4_MASK                       0x0000003f
/** IMO-irefgen output current magnitude trim @multiple */
  #define SRSS_PWR_BG_TRIM4_ABS_TRIM_IMO(v)        ((v) << 0)
  #define SRSS_PWR_BG_TRIM4_ABS_TRIM_IMO_SET(x, v) do { (x) = (((x) & ~0x3f) | ((v) << 0)); } while(0)
  #define SRSS_PWR_BG_TRIM4_ABS_TRIM_IMO_GET(x)    (((x) >> 0) & 0x3f)

#define SRSS_PWR_BG_TRIM5_ADDR                       0x0000ff20
#define SRSS_PWR_BG_TRIM5_MASK                       0x0000003f
/** IMO-irefgen output current temperature co-efficient trim @multiple */
  #define SRSS_PWR_BG_TRIM5_TMPCO_TRIM_IMO(v)      ((v) << 0)
  #define SRSS_PWR_BG_TRIM5_TMPCO_TRIM_IMO_SET(x, v) do { (x) = (((x) & ~0x3f) | ((v) << 0)); } while(0)
  #define SRSS_PWR_BG_TRIM5_TMPCO_TRIM_IMO_GET(x)  (((x) >> 0) & 0x3f)

#define SRSS_CLK_ILO_TRIM_ADDR                       0x0000ff24
#define SRSS_CLK_ILO_TRIM_MASK                       0x000000ff
/** Trim bits to control frequency @multiple */
  #define SRSS_CLK_ILO_TRIM_TRIM(v)                ((v) << 0)
  #define SRSS_CLK_ILO_TRIM_TRIM_SET(x, v)         do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SRSS_CLK_ILO_TRIM_TRIM_GET(x)            (((x) >> 0) & 0xf)
/** Adjusts the bias in the event of high current after fab. Leave these bits at
   the default setting for normal operation. @multiple */
  #define SRSS_CLK_ILO_TRIM_COARSE_TRIM(v)         ((v) << 4)
  #define SRSS_CLK_ILO_TRIM_COARSE_TRIM_SET(x, v)  do { (x) = (((x) & ~0x70) | ((v) << 4)); } while(0)
  #define SRSS_CLK_ILO_TRIM_COARSE_TRIM_GET(x)     (((x) >> 4) & 0x7)
  #define SRSS_CLK_ILO_TRIM_COARSE_TRIM_MODE(v)    ((SRSS_CLK_ILO_TRIM_COARSE_TRIM_MODE_##v) << 7)
  #define SRSS_CLK_ILO_TRIM_COARSE_TRIM_MODE_SET(x, v) do { (x) = (((x) & ~0x80) | ((SRSS_CLK_ILO_TRIM_COARSE_TRIM_MODE_##v) << 7)); } while(0)
  #define SRSS_CLK_ILO_TRIM_COARSE_TRIM_MODE_SETVAL(x, v) do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
  #define SRSS_CLK_ILO_TRIM_COARSE_TRIM_MODE_GET(x) (((x) >> 7) & 0x1)
/** Normal Mode */
    #define SRSS_CLK_ILO_TRIM_COARSE_TRIM_MODE_NORMAL 0x00000000
/** Low Current Mode */
    #define SRSS_CLK_ILO_TRIM_COARSE_TRIM_MODE_LOW_CURRENT 0x00000001

#define SRSS_CLK_IMO_TRIM1_ADDR                      0x0000ff28
#define SRSS_CLK_IMO_TRIM1_MASK                      0x000000ff
/** Frequency trim bits. These bits are determined at manufacturing time for each
   FREQ setting (IMO_TRIM2) and stored in SFLASH. This field is hardware updated
   during USB osclock mode. @multiple */
  #define SRSS_CLK_IMO_TRIM1_OFFSET(v)             ((v) << 0)
  #define SRSS_CLK_IMO_TRIM1_OFFSET_SET(x, v)      do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define SRSS_CLK_IMO_TRIM1_OFFSET_GET(x)         (((x) >> 0) & 0xff)

#define SRSS_CLK_IMO_TRIM2_ADDR                      0x0000ff2c
#define SRSS_CLK_IMO_TRIM2_MASK                      0x0000003f
/** Frequency in range 3-48 MHz. Value = (Frequency + GAP), with GAP increments
   at 12, 24, 33, 40 and 40 MHz (twice). @multiple */
  #define SRSS_CLK_IMO_TRIM2_FREQ(v)               ((v) << 0)
  #define SRSS_CLK_IMO_TRIM2_FREQ_SET(x, v)        do { (x) = (((x) & ~0x3f) | ((v) << 0)); } while(0)
  #define SRSS_CLK_IMO_TRIM2_FREQ_GET(x)           (((x) >> 0) & 0x3f)

#define SRSS_CLK_IMO_TRIM4_ADDR                      0x0000ff34
#define SRSS_CLK_IMO_TRIM4_MASK                      0x000000ff
/** Gain for IMO. Typically stored in SFLASH and copied here on boot. Only used
   during USB mode, either during USB operation or when
   CLK_IMO_CONFIG.TEST_USB_MODE=1. When not in USB mode, this register is not
   used and the actual IMO gain is forced to a setting of 0. @multiple */
  #define SRSS_CLK_IMO_TRIM4_GAIN(v)               ((v) << 0)
  #define SRSS_CLK_IMO_TRIM4_GAIN_SET(x, v)        do { (x) = (((x) & ~0x1f) | ((v) << 0)); } while(0)
  #define SRSS_CLK_IMO_TRIM4_GAIN_GET(x)           (((x) >> 0) & 0x1f)
/** Full-speed USB offset. Updated by hardware during USB osclock mode. Can be
   updated by software when TEST_USB_MODE=1. Otherwise writes are ignored.
   Engineering only. @multiple */
  #define SRSS_CLK_IMO_TRIM4_FSOFFSET(v)           ((v) << 5)
  #define SRSS_CLK_IMO_TRIM4_FSOFFSET_SET(x, v)    do { (x) = (((x) & ~0xe0) | ((v) << 5)); } while(0)
  #define SRSS_CLK_IMO_TRIM4_FSOFFSET_GET(x)       (((x) >> 5) & 0x7)

#define SRSS_PWR_RSVD_TRIM_ADDR                      0x0000ff38
#define SRSS_PWR_RSVD_TRIM_MASK                      0x0000000f
/** Reserved, unused registers. @multiple */
  #define SRSS_PWR_RSVD_TRIM_RSVD_TRIM(v)          ((v) << 0)
  #define SRSS_PWR_RSVD_TRIM_RSVD_TRIM_SET(x, v)   do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define SRSS_PWR_RSVD_TRIM_RSVD_TRIM_GET(x)      (((x) >> 0) & 0xf)

#endif

