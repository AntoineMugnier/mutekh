/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -I gpio_port.bf -O gpio_port.h -o cdefs cdefs_use_reg_mask=1          \
     cdefs_use_field_setval=1
*/

#ifndef _GPIO_PORT_BFGEN_DEFS_
#define _GPIO_PORT_BFGEN_DEFS_

#define GPIO_PORT_DR_ADDR                            0x00000000
#define GPIO_PORT_DR_MASK                            0x000000ff
/** IO pad output data. @multiple */
  #define GPIO_PORT_DR_DATA_COUNT                  8
  #define GPIO_PORT_DR_DATA(fidx)                  (0x00000001 << ((fidx)))

#define GPIO_PORT_PS_ADDR                            0x00000004
#define GPIO_PORT_PS_MASK                            0x000001ff
/** IO pad state. If the drive mode for the pin is set to high Z Analog, the pin
   state will read 0 independent of the voltage on the pin. @multiple */
  #define GPIO_PORT_PS_DATA_COUNT                  8
  #define GPIO_PORT_PS_DATA(fidx)                  (0x00000001 << ((fidx)))
/** State of the filtered pin. @multiple */
  #define GPIO_PORT_PS_FLT_DATA                    0x00000100

#define GPIO_PORT_PC_ADDR                            0x00000008
#define GPIO_PORT_PC_MASK                            0xc3ffffff
/** The GPIO drive mode for IO pad. Note: when initializing IO's that are
   connected to a live bus (such as I2C), make sure the HSIOM is properly
   configured (HSIOM_PRT_SELx) before turning the IO on here to avoid producing
   glitches on the bus. Default Value: 0 @multiple */
  #define GPIO_PORT_PC_DM_COUNT                    8
  #define GPIO_PORT_PC_DM(fidx, v)                 ((GPIO_PORT_PC_DM_##v) << ((fidx) * 3 + 0))
  #define GPIO_PORT_PC_DM_SET(fidx, x, v)          do { (x) = (((x) & ~(0x7 << ((fidx) * 3))) | ((GPIO_PORT_PC_DM_##v) << ((fidx) * 3 + 0))); } while(0)
  #define GPIO_PORT_PC_DM_SETVAL(fidx, x, v)       do { (x) = (((x) & ~(0x7 << ((fidx) * 3))) | ((v) << ((fidx) * 3 + 0))); } while(0)
  #define GPIO_PORT_PC_DM_GET(fidx, x)             (((x) >> ((fidx) * 3 + 0)) & 0x7)
/** Mode 0 (analog mode): Output buffer off (high Z). Input buffer off. */
  #define GPIO_PORT_PC_DM_OFF                      0x00000000
/** Mode 1: Output buffer off (high Z). Input buffer on. */
  #define GPIO_PORT_PC_DM_INPUT                    0x00000001
/** Mode 2: Strong pull down ('0'), weak/resistive pull up (PU). Input buffer on. */
  #define GPIO_PORT_PC_DM_0_PU                     0x00000002
/** Mode 3: Weak/resistive pull down (PD), strong pull up ('1'). Input buffer on. */
  #define GPIO_PORT_PC_DM_PD_1                     0x00000003
/** Mode 4: Strong pull down ('0'), open drain (pull up off). Input buffer on. */
  #define GPIO_PORT_PC_DM_0_Z                      0x00000004
/** Mode 5: Open drain (pull down off), strong pull up ('1'). Input buffer on. */
  #define GPIO_PORT_PC_DM_Z_1                      0x00000005
/** Mode 6: Strong pull down ('0'), strong pull up ('1'). Input buffer on. */
  #define GPIO_PORT_PC_DM_0_1                      0x00000006
/** Mode 7: Weak/resistive pull down (PD), weak/resistive pull up (PU). Input buffer on. */
  #define GPIO_PORT_PC_DM_PD_PU                    0x00000007
/** The GPIO cells include a VTRIP_SEL signal to alter the input buffer voltage.
   Note: this bit is ignored for SIO ports, the VTRIP_SEL settings in the SIO
   register are used instead (a separate VTRIP_SEL is provided for each pin
   pair). @multiple */
  #define GPIO_PORT_PC_PORT_VTRIP_SEL(v)           ((GPIO_PORT_PC_PORT_VTRIP_SEL_##v) << 24)
  #define GPIO_PORT_PC_PORT_VTRIP_SEL_SET(x, v)    do { (x) = (((x) & ~0x1000000) | ((GPIO_PORT_PC_PORT_VTRIP_SEL_##v) << 24)); } while(0)
  #define GPIO_PORT_PC_PORT_VTRIP_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x1000000) | ((v) << 24)); } while(0)
  #define GPIO_PORT_PC_PORT_VTRIP_SEL_GET(x)       (((x) >> 24) & 0x1)
/** CMOS input buffer. */
    #define GPIO_PORT_PC_PORT_VTRIP_SEL_CMOS         0x00000000
/** LVTTL input buffer. */
    #define GPIO_PORT_PC_PORT_VTRIP_SEL_LVTTL        0x00000001
/** This field controls the output edge rate of all pins on the port. @multiple
   */
  #define GPIO_PORT_PC_PORT_SLOW                   0x02000000
/** This field selects the input buffer reference. @multiple */
  #define GPIO_PORT_PC_PORT_IB_MODE_SEL(v)         ((GPIO_PORT_PC_PORT_IB_MODE_SEL_##v) << 30)
  #define GPIO_PORT_PC_PORT_IB_MODE_SEL_SET(x, v)  do { (x) = (((x) & ~0xc0000000) | ((GPIO_PORT_PC_PORT_IB_MODE_SEL_##v) << 30)); } while(0)
  #define GPIO_PORT_PC_PORT_IB_MODE_SEL_SETVAL(x, v) do { (x) = (((x) & ~0xc0000000) | ((v) << 30)); } while(0)
  #define GPIO_PORT_PC_PORT_IB_MODE_SEL_GET(x)     (((x) >> 30) & 0x3)
/** CMOS/LVTTL input buffer, see PORT_VTRIP_SEL */
    #define GPIO_PORT_PC_PORT_IB_MODE_SEL_LOGIC      0x00000000
    #define GPIO_PORT_PC_PORT_IB_MODE_SEL_VCCHIB     0x00000001
/** (GPIO_OVTv2 and SIOv2) */
    #define GPIO_PORT_PC_PORT_IB_MODE_SEL_OVT        0x00000002
/** Reference possibly from reference generator cell (GPIO_OVTv2 and SIOv2) */
    #define GPIO_PORT_PC_PORT_IB_MODE_SEL_REF        0x00000003

#define GPIO_PORT_INTR_CFG_ADDR                      0x0000000c
#define GPIO_PORT_INTR_CFG_MASK                      0x001fffff
/** Sets which edge will trigger an IRQ for IO pad. @multiple */
  #define GPIO_PORT_INTR_CFG_EDGE_SEL_COUNT        8
  #define GPIO_PORT_INTR_CFG_EDGE_SEL(fidx, v)     ((GPIO_PORT_INTR_CFG_EDGE_SEL_##v) << ((fidx) * 2 + 0))
  #define GPIO_PORT_INTR_CFG_EDGE_SEL_SET(fidx, x, v) do { (x) = (((x) & ~(0x3 << ((fidx) * 2))) | ((GPIO_PORT_INTR_CFG_EDGE_SEL_##v) << ((fidx) * 2 + 0))); } while(0)
  #define GPIO_PORT_INTR_CFG_EDGE_SEL_SETVAL(fidx, x, v) do { (x) = (((x) & ~(0x3 << ((fidx) * 2))) | ((v) << ((fidx) * 2 + 0))); } while(0)
  #define GPIO_PORT_INTR_CFG_EDGE_SEL_GET(fidx, x) (((x) >> ((fidx) * 2 + 0)) & 0x3)
/** Disabled */
  #define GPIO_PORT_INTR_CFG_EDGE_SEL_DISABLE      0x00000000
/** Rising edge */
  #define GPIO_PORT_INTR_CFG_EDGE_SEL_RISING       0x00000001
/** Falling edge */
  #define GPIO_PORT_INTR_CFG_EDGE_SEL_FALLING      0x00000002
/** Both rising and falling edges */
  #define GPIO_PORT_INTR_CFG_EDGE_SEL_BOTH         0x00000003
/** Same for the glitch filtered pin (selected by FLT_SELECT). Default Value: 0
   @multiple */
  #define GPIO_PORT_INTR_CFG_FLT_EDGE_SEL(v)       ((GPIO_PORT_INTR_CFG_FLT_EDGE_SEL_##v) << 16)
  #define GPIO_PORT_INTR_CFG_FLT_EDGE_SEL_SET(x, v) do { (x) = (((x) & ~0x30000) | ((GPIO_PORT_INTR_CFG_FLT_EDGE_SEL_##v) << 16)); } while(0)
  #define GPIO_PORT_INTR_CFG_FLT_EDGE_SEL_SETVAL(x, v) do { (x) = (((x) & ~0x30000) | ((v) << 16)); } while(0)
  #define GPIO_PORT_INTR_CFG_FLT_EDGE_SEL_GET(x)   (((x) >> 16) & 0x3)
/** Disabled */
    #define GPIO_PORT_INTR_CFG_FLT_EDGE_SEL_DISABLE  0x00000000
/** Rising edge */
    #define GPIO_PORT_INTR_CFG_FLT_EDGE_SEL_RISING   0x00000001
/** Falling edge */
    #define GPIO_PORT_INTR_CFG_FLT_EDGE_SEL_FALLING  0x00000002
/** Both rising and falling edges */
    #define GPIO_PORT_INTR_CFG_FLT_EDGE_SEL_BOTH     0x00000003
/** Selects which pin is routed through the 50ns glitch filter to provide a
   glitch-safe interrupt. @multiple */
  #define GPIO_PORT_INTR_CFG_FLT_SEL(v)            ((v) << 18)
  #define GPIO_PORT_INTR_CFG_FLT_SEL_SET(x, v)     do { (x) = (((x) & ~0x1c0000) | ((v) << 18)); } while(0)
  #define GPIO_PORT_INTR_CFG_FLT_SEL_GET(x)        (((x) >> 18) & 0x7)

#define GPIO_PORT_INTR_ADDR                          0x00000010
#define GPIO_PORT_INTR_MASK                          0x01ff01ff
/** Interrupt pending on IO pad. Write 1 to clear. @multiple */
  #define GPIO_PORT_INTR_DATA_COUNT                8
  #define GPIO_PORT_INTR_DATA(fidx)                (0x00000001 << ((fidx)))
/** Deglitched interrupt pending (selected by FLT_SELECT). @multiple */
  #define GPIO_PORT_INTR_FLT_DATA                  0x00000100
  #define GPIO_PORT_INTR_PS_DATA_COUNT             8
  #define GPIO_PORT_INTR_PS_DATA(fidx)             (0x00010000 << ((fidx)))
/** This is a duplicate of the contents of the PS register, provided here to
   allow reading of both pin state and interrupt state of the port in a single
   read operation. @multiple */
  #define GPIO_PORT_INTR_PS_FLT_DATA               0x01000000

#define GPIO_PORT_PC2_ADDR                           0x00000018
#define GPIO_PORT_PC2_MASK                           0x000000ff
/** Disables the input buffer for IO pad independent of the port control drive
   mode (PC.DM). This bit should be set when analog signals are present on the
   pin and PC.DM != 0 is required to use the output driver. @multiple */
  #define GPIO_PORT_PC2_INP_DIS_COUNT              8
  #define GPIO_PORT_PC2_INP_DIS(fidx)              (0x00000001 << ((fidx)))

#define GPIO_PORT_DR_SET_ADDR                        0x00000040
#define GPIO_PORT_DR_SET_MASK                        0x000000ff
/** IO pad @multiple */
  #define GPIO_PORT_DR_SET_DATA_COUNT              8
  #define GPIO_PORT_DR_SET_DATA(fidx)              (0x00000001 << ((fidx)))

#define GPIO_PORT_DR_CLR_ADDR                        0x00000044
#define GPIO_PORT_DR_CLR_MASK                        0x000000ff
/** IO pad @multiple */
  #define GPIO_PORT_DR_CLR_DATA_COUNT              8
  #define GPIO_PORT_DR_CLR_DATA(fidx)              (0x00000001 << ((fidx)))

#define GPIO_PORT_DR_TOGGLE_ADDR                     0x00000048
#define GPIO_PORT_DR_TOGGLE_MASK                     0x000000ff
/** IO pad @multiple */
  #define GPIO_PORT_DR_TOGGLE_DATA_COUNT           8
  #define GPIO_PORT_DR_TOGGLE_DATA(fidx)           (0x00000001 << ((fidx)))

#endif

