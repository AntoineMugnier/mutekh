/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -o cdefs cdefs_use_reg_mask=1 cdefs_use_field_setval=1                \
     cdefs_use_field_shift=1 cdefs_use_field_shifted_mask=1                    \
     cdefs_sfx_field_shifter=_SHIFT_VAL
*/

#ifndef _USBD_BFGEN_DEFS_
#define _USBD_BFGEN_DEFS_

/** Description collection[0]: Captures the EPIN[0].PTR, EPIN[0].MAXCNT and
   EPIN[0].CONFIG registers values, and enables endpoint IN 0 to respond to
   traffic from host @multiple */
#define USBD_TASKS_STARTEPIN_ADDR(ridx)              (0x00000004 + (ridx) * 4)
#define USBD_TASKS_STARTEPIN_COUNT                   8
#define USBD_TASKS_STARTEPIN_MASK                    0x00000000

/** Captures the ISOIN.PTR, ISOIN.MAXCNT and ISOIN.CONFIG registers values, and
   enables sending data on iso endpoint @multiple */
#define USBD_TASKS_STARTISOIN_ADDR                   0x00000024
#define USBD_TASKS_STARTISOIN_MASK                   0x00000000

/** Description collection[0]: Captures the EPOUT[0].PTR, EPOUT[0].MAXCNT and
   EPOUT[0].CONFIG registers values, and enables endpoint 0 to respond to traffic
   from host @multiple */
#define USBD_TASKS_STARTEPOUT_ADDR(ridx)             (0x00000028 + (ridx) * 4)
#define USBD_TASKS_STARTEPOUT_COUNT                  8
#define USBD_TASKS_STARTEPOUT_MASK                   0x00000000

/** OUT Endpoint halted status, can be used as response to GetStatus() @multiple
   */
#define USBD_HALTED_EPOUT_ADDR(ridx)                 (0x00000044 + (ridx) * 4)
#define USBD_HALTED_EPOUT_COUNT                      8
#define USBD_HALTED_EPOUT_MASK                       0x0000ffff
/** OUT Endpoint halted cause @multiple */
  #define USBD_HALTED_EPOUT_HALTED                 0x0000ffff
  #define USBD_HALTED_EPOUT_HALTED_SHIFT           0
  #define USBD_HALTED_EPOUT_HALTED_SHIFT_VAL(v)    ((v) << 0)
  #define USBD_HALTED_EPOUT_HALTED_SET(x, v)       do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define USBD_HALTED_EPOUT_HALTED_GET(x)          (((x) >> 0) & 0xffff)

/** Captures the ISOOUT.PTR, ISOOUT.MAXCNT and ISOOUT.CONFIG registers values,
   and enables receiving of data on iso endpoint @multiple */
#define USBD_TASKS_STARTISOOUT_ADDR                  0x00000048
#define USBD_TASKS_STARTISOOUT_MASK                  0x00000000

/** Allows OUT data stage on control endpoint 0 @multiple */
#define USBD_TASKS_EP0RCVOUT_ADDR                    0x0000004c
#define USBD_TASKS_EP0RCVOUT_MASK                    0x00000000

/** Allows status stage on control endpoint 0 @multiple */
#define USBD_TASKS_EP0STATUS_ADDR                    0x00000050
#define USBD_TASKS_EP0STATUS_MASK                    0x00000000

/** STALLs data and status stage on control endpoint 0 @multiple */
#define USBD_TASKS_EP0STALL_ADDR                     0x00000054
#define USBD_TASKS_EP0STALL_MASK                     0x00000000

/** Forces D+ and D-lines to the state defined in the DPDMVALUE register
   @multiple */
#define USBD_TASKS_DPDMDRIVE_ADDR                    0x00000058
#define USBD_TASKS_DPDMDRIVE_MASK                    0x00000000

/** Stops forcing D+ and D- lines to any state (USB engine takes control)
   @multiple */
#define USBD_TASKS_DPDMNODRIVE_ADDR                  0x0000005c
#define USBD_TASKS_DPDMNODRIVE_MASK                  0x00000000

/** Signals that a USB reset condition has been detected on the USB lines
   @multiple */
#define USBD_EVENTS_USBRESET_ADDR                    0x00000100
#define USBD_EVENTS_USBRESET_MASK                    0x00000000

/** Confirms that the EPIN[n].PTR, EPIN[n].MAXCNT, EPIN[n].CONFIG, or
   EPOUT[n].PTR, EPOUT[n].MAXCNT and EPOUT[n].CONFIG registers have been captured
   on all endpoints reported in the EPSTATUS register @multiple */
#define USBD_EVENTS_STARTED_ADDR                     0x00000104
#define USBD_EVENTS_STARTED_MASK                     0x00000000

/** Description collection[0]: The whole EPIN[0] buffer has been consumed. The
   RAM buffer can be accessed safely by software @multiple */
#define USBD_EVENTS_ENDEPIN_ADDR(ridx)               (0x00000108 + (ridx) * 4)
#define USBD_EVENTS_ENDEPIN_COUNT                    8
#define USBD_EVENTS_ENDEPIN_MASK                     0x00000000

/** An acknowledged data transfer has taken place on the control endpoint
   @multiple */
#define USBD_EVENTS_EP0DATADONE_ADDR                 0x00000128
#define USBD_EVENTS_EP0DATADONE_MASK                 0x00000000

/** The whole ISOIN buffer has been consumed. The RAM buffer can be accessed
   safely by software @multiple */
#define USBD_EVENTS_ENDISOIN_ADDR                    0x0000012c
#define USBD_EVENTS_ENDISOIN_MASK                    0x00000000

/** Description collection[0]: The whole EPOUT[0] buffer has been consumed. The
   RAM buffer can be accessed safely by software @multiple */
#define USBD_EVENTS_ENDEPOUT_ADDR(ridx)              (0x00000130 + (ridx) * 4)
#define USBD_EVENTS_ENDEPOUT_COUNT                   8
#define USBD_EVENTS_ENDEPOUT_MASK                    0x00000000

/** The whole ISOOUT buffer has been consumed. The RAM buffer can be accessed
   safely by software @multiple */
#define USBD_EVENTS_ENDISOOUT_ADDR                   0x00000150
#define USBD_EVENTS_ENDISOOUT_MASK                   0x00000000

/** Signals that a SOF (start of frame) condition has been detected on the USB
   lines @multiple */
#define USBD_EVENTS_SOF_ADDR                         0x00000154
#define USBD_EVENTS_SOF_MASK                         0x00000000

/** An event or an error not covered by specific events has occurred, check
   EVENTCAUSE register to find the cause @multiple */
#define USBD_EVENTS_USBEVENT_ADDR                    0x00000158
#define USBD_EVENTS_USBEVENT_MASK                    0x00000000

/** A valid SETUP token has been received (and acknowledged) on the control
   endpoint @multiple */
#define USBD_EVENTS_EP0SETUP_ADDR                    0x0000015c
#define USBD_EVENTS_EP0SETUP_MASK                    0x00000000

/** A data transfer has occurred on a data endpoint, indicated by the
   EPDATASTATUS register @multiple */
#define USBD_EVENTS_EPDATA_ADDR                      0x00000160
#define USBD_EVENTS_EPDATA_MASK                      0x00000000

/** Access to an unavailable USB register has been attempted (software or
   EasyDMA). This event can get fired even when USBD is not ENABLEd @multiple */
#define USBD_EVENTS_ACCESSFAULT_ADDR                 0x00000164
#define USBD_EVENTS_ACCESSFAULT_MASK                 0x00000000

/** Shortcut register @multiple */
#define USBD_SHORTS_ADDR                             0x00000200
#define USBD_SHORTS_MASK                             0x0000001f
/** Shortcut between EP0DATADONE event and STARTEPIN[0] task @multiple */
  #define USBD_SHORTS_EP0DATADONE_STARTEPIN0       0x00000001
  #define USBD_SHORTS_EP0DATADONE_STARTEPIN0_SHIFT 0
  #define USBD_SHORTS_EP0DATADONE_STARTEPIN0_SHIFT_VAL(v) ((USBD_SHORTS_EP0DATADONE_STARTEPIN0_##v) << 0)
  #define USBD_SHORTS_EP0DATADONE_STARTEPIN0_SET(x, v) do { (x) = (((x) & ~0x1) | ((USBD_SHORTS_EP0DATADONE_STARTEPIN0_##v) << 0)); } while(0)
  #define USBD_SHORTS_EP0DATADONE_STARTEPIN0_SETVAL(x, v) do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define USBD_SHORTS_EP0DATADONE_STARTEPIN0_GET(x) (((x) >> 0) & 0x1)
    #define USBD_SHORTS_EP0DATADONE_STARTEPIN0_DISABLE_SHORTCUT 0x00000000
    #define USBD_SHORTS_EP0DATADONE_STARTEPIN0_ENABLE_SHORTCUT 0x00000001
/** Shortcut between EP0DATADONE event and STARTEPOUT[0] task @multiple */
  #define USBD_SHORTS_EP0DATADONE_STARTEPOUT0      0x00000002
  #define USBD_SHORTS_EP0DATADONE_STARTEPOUT0_SHIFT 1
  #define USBD_SHORTS_EP0DATADONE_STARTEPOUT0_SHIFT_VAL(v) ((USBD_SHORTS_EP0DATADONE_STARTEPOUT0_##v) << 1)
  #define USBD_SHORTS_EP0DATADONE_STARTEPOUT0_SET(x, v) do { (x) = (((x) & ~0x2) | ((USBD_SHORTS_EP0DATADONE_STARTEPOUT0_##v) << 1)); } while(0)
  #define USBD_SHORTS_EP0DATADONE_STARTEPOUT0_SETVAL(x, v) do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define USBD_SHORTS_EP0DATADONE_STARTEPOUT0_GET(x) (((x) >> 1) & 0x1)
    #define USBD_SHORTS_EP0DATADONE_STARTEPOUT0_DISABLE_SHORTCUT 0x00000000
    #define USBD_SHORTS_EP0DATADONE_STARTEPOUT0_ENABLE_SHORTCUT 0x00000001
/** Shortcut between EP0DATADONE event and EP0STATUS task @multiple */
  #define USBD_SHORTS_EP0DATADONE_EP0STATUS        0x00000004
  #define USBD_SHORTS_EP0DATADONE_EP0STATUS_SHIFT  2
  #define USBD_SHORTS_EP0DATADONE_EP0STATUS_SHIFT_VAL(v) ((USBD_SHORTS_EP0DATADONE_EP0STATUS_##v) << 2)
  #define USBD_SHORTS_EP0DATADONE_EP0STATUS_SET(x, v) do { (x) = (((x) & ~0x4) | ((USBD_SHORTS_EP0DATADONE_EP0STATUS_##v) << 2)); } while(0)
  #define USBD_SHORTS_EP0DATADONE_EP0STATUS_SETVAL(x, v) do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define USBD_SHORTS_EP0DATADONE_EP0STATUS_GET(x) (((x) >> 2) & 0x1)
    #define USBD_SHORTS_EP0DATADONE_EP0STATUS_DISABLE_SHORTCUT 0x00000000
    #define USBD_SHORTS_EP0DATADONE_EP0STATUS_ENABLE_SHORTCUT 0x00000001
/** Shortcut between ENDEPOUT[0] event and EP0STATUS task @multiple */
  #define USBD_SHORTS_ENDEPOUT0_EP0STATUS          0x00000008
  #define USBD_SHORTS_ENDEPOUT0_EP0STATUS_SHIFT    3
  #define USBD_SHORTS_ENDEPOUT0_EP0STATUS_SHIFT_VAL(v) ((USBD_SHORTS_ENDEPOUT0_EP0STATUS_##v) << 3)
  #define USBD_SHORTS_ENDEPOUT0_EP0STATUS_SET(x, v) do { (x) = (((x) & ~0x8) | ((USBD_SHORTS_ENDEPOUT0_EP0STATUS_##v) << 3)); } while(0)
  #define USBD_SHORTS_ENDEPOUT0_EP0STATUS_SETVAL(x, v) do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define USBD_SHORTS_ENDEPOUT0_EP0STATUS_GET(x)   (((x) >> 3) & 0x1)
    #define USBD_SHORTS_ENDEPOUT0_EP0STATUS_DISABLE_SHORTCUT 0x00000000
    #define USBD_SHORTS_ENDEPOUT0_EP0STATUS_ENABLE_SHORTCUT 0x00000001
/** Shortcut between ENDEPOUT[0] event and EP0RCVOUT task @multiple */
  #define USBD_SHORTS_ENDEPOUT0_EP0RCVOUT          0x00000010
  #define USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_SHIFT    4
  #define USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_SHIFT_VAL(v) ((USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_##v) << 4)
  #define USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_SET(x, v) do { (x) = (((x) & ~0x10) | ((USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_##v) << 4)); } while(0)
  #define USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_SETVAL(x, v) do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_GET(x)   (((x) >> 4) & 0x1)
    #define USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_DISABLE_SHORTCUT 0x00000000
    #define USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_ENABLE_SHORTCUT 0x00000001

/** Enable or disable interrupt @multiple */
#define USBD_INTEN_ADDR                              0x00000300
#define USBD_INTEN_MASK                              0x03ffffff
/** Enable or disable interrupt for USBRESET event @multiple */
  #define USBD_INTEN_USBRESET                      0x00000001
  #define USBD_INTEN_USBRESET_SHIFT                0
/** Enable or disable interrupt for STARTED event @multiple */
  #define USBD_INTEN_STARTED                       0x00000002
  #define USBD_INTEN_STARTED_SHIFT                 1
/** Enable or disable interrupt for ENDEPIN event @multiple */
  #define USBD_INTEN_ENDEPIN_COUNT                 8
  #define USBD_INTEN_ENDEPIN(fidx)                 (0x00000004 << ((fidx)))
  #define USBD_INTEN_ENDEPIN_SHIFT(fidx)           ((fidx) + 2)
/** Enable or disable interrupt for EP0DATADONE event @multiple */
  #define USBD_INTEN_EP0DATADONE                   0x00000400
  #define USBD_INTEN_EP0DATADONE_SHIFT             10
/** Enable or disable interrupt for ENDISOIN event @multiple */
  #define USBD_INTEN_ENDISOIN                      0x00000800
  #define USBD_INTEN_ENDISOIN_SHIFT                11
/** Enable or disable interrupt for ENDEPOUT event @multiple */
  #define USBD_INTEN_ENDEPOUT_COUNT                8
  #define USBD_INTEN_ENDEPOUT(fidx)                (0x00001000 << ((fidx)))
  #define USBD_INTEN_ENDEPOUT_SHIFT(fidx)          ((fidx) + 12)
/** Enable or disable interrupt for ENDISOOUT event @multiple */
  #define USBD_INTEN_ENDISOOUT                     0x00100000
  #define USBD_INTEN_ENDISOOUT_SHIFT               20
/** Enable or disable interrupt for SOF event @multiple */
  #define USBD_INTEN_SOF                           0x00200000
  #define USBD_INTEN_SOF_SHIFT                     21
/** Enable or disable interrupt for USBEVENT event @multiple */
  #define USBD_INTEN_USBEVENT                      0x00400000
  #define USBD_INTEN_USBEVENT_SHIFT                22
/** Enable or disable interrupt for EP0SETUP event @multiple */
  #define USBD_INTEN_EP0SETUP                      0x00800000
  #define USBD_INTEN_EP0SETUP_SHIFT                23
/** Enable or disable interrupt for EPDATA event @multiple */
  #define USBD_INTEN_EPDATA                        0x01000000
  #define USBD_INTEN_EPDATA_SHIFT                  24
/** Enable or disable interrupt for ACCESSFAULT event @multiple */
  #define USBD_INTEN_ACCESSFAULT                   0x02000000
  #define USBD_INTEN_ACCESSFAULT_SHIFT             25

/** Enable interrupt, use bitfield from INTEN @multiple */
#define USBD_INTENSET_ADDR                           0x00000304
#define USBD_INTENSET_MASK                           0x00000000

/** Disable interrupt, use bitfield from INTEN @multiple */
#define USBD_INTENCLR_ADDR                           0x00000308
#define USBD_INTENCLR_MASK                           0x00000000

/** Details on event that caused the USBEVENT event @multiple */
#define USBD_EVENTCAUSE_ADDR                         0x00000400
#define USBD_EVENTCAUSE_MASK                         0x00000b01
/** CRC error was detected on isochronous OUT endpoint 8. Write '1' to clear
   @multiple */
  #define USBD_EVENTCAUSE_ISOOUTCRC                0x00000001
  #define USBD_EVENTCAUSE_ISOOUTCRC_SHIFT          0
/** Signals that the USB lines have been seen idle long enough for the device to
   enter suspend. Write '1' to clear @multiple */
  #define USBD_EVENTCAUSE_SUSPEND                  0x00000100
  #define USBD_EVENTCAUSE_SUSPEND_SHIFT            8
/** Signals that a RESUME condition (K state or activity restart) has been
   detected on the USB lines. Write '1' to clear @multiple */
  #define USBD_EVENTCAUSE_RESUME                   0x00000200
  #define USBD_EVENTCAUSE_RESUME_SHIFT             9
/** Wrapper has re-initialized SFRs to the proper values. MAC is ready for normal
   operation. Write '1' to clear @multiple */
  #define USBD_EVENTCAUSE_READY                    0x00000800
  #define USBD_EVENTCAUSE_READY_SHIFT              11

/** Provides the logic state of the D+ and D- lines @multiple */
#define USBD_BUSSTATE_ADDR                           0x00000404
#define USBD_BUSSTATE_MASK                           0x00000003
/** State of the D- line @multiple */
  #define USBD_BUSSTATE_DM                         0x00000001
  #define USBD_BUSSTATE_DM_SHIFT                   0
/** State of the D+ line @multiple */
  #define USBD_BUSSTATE_DP                         0x00000002
  #define USBD_BUSSTATE_DP_SHIFT                   1

/** IN Endpoint halted status, can be used as response to GetStatus() @multiple
   */
#define USBD_HALTED_EPIN_ADDR(ridx)                  (0x00000420 + (ridx) * 4)
#define USBD_HALTED_EPIN_COUNT                       8
#define USBD_HALTED_EPIN_MASK                        0x0000ffff
/** IN Endpoint halted cause @multiple */
  #define USBD_HALTED_EPIN_HALTED                  0x0000ffff
  #define USBD_HALTED_EPIN_HALTED_SHIFT            0
  #define USBD_HALTED_EPIN_HALTED_SHIFT_VAL(v)     ((v) << 0)
  #define USBD_HALTED_EPIN_HALTED_SET(x, v)        do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define USBD_HALTED_EPIN_HALTED_GET(x)           (((x) >> 0) & 0xffff)

/** Provides information on which endpoint's EasyDMA registers have been captured
   @multiple */
#define USBD_EPSTATUS_ADDR                           0x00000468
#define USBD_EPSTATUS_MASK                           0x00ff01ff
/** Endpoint's EasyDMA registers captured state. Write '1' to clear @multiple */
  #define USBD_EPSTATUS_EPIN_COUNT                 9
  #define USBD_EPSTATUS_EPIN(fidx)                 (0x00000001 << ((fidx)))
  #define USBD_EPSTATUS_EPIN_SHIFT(fidx)           ((fidx) + 0)
/** Endpoint's EasyDMA registers captured state. Write '1' to clear @multiple */
  #define USBD_EPSTATUS_EPOUT_COUNT                8
  #define USBD_EPSTATUS_EPOUT(fidx)                (0x00010000 << ((fidx)))
  #define USBD_EPSTATUS_EPOUT_SHIFT(fidx)          ((fidx) + 16)

/** Provides information on which endpoint(s) an acknowledged data transfer has
   occurred (EPDATA event) Use bitfield from EPSTATUS, EPDATASTATUS.EPIN0 does
   not exist @multiple */
#define USBD_EPDATASTATUS_ADDR                       0x0000046c
#define USBD_EPDATASTATUS_MASK                       0x00000000

/** Device USB address @multiple */
#define USBD_USBADDR_ADDR                            0x00000470
#define USBD_USBADDR_MASK                            0x00000000

#define USBD_EP0CS_ADDR                              0x00000474
#define USBD_EP0CS_MASK                              0x00000020
/** Setup buffer content changed @multiple */
  #define USBD_EP0CS_CHGSET                        0x00000020
  #define USBD_EP0CS_CHGSET_SHIFT                  5

/** SETUP data, byte 0, bmRequestType @multiple */
#define USBD_BMREQUESTTYPE_ADDR                      0x00000480
#define USBD_BMREQUESTTYPE_MASK                      0x000000ff
/** Data transfer type @multiple */
  #define USBD_BMREQUESTTYPE_RECIPIENT             0x0000001f
  #define USBD_BMREQUESTTYPE_RECIPIENT_SHIFT       0
  #define USBD_BMREQUESTTYPE_RECIPIENT_SHIFT_VAL(v) ((USBD_BMREQUESTTYPE_RECIPIENT_##v) << 0)
  #define USBD_BMREQUESTTYPE_RECIPIENT_SET(x, v)   do { (x) = (((x) & ~0x1f) | ((USBD_BMREQUESTTYPE_RECIPIENT_##v) << 0)); } while(0)
  #define USBD_BMREQUESTTYPE_RECIPIENT_SETVAL(x, v) do { (x) = (((x) & ~0x1f) | ((v) << 0)); } while(0)
  #define USBD_BMREQUESTTYPE_RECIPIENT_GET(x)      (((x) >> 0) & 0x1f)
    #define USBD_BMREQUESTTYPE_RECIPIENT_DEVICE      0x00000000
    #define USBD_BMREQUESTTYPE_RECIPIENT_INTERFACE   0x00000001
    #define USBD_BMREQUESTTYPE_RECIPIENT_ENDPOINT    0x00000002
    #define USBD_BMREQUESTTYPE_RECIPIENT_OTHER       0x00000003
/** Data transfer type @multiple */
  #define USBD_BMREQUESTTYPE_TYPE                  0x00000060
  #define USBD_BMREQUESTTYPE_TYPE_SHIFT            5
  #define USBD_BMREQUESTTYPE_TYPE_SHIFT_VAL(v)     ((USBD_BMREQUESTTYPE_TYPE_##v) << 5)
  #define USBD_BMREQUESTTYPE_TYPE_SET(x, v)        do { (x) = (((x) & ~0x60) | ((USBD_BMREQUESTTYPE_TYPE_##v) << 5)); } while(0)
  #define USBD_BMREQUESTTYPE_TYPE_SETVAL(x, v)     do { (x) = (((x) & ~0x60) | ((v) << 5)); } while(0)
  #define USBD_BMREQUESTTYPE_TYPE_GET(x)           (((x) >> 5) & 0x3)
    #define USBD_BMREQUESTTYPE_TYPE_STANDARD         0x00000000
    #define USBD_BMREQUESTTYPE_TYPE_CLASS            0x00000001
    #define USBD_BMREQUESTTYPE_TYPE_VENDOR           0x00000002
/** Data transfer direction @multiple */
  #define USBD_BMREQUESTTYPE_DIRECTION             0x00000080
  #define USBD_BMREQUESTTYPE_DIRECTION_SHIFT       7
  #define USBD_BMREQUESTTYPE_DIRECTION_SHIFT_VAL(v) ((USBD_BMREQUESTTYPE_DIRECTION_##v) << 7)
  #define USBD_BMREQUESTTYPE_DIRECTION_SET(x, v)   do { (x) = (((x) & ~0x80) | ((USBD_BMREQUESTTYPE_DIRECTION_##v) << 7)); } while(0)
  #define USBD_BMREQUESTTYPE_DIRECTION_SETVAL(x, v) do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
  #define USBD_BMREQUESTTYPE_DIRECTION_GET(x)      (((x) >> 7) & 0x1)
    #define USBD_BMREQUESTTYPE_DIRECTION_HOST_TO_DEVICE 0x00000000
    #define USBD_BMREQUESTTYPE_DIRECTION_DEVICE_TO_HOST 0x00000001

/** SETUP data, byte 1, bRequest @multiple */
#define USBD_BREQUEST_ADDR                           0x00000484
#define USBD_BREQUEST_MASK                           0x000000ff
/** SETUP data, byte 1, bRequest. Values provides for standard requests only,
   user must implement Class and Vendor values @multiple */
  #define USBD_BREQUEST_BREQUEST                   0x000000ff
  #define USBD_BREQUEST_BREQUEST_SHIFT             0
  #define USBD_BREQUEST_BREQUEST_SHIFT_VAL(v)      ((USBD_BREQUEST_BREQUEST_##v) << 0)
  #define USBD_BREQUEST_BREQUEST_SET(x, v)         do { (x) = (((x) & ~0xff) | ((USBD_BREQUEST_BREQUEST_##v) << 0)); } while(0)
  #define USBD_BREQUEST_BREQUEST_SETVAL(x, v)      do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define USBD_BREQUEST_BREQUEST_GET(x)            (((x) >> 0) & 0xff)
    #define USBD_BREQUEST_BREQUEST_GET_STATUS        0x00000000
    #define USBD_BREQUEST_BREQUEST_CLEAR_FEATURE     0x00000001
    #define USBD_BREQUEST_BREQUEST_SET_FEATURE       0x00000003
    #define USBD_BREQUEST_BREQUEST_SET_ADDRESS       0x00000005
    #define USBD_BREQUEST_BREQUEST_GET_DESCRIPTOR    0x00000006
    #define USBD_BREQUEST_BREQUEST_SET_DESCRIPTOR    0x00000007
    #define USBD_BREQUEST_BREQUEST_GET_CONFIGURATION 0x00000008
    #define USBD_BREQUEST_BREQUEST_SET_CONFIGURATION 0x00000009
    #define USBD_BREQUEST_BREQUEST_GET_INTERFACE     0x0000000a
    #define USBD_BREQUEST_BREQUEST_SET_INTERFACE     0x0000000b
    #define USBD_BREQUEST_BREQUEST_SYNCH_FRAME       0x0000000c

/** SETUP data, byte 2, LSB of wValue @multiple */
#define USBD_WVALUEL_ADDR                            0x00000488
#define USBD_WVALUEL_MASK                            0x000000ff
/** SETUP data, byte 2, LSB of wValue @multiple */
  #define USBD_WVALUEL_WVALUEL                     0x000000ff
  #define USBD_WVALUEL_WVALUEL_SHIFT               0
  #define USBD_WVALUEL_WVALUEL_SHIFT_VAL(v)        ((v) << 0)
  #define USBD_WVALUEL_WVALUEL_SET(x, v)           do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define USBD_WVALUEL_WVALUEL_GET(x)              (((x) >> 0) & 0xff)

/** SETUP data, byte 3, MSB of wValue @multiple */
#define USBD_WVALUEH_ADDR                            0x0000048c
#define USBD_WVALUEH_MASK                            0x000000ff
/** SETUP data, byte 3, MSB of wValue @multiple */
  #define USBD_WVALUEH_WVALUEH                     0x000000ff
  #define USBD_WVALUEH_WVALUEH_SHIFT               0
  #define USBD_WVALUEH_WVALUEH_SHIFT_VAL(v)        ((v) << 0)
  #define USBD_WVALUEH_WVALUEH_SET(x, v)           do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define USBD_WVALUEH_WVALUEH_GET(x)              (((x) >> 0) & 0xff)

/** SETUP data, byte 4, LSB of wIndex @multiple */
#define USBD_WINDEXL_ADDR                            0x00000490
#define USBD_WINDEXL_MASK                            0x000000ff
/** SETUP data, byte 4, LSB of wIndex @multiple */
  #define USBD_WINDEXL_WINDEXL                     0x000000ff
  #define USBD_WINDEXL_WINDEXL_SHIFT               0
  #define USBD_WINDEXL_WINDEXL_SHIFT_VAL(v)        ((v) << 0)
  #define USBD_WINDEXL_WINDEXL_SET(x, v)           do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define USBD_WINDEXL_WINDEXL_GET(x)              (((x) >> 0) & 0xff)

/** SETUP data, byte 5, MSB of wIndex @multiple */
#define USBD_WINDEXH_ADDR                            0x00000494
#define USBD_WINDEXH_MASK                            0x000000ff
/** SETUP data, byte 5, MSB of wIndex @multiple */
  #define USBD_WINDEXH_WINDEXH                     0x000000ff
  #define USBD_WINDEXH_WINDEXH_SHIFT               0
  #define USBD_WINDEXH_WINDEXH_SHIFT_VAL(v)        ((v) << 0)
  #define USBD_WINDEXH_WINDEXH_SET(x, v)           do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define USBD_WINDEXH_WINDEXH_GET(x)              (((x) >> 0) & 0xff)

/** SETUP data, byte 6, LSB of wLength @multiple */
#define USBD_WLENGTHL_ADDR                           0x00000498
#define USBD_WLENGTHL_MASK                           0x000000ff
/** SETUP data, byte 6, LSB of wLength @multiple */
  #define USBD_WLENGTHL_WLENGTHL                   0x000000ff
  #define USBD_WLENGTHL_WLENGTHL_SHIFT             0
  #define USBD_WLENGTHL_WLENGTHL_SHIFT_VAL(v)      ((v) << 0)
  #define USBD_WLENGTHL_WLENGTHL_SET(x, v)         do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define USBD_WLENGTHL_WLENGTHL_GET(x)            (((x) >> 0) & 0xff)

/** SETUP data, byte 7, MSB of wLength @multiple */
#define USBD_WLENGTHH_ADDR                           0x0000049c
#define USBD_WLENGTHH_MASK                           0x000000ff
/** SETUP data, byte 7, MSB of wLength @multiple */
  #define USBD_WLENGTHH_WLENGTHH                   0x000000ff
  #define USBD_WLENGTHH_WLENGTHH_SHIFT             0
  #define USBD_WLENGTHH_WLENGTHH_SHIFT_VAL(v)      ((v) << 0)
  #define USBD_WLENGTHH_WLENGTHH_SET(x, v)         do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define USBD_WLENGTHH_WLENGTHH_GET(x)            (((x) >> 0) & 0xff)

/** Amount of data received in last OUT transfer @multiple */
#define USBD_SIZE_EPOUT_ADDR(ridx)                   (0x000004a0 + (ridx) * 4)
#define USBD_SIZE_EPOUT_COUNT                        8
#define USBD_SIZE_EPOUT_MASK                         0x0000007f
  #define USBD_SIZE_EPOUT_SIZE                     0x0000007f
  #define USBD_SIZE_EPOUT_SIZE_SHIFT               0
  #define USBD_SIZE_EPOUT_SIZE_SHIFT_VAL(v)        ((v) << 0)
  #define USBD_SIZE_EPOUT_SIZE_SET(x, v)           do { (x) = (((x) & ~0x7f) | ((v) << 0)); } while(0)
  #define USBD_SIZE_EPOUT_SIZE_GET(x)              (((x) >> 0) & 0x7f)

/** Amount of data received in last ISO OUT transfer @multiple */
#define USBD_SIZE_ISOOUT_ADDR                        0x000004c0
#define USBD_SIZE_ISOOUT_MASK                        0x0001007f
  #define USBD_SIZE_ISOOUT_SIZE                    0x0000007f
  #define USBD_SIZE_ISOOUT_SIZE_SHIFT              0
  #define USBD_SIZE_ISOOUT_SIZE_SHIFT_VAL(v)       ((v) << 0)
  #define USBD_SIZE_ISOOUT_SIZE_SET(x, v)          do { (x) = (((x) & ~0x7f) | ((v) << 0)); } while(0)
  #define USBD_SIZE_ISOOUT_SIZE_GET(x)             (((x) >> 0) & 0x7f)
/** Whether transfer was zero in length, and size field should be ignored
   @multiple */
  #define USBD_SIZE_ISOOUT_ZERO                    0x00010000
  #define USBD_SIZE_ISOOUT_ZERO_SHIFT              16

/** Enable USB @multiple */
#define USBD_ENABLE_ADDR                             0x00000500
#define USBD_ENABLE_MASK                             0x00000001
/** Enable USB @multiple */
  #define USBD_ENABLE_ENABLE                       0x00000001
  #define USBD_ENABLE_ENABLE_SHIFT                 0

/** Control of the USB pull-up @multiple */
#define USBD_USBPULLUP_ADDR                          0x00000504
#define USBD_USBPULLUP_MASK                          0x00000001
/** Control of the USB pull-up on the D+ line @multiple */
  #define USBD_USBPULLUP_CONNECT                   0x00000001
  #define USBD_USBPULLUP_CONNECT_SHIFT             0
  #define USBD_USBPULLUP_CONNECT_SHIFT_VAL(v)      ((USBD_USBPULLUP_CONNECT_##v) << 0)
  #define USBD_USBPULLUP_CONNECT_SET(x, v)         do { (x) = (((x) & ~0x1) | ((USBD_USBPULLUP_CONNECT_##v) << 0)); } while(0)
  #define USBD_USBPULLUP_CONNECT_SETVAL(x, v)      do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define USBD_USBPULLUP_CONNECT_GET(x)            (((x) >> 0) & 0x1)
/** Pull-up is disconnected */
    #define USBD_USBPULLUP_CONNECT_DISCONNECTED      0x00000000
/** Pull-up is connected to D+ */
    #define USBD_USBPULLUP_CONNECT_DPLUS             0x00000001

/** State at which the DPDMDRIVE task will force D+ and D-. The DPDMNODRIVE task
   reverts the control of the lines to MAC IP (no forcing) @multiple */
#define USBD_DPDMVALUE_ADDR                          0x00000508
#define USBD_DPDMVALUE_MASK                          0x0000001f
/** State at which the DPDMDRIVE task will force D+ and D- @multiple */
  #define USBD_DPDMVALUE_STATE                     0x0000001f
  #define USBD_DPDMVALUE_STATE_SHIFT               0
  #define USBD_DPDMVALUE_STATE_SHIFT_VAL(v)        ((USBD_DPDMVALUE_STATE_##v) << 0)
  #define USBD_DPDMVALUE_STATE_SET(x, v)           do { (x) = (((x) & ~0x1f) | ((USBD_DPDMVALUE_STATE_##v) << 0)); } while(0)
  #define USBD_DPDMVALUE_STATE_SETVAL(x, v)        do { (x) = (((x) & ~0x1f) | ((v) << 0)); } while(0)
  #define USBD_DPDMVALUE_STATE_GET(x)              (((x) >> 0) & 0x1f)
/** D+ forced low, D- forced high (K state) for a timing pre-set in hardware (50 us or 5 ms, depending on bus state) */
    #define USBD_DPDMVALUE_STATE_K_TIMED             0x00000001
/** D+ forced high, D- forced low (J state) */
    #define USBD_DPDMVALUE_STATE_J                   0x00000002
/** D+ forced low, D- forced high (K state) */
    #define USBD_DPDMVALUE_STATE_K                   0x00000004

/** Data toggle control and status @multiple */
#define USBD_DTOGGLE_ADDR                            0x0000050c
#define USBD_DTOGGLE_MASK                            0x00000387
/** Select bulk endpoint number @multiple */
  #define USBD_DTOGGLE_EP                          0x00000007
  #define USBD_DTOGGLE_EP_SHIFT                    0
  #define USBD_DTOGGLE_EP_SHIFT_VAL(v)             ((v) << 0)
  #define USBD_DTOGGLE_EP_SET(x, v)                do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define USBD_DTOGGLE_EP_GET(x)                   (((x) >> 0) & 0x7)
/** Selects IN or OUT endpoint @multiple */
  #define USBD_DTOGGLE_IO                          0x00000080
  #define USBD_DTOGGLE_IO_SHIFT                    7
  #define USBD_DTOGGLE_IO_SHIFT_VAL(v)             ((USBD_DTOGGLE_IO_##v) << 7)
  #define USBD_DTOGGLE_IO_SET(x, v)                do { (x) = (((x) & ~0x80) | ((USBD_DTOGGLE_IO_##v) << 7)); } while(0)
  #define USBD_DTOGGLE_IO_SETVAL(x, v)             do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
  #define USBD_DTOGGLE_IO_GET(x)                   (((x) >> 7) & 0x1)
/** Selects OUT endpoint */
    #define USBD_DTOGGLE_IO_OUT                      0x00000000
/** Selects IN endpoint */
    #define USBD_DTOGGLE_IO_IN                       0x00000001
/** Data toggle value @multiple */
  #define USBD_DTOGGLE_VALUE                       0x00000300
  #define USBD_DTOGGLE_VALUE_SHIFT                 8
  #define USBD_DTOGGLE_VALUE_SHIFT_VAL(v)          ((USBD_DTOGGLE_VALUE_##v) << 8)
  #define USBD_DTOGGLE_VALUE_SET(x, v)             do { (x) = (((x) & ~0x300) | ((USBD_DTOGGLE_VALUE_##v) << 8)); } while(0)
  #define USBD_DTOGGLE_VALUE_SETVAL(x, v)          do { (x) = (((x) & ~0x300) | ((v) << 8)); } while(0)
  #define USBD_DTOGGLE_VALUE_GET(x)                (((x) >> 8) & 0x3)
/** No action on data toggle when writing the register with this value */
    #define USBD_DTOGGLE_VALUE_NOP                   0x00000000
/** Data toggle is DATA0 on endpoint set by EP and IO */
    #define USBD_DTOGGLE_VALUE_DATA0                 0x00000001
/** Data toggle is DATA1 on endpoint set by EP and IO */
    #define USBD_DTOGGLE_VALUE_DATA1                 0x00000002

/** Endpoint IN enable @multiple */
#define USBD_EPINEN_ADDR                             0x00000510
#define USBD_EPINEN_MASK                             0x000001ff
/** Enable IN endpoint @multiple */
  #define USBD_EPINEN_IN_ENABLE_COUNT              8
  #define USBD_EPINEN_IN_ENABLE(fidx)              (0x00000001 << ((fidx)))
  #define USBD_EPINEN_IN_ENABLE_SHIFT(fidx)        ((fidx) + 0)
/** Enable iso IN endpoint @multiple */
  #define USBD_EPINEN_ISOIN_ENABLE                 0x00000100
  #define USBD_EPINEN_ISOIN_ENABLE_SHIFT           8

/** Endpoint OUT enable @multiple */
#define USBD_EPOUTEN_ADDR                            0x00000514
#define USBD_EPOUTEN_MASK                            0x000001ff
/** Enable OUT endpoint @multiple */
  #define USBD_EPOUTEN_OUT_ENABLE_COUNT            8
  #define USBD_EPOUTEN_OUT_ENABLE(fidx)            (0x00000001 << ((fidx)))
  #define USBD_EPOUTEN_OUT_ENABLE_SHIFT(fidx)      ((fidx) + 0)
/** Enable iso OUT endpoint 8 @multiple */
  #define USBD_EPOUTEN_ISOOUT_ENABLE               0x00000100
  #define USBD_EPOUTEN_ISOOUT_ENABLE_SHIFT         8

/** STALL endpoints @multiple */
#define USBD_EPSTALL_ADDR                            0x00000518
#define USBD_EPSTALL_MASK                            0x00000187
/** Select endpoint number @multiple */
  #define USBD_EPSTALL_EP                          0x00000007
  #define USBD_EPSTALL_EP_SHIFT                    0
  #define USBD_EPSTALL_EP_SHIFT_VAL(v)             ((v) << 0)
  #define USBD_EPSTALL_EP_SET(x, v)                do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define USBD_EPSTALL_EP_GET(x)                   (((x) >> 0) & 0x7)
/** Selects IN or OUT endpoint @multiple */
  #define USBD_EPSTALL_IO                          0x00000080
  #define USBD_EPSTALL_IO_SHIFT                    7
  #define USBD_EPSTALL_IO_SHIFT_VAL(v)             ((USBD_EPSTALL_IO_##v) << 7)
  #define USBD_EPSTALL_IO_SET(x, v)                do { (x) = (((x) & ~0x80) | ((USBD_EPSTALL_IO_##v) << 7)); } while(0)
  #define USBD_EPSTALL_IO_SETVAL(x, v)             do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
  #define USBD_EPSTALL_IO_GET(x)                   (((x) >> 7) & 0x1)
/** Selects OUT endpoint */
    #define USBD_EPSTALL_IO_OUT                      0x00000000
/** Selects IN endpoint */
    #define USBD_EPSTALL_IO_IN                       0x00000001
/** Stall selected endpoint @multiple */
  #define USBD_EPSTALL_STALL                       0x00000100
  #define USBD_EPSTALL_STALL_SHIFT                 8
  #define USBD_EPSTALL_STALL_SHIFT_VAL(v)          ((USBD_EPSTALL_STALL_##v) << 8)
  #define USBD_EPSTALL_STALL_SET(x, v)             do { (x) = (((x) & ~0x100) | ((USBD_EPSTALL_STALL_##v) << 8)); } while(0)
  #define USBD_EPSTALL_STALL_SETVAL(x, v)          do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define USBD_EPSTALL_STALL_GET(x)                (((x) >> 8) & 0x1)
/** Don't stall selected endpoint */
    #define USBD_EPSTALL_STALL_RESUME                0x00000000
/** Stall selected endpoint */
    #define USBD_EPSTALL_STALL_STALL                 0x00000001

/** Controls the split of ISO buffers @multiple */
#define USBD_ISOSPLIT_ADDR                           0x0000051c
#define USBD_ISOSPLIT_MASK                           0x0000ffff
/** Controls the split of ISO buffers @multiple */
  #define USBD_ISOSPLIT_SPLIT                      0x0000ffff
  #define USBD_ISOSPLIT_SPLIT_SHIFT                0
  #define USBD_ISOSPLIT_SPLIT_SHIFT_VAL(v)         ((USBD_ISOSPLIT_SPLIT_##v) << 0)
  #define USBD_ISOSPLIT_SPLIT_SET(x, v)            do { (x) = (((x) & ~0xffff) | ((USBD_ISOSPLIT_SPLIT_##v) << 0)); } while(0)
  #define USBD_ISOSPLIT_SPLIT_SETVAL(x, v)         do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define USBD_ISOSPLIT_SPLIT_GET(x)               (((x) >> 0) & 0xffff)
    #define USBD_ISOSPLIT_SPLIT_FULL_BUFFER_DEDICATED_TO_EITHER_ISO_IN_OR_OUT 0x00000000
    #define USBD_ISOSPLIT_SPLIT_LOWER_HALF_FOR_IN_UPPER_HALF_FOR_OUT 0x00000080

/** Returns the current value of the start of frame counter @multiple */
#define USBD_FRAMECNTR_ADDR                          0x00000520
#define USBD_FRAMECNTR_MASK                          0x000007ff
/** Returns the current value of the start of frame counter @multiple */
  #define USBD_FRAMECNTR_FRAMECNTR                 0x000007ff
  #define USBD_FRAMECNTR_FRAMECNTR_SHIFT           0
  #define USBD_FRAMECNTR_FRAMECNTR_SHIFT_VAL(v)    ((v) << 0)
  #define USBD_FRAMECNTR_FRAMECNTR_SET(x, v)       do { (x) = (((x) & ~0x7ff) | ((v) << 0)); } while(0)
  #define USBD_FRAMECNTR_FRAMECNTR_GET(x)          (((x) >> 0) & 0x7ff)

/** First silicon only: Controls USBD peripheral low-power mode during USB
   suspend @multiple */
#define USBD_LOWPOWER_ADDR                           0x0000052c
#define USBD_LOWPOWER_MASK                           0x00000001
/** Controls USBD peripheral low-power mode during USB suspend @multiple */
  #define USBD_LOWPOWER_LOWPOWER                   0x00000001
  #define USBD_LOWPOWER_LOWPOWER_SHIFT             0
  #define USBD_LOWPOWER_LOWPOWER_SHIFT_VAL(v)      ((USBD_LOWPOWER_LOWPOWER_##v) << 0)
  #define USBD_LOWPOWER_LOWPOWER_SET(x, v)         do { (x) = (((x) & ~0x1) | ((USBD_LOWPOWER_LOWPOWER_##v) << 0)); } while(0)
  #define USBD_LOWPOWER_LOWPOWER_SETVAL(x, v)      do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define USBD_LOWPOWER_LOWPOWER_GET(x)            (((x) >> 0) & 0x1)
/** Software must write this value to exit low power mode and before performing a remote wake-up */
    #define USBD_LOWPOWER_LOWPOWER_EXIT              0x00000000
/** Software must write this value to enter low power mode after DMA and software have finished interacting with the USB peripheral */
    #define USBD_LOWPOWER_LOWPOWER_ENTER             0x00000001

/** Controls the response of the ISO IN endpoint to an IN token when no data is
   ready to be sent @multiple */
#define USBD_ISOINCONFIG_ADDR                        0x00000530
#define USBD_ISOINCONFIG_MASK                        0x00000001
/** Controls the response of the ISO IN endpoint to an IN token when no data is
   ready to be sent @multiple */
  #define USBD_ISOINCONFIG_RESPONSE                0x00000001
  #define USBD_ISOINCONFIG_RESPONSE_SHIFT          0
  #define USBD_ISOINCONFIG_RESPONSE_SHIFT_VAL(v)   ((USBD_ISOINCONFIG_RESPONSE_##v) << 0)
  #define USBD_ISOINCONFIG_RESPONSE_SET(x, v)      do { (x) = (((x) & ~0x1) | ((USBD_ISOINCONFIG_RESPONSE_##v) << 0)); } while(0)
  #define USBD_ISOINCONFIG_RESPONSE_SETVAL(x, v)   do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define USBD_ISOINCONFIG_RESPONSE_GET(x)         (((x) >> 0) & 0x1)
/** Endpoint does not respond in that case */
    #define USBD_ISOINCONFIG_RESPONSE_NONE           0x00000000
/** Endpoint responds with a zero-length data packet in that case */
    #define USBD_ISOINCONFIG_RESPONSE_ZLP            0x00000001

#define USBD_EPIN_PTR_ADDR(ridx)                     (0x00000600 + (ridx) * 20)
#define USBD_EPIN_PTR_COUNT                          8
#define USBD_EPIN_PTR_MASK                           0x00000000

#define USBD_EPIN_MAXCNT_ADDR(ridx)                  (0x00000604 + (ridx) * 20)
#define USBD_EPIN_MAXCNT_COUNT                       8
#define USBD_EPIN_MAXCNT_MASK                        0x00000000

#define USBD_EPIN_AMOUNT_ADDR(ridx)                  (0x00000608 + (ridx) * 20)
#define USBD_EPIN_AMOUNT_COUNT                       8
#define USBD_EPIN_AMOUNT_MASK                        0x00000000

#define USBD_ISOIN_PTR_ADDR                          0x000006a0
#define USBD_ISOIN_PTR_MASK                          0x00000000

#define USBD_ISOIN_MAXCNT_ADDR                       0x000006a4
#define USBD_ISOIN_MAXCNT_MASK                       0x00000000

#define USBD_ISOIN_AMOUNT_ADDR                       0x000006a8
#define USBD_ISOIN_AMOUNT_MASK                       0x00000000

#define USBD_EPOUT_PTR_ADDR(ridx)                    (0x00000700 + (ridx) * 20)
#define USBD_EPOUT_PTR_COUNT                         8
#define USBD_EPOUT_PTR_MASK                          0x00000000

#define USBD_EPOUT_MAXCNT_ADDR(ridx)                 (0x00000704 + (ridx) * 20)
#define USBD_EPOUT_MAXCNT_COUNT                      8
#define USBD_EPOUT_MAXCNT_MASK                       0x00000000

#define USBD_EPOUT_AMOUNT_ADDR(ridx)                 (0x00000708 + (ridx) * 20)
#define USBD_EPOUT_AMOUNT_COUNT                      8
#define USBD_EPOUT_AMOUNT_MASK                       0x00000000

#define USBD_ISOOUT_PTR_ADDR                         0x000007a0
#define USBD_ISOOUT_PTR_MASK                         0x00000000

#define USBD_ISOOUT_MAXCNT_ADDR                      0x000007a4
#define USBD_ISOOUT_MAXCNT_MASK                      0x00000000

#define USBD_ISOOUT_AMOUNT_ADDR                      0x000007a8
#define USBD_ISOOUT_AMOUNT_MASK                      0x00000000

/** Undocumented register to access internal registers @multiple */
#define USBD_INTBUS_ADDR_ADDR                        0x00000800
#define USBD_INTBUS_ADDR_MASK                        0x00000000

/** Undocumented register to access internal registers @multiple */
#define USBD_INTBUS_DATA_ADDR                        0x00000804
#define USBD_INTBUS_DATA_MASK                        0x00000000

#endif

