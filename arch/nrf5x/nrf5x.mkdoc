@section TP {nRF51/nRF52 Architecture support}

Nordic's nRF51 and nRF52 architecture support.

@parse{
arch/nrf5x/ids.h
arch/nrf5x/peripheral.h
}

@section {Drivers}

  @section {Clocks}
    Clocking in nRF5x is quite simple because most clock dependencies
    are handled automatically by hardware, and because there are only
    two clock sources, using fixed frequencies.  Nevertheless, clock
    driver handles many tedious aspects of the clocking of the device:

    @list
      @item it handles LFCLK calibration when there is no external
        crystal available,
      @item it monitors temperature to see whether to calibrate LFCLK,
      @item it tries to delay LFCLK calibration to a later time where
        HFCLK runs,
      @item it handles switching source for LFCLK when requested, and
        indicates when precision changes,
      @item it handles switching source for HFCLK when requested, and
        indicates when precision changes.
    @end list

    Clock tree is designed to be as straightforward as possible to
    use. Clock driver exports four clocks:
    @list
      @item @ref {NRF_CLOCK_LF} {Low Frequency clock, with unspecified
        precision},
      @item @ref {NRF_CLOCK_LF_PRECISE} {Low Frequency clock, with
        specified precision}, calibrated or not (depending on whether
        LFCLK source is internal RC or an external crystal),
      @item @ref {NRF_CLOCK_HF} {High Frequency clock, with
        unspecified precision},
      @item @ref {NRF_CLOCK_HF_PRECISE} {High Frequency clock, with
        specified precision}.
    @end list

    Both the low frequency and both the high frequency clocks
    described here actually are the same internal clock tree, but
    requesting the precise version enables crystal oscillator or
    calibration.  This way, in the device tree, platform designer may
    connect either the low precision or high precision clock,
    depending on needs.
  @end section

  @section {GPIO}
    GPIO controller implements both the GPIO class and the ICU class,
    so that an external peripheral can use a GPIO as an interrupt
    sink.  This feature uses GPIOTE channels in Event mode.  @see
    GPIOTE.
  @end section

  @section {PWM}
    PWM is a composite device using a timer, PPIs and GPIOTE channels.
    GPIOTE are used in Task mode.  @see GPIOTE.
  @end section

  @section {UART}
    UART is implemented as a Character Device, fully interrupt driven.
    Optionnally, nRF UART driver may also be enabled to handle the
    UART class to support dynamic port reconfiguration.

    Printk support is also implemented, it has transparent coexistence
    support with char/uart device driver on the same hardware block.

    Declaration of UART device is board-specific.
  @end section

  @section {I2C}
    Hardware I2C block is available with full interrupt support.  It
    only supports master operation, this is a hardware limitation.
  @end section

  @section {SPI}
    Hardware SPI-master block is available with full interrupt
    support.

    Slave SPI block is unsupported.
  @end section

  @section {RTC}
    RTC is supported as a Timer device.  When driver is compiled in,
    RTC1 instance is declared built-in as "rtc1".
  @end section

  @section {NVMC}
    Flash controller is implemented with two concurrent classes:
    @list
      @item Memory controller,
      @item Persistent data controller.
    @end list

    This allows to implement persistent data support and yet have
    concurrent raw block accesses.

    Flash access is polled and fully blocking when writing.  This is a
    hardware-enforced requirement.
  @end section

  @section {Timer}
    Timers are implemented as Timer devices.  When driver is enabled,
    Timer1 is instantiated as "timer1".
  @end section


  @section {AES}
    Hardware AES encrypt block is supported through a crypto driver
    which supports 4 functions:

    @list
      @item Basic AES block encrypt,
      @item a custom AES-based seedable DRBG,
      @item AES-CMAC, a keyed-hash algorithm used in Bluetooth
    @end list

    As most operations are fast and shorter than an interrupt
    round-trip, cryptographical operations use a @ref
    {dev_request_dlqueue_s} {delayed queued} to handle request from
    interruptible mode, in a busy-wait manner.
  @end section

  @section {RNG}
    Hardware Thermal noise random number generator is supported as a
    Cryptographic device yielding a random stream without context.
    Derivation compensation is enabled.

    This driver should only be used to seed another RNG.
  @end section

@end section

@section {Implementation notes}

  @section {Device register access}
    nRF5x devices all look the same and regular.  Device at address
    0x4000000 has number 0 and interrupt 0, device at address 0x40001000
    has number 1 and interrupt 1, and so on.  Inside a device register
    map, there are tasks, events, shorts, interrupt handling, and then
    configuration registers.

    This regular pattern explains why nRF5x architecture declaration
    adds an overlay on top of cpu_mem_read_32 and cpu_mem_write_32 to
    access hardware registers.  nRF5x code use the following accessors:
    @list
      @item nrf_task_trigger,
      @item nrf_event_check,
      @item nrf_event_clear,
      @item nrf_event_wait,
      @item nrf_event_wait_clear,
      @item nrf_it_is_enabled,
      @item nrf_it_set_mask,
      @item nrf_it_enable,
      @item nrf_it_enable_mask,
      @item nrf_it_disable,
      @item nrf_it_disable_mask,
      @item nrf_short_set,
      @item nrf_short_enable,
      @item nrf_short_enable_mask,
      @item nrf_short_disable,
      @item nrf_short_disable_mask,
      @item nrf_reg_get,
      @item nrf_reg_set.
    @end list

    All these accessors take device base address and task/event/register
    number as arguments.  These accessors make the code obvious about
    what the driver intends to do.

    @insert {@arch/nrf5x/ids.h} decl_inline_doc
    @insert {@arch/nrf5x/peripheral.h} decl_inline_doc

  @end section
  
  @section {PPI}
    PPIs are statically allocated by drivers as needed.  This is done
    through the @tt CONFIG_DRIVER_NRF5X_PPI_ENUM enum config token.
  @end section

  @section {GPIOTE}
    GPIOTE channels are partitioned between GPIO ICU input and PWM
    outputs.  Allocation between those two modules is static.
  @end section

  @section GPIOTE
    GPIOTE channels are partitioned between GPIO ICU input and PWM
    outputs.  Allocation between those two modules is static.
  @end section

@end section

@end section
