@section TP {nRF51/nRF52 Architecture support}

Nordic's nRF51 and nRF52 architecture support.

@section {Drivers}

  @section Clocks
    Clocking in nRF5x is quite simple because most clock dependencies
    are handled automatically by hardware, and because there are only
    two clock sources, using fixed frequencies.  Nevertheless, clock
    driver handles many tedious aspects of the clocking of the device:

    @list
      @item it handles LFCLK calibration when there is no external
        chrystal available,
      @item it monitors temperature to see whether to calibrate LFCLK,
      @item it tries to delay LFCLK calibration to a later time where
        HFCLK runs,
      @item it handles switching source for LFCLK when requested, and
        indicates when precision changes,
      @item it handles switching source for HFCLK when requested, and
        indicates when precision changes.
    @end list
  @end section

  @section GPIO
    GPIO controller implements both the GPIO class and the ICU class,
    so that an external peripheral can use a GPIO as an interrupt
    sink.  This feature uses GPIOTE channels in Event mode.  @see
    GPIOTE.
  @end section

  @section PWM
    PWM is a composite device using a timer, PPIs and GPIOTE channels.
    GPIOTE are used in Task mode.  @see GPIOTE.
  @end section

  @section UART
    UART is implemented as a Character Device, fully interrupt driven.
    Optionnally, UART class may also be enabled to handle dynamic port
    reconfiguration.

    Printk support is also implemented, it has transparent coexistence
    support with char/uart device driver on the same hardware block.

    Declaration of UART device is board-specific.
  @end section

  @section I2C
    Hardware I2C block is available with full interrupt support.  It
    only supports master operation.
  @end section

  @section SPI
    Hardware SPI-master block is available with full interrupt
    support.

    Slave SPI block is unsupported.
  @end section

  @section {RTC}
    RTC is supported as a Timer device.  When driver is compiled in,
    RTC1 instance is declared built-in as "rtc1".  RTC0 is left out of
    BLE radio driver.  User may instantiate RTC0 on its own if radio
    driver is unused.
  @end section

  @section NVMC
    Flash controller is implemented for two concurrent interfaces:
    @list
      @item Memory controller,
      @item Persistent data controller.
    @end list

    This allows to implement persistent data support and yet have
    concurrent raw block accesses.

    Flash access is polled and fully blocking when writing.  This is a
    hardware-enforced requirement.
  @end section

  @section Timer
    Timers are implemented as Timer devices.  When driver is enabled,
    Timer1 is instantiated as "timer1".
  @end section

  @section {BLE Radio}
    BLE Radio driver implements various network layers, depending on
    the @tt libble configuration:

    @list
      @item Advertising layer,
      @item Scanner layer (Oberver, Scanner, Initiator),
      @item Slave,
      @item Master.
    @end list

    Link-layer (LL demux, Crypto and LLCP) is handled through generic
    libble network layers.

    This driver uses 3 hardware blocks: Radio, RTC0 and Timer0.
    Timer0 and RTC0 blocks may not be changed to others as there are
    some hardwired PPIs between them.

    Nordic assigns Random BLE addresses to its chips.  Driver
    retrieves device address from FICR.
  @end section
  
  @section {AES}
    Hardware AES encrypt block is supported through a crypto driver
    which supports 4 functions:

    @list
      @item Basic AES block encrypt,
      @item a custom AES-based seedable DRBG,
      @item BLE-CCM mode (it only supports CCM operation with BLE-specific parameters),
      @item AES-CMAC, a keyed-hash algorithm used in Bluetooth
    @end list

    As most operations are fast and shorter than an interrupt
    round-trip, cryptographical operations use a delayed queued to
    handle request from interruptible mode, in a busy-wait manner.
  @end section

  @section {RNG}
    Hardware Thermal noise random number generator is supported as a
    Cryptographic device yielding a random stream without context.
    Derivation compensation is enabled.

    This driver should only be used to seed another RNG.
  @end section

  @section ADC
    ADC is handled through relevant Valio subclass.  Analog pin
    configuration is done at driver instantiation time.
  @end section

@end section

@section {Boards}

  @section {nRF51822-Dongle}
    PCA10000 is the most simple board.  UART is driven as a character
    device, RGB LED can be controlled through GPIOs or PWM drivers.
  @end section

  @section {nRF51822-DK nRFgo boards}
    PCA10004 and PCA10005 are actually the same boards from a software
    point of view.  Only difference is on the PCB antenna vs. SMA connector.

    Their support is quite basic, connection with hardware on the
    nRFgo mother board has not been explored.
  @end section

  @section {nRF51822-mKit}
    This board is mBed-based development board for nRF51.  It has all
    IO ports routed to external headers, user may use IOs as needed.
    UART is routed to USB controller and declared.  All other IOs
    (including LEDs and buttons) are left to user code.
  @end section

  @section {nRF51-SmartRemote}
    PCA20002 is daugther-board for SmartRemote.  This board only
    contains the nRF51 chip and an I2C extender (PCA9557).  It is
    meant to be plugged to a SmartRemote motherboard.

    In PCA20002 defintion, all SmartRemote peripherals are declared as
    well.  Not all of them are driven by MutekH yet, though.
  @end section

@end section

@section {Implementation notes}

  @section {Device register access}
    nRF5x devices all look the same and regular.  Device at address
    0x4000000 has number 0 and interrupt 0, device at address 0x40001000
    has number 1 and interrupt 1, and so on.  Inside a device register
    map, there are tasks, events, shorts, interrupt handling, and then
    configuration registers.

    This regular pattern explains why nRF5x architecture declaration
    adds an overlay on top of cpu_mem_read_32 and cpu_mem_write_32 to
    access hardware registers.  nRF5x code use the following accessors:
    @list
      @item nrf_task_trigger,
      @item nrf_event_check,
      @item nrf_event_clear,
      @item nrf_event_wait,
      @item nrf_event_wait_clear,
      @item nrf_it_is_enabled,
      @item nrf_it_set_mask,
      @item nrf_it_enable,
      @item nrf_it_enable_mask,
      @item nrf_it_disable,
      @item nrf_it_disable_mask,
      @item nrf_short_set,
      @item nrf_short_enable,
      @item nrf_short_enable_mask,
      @item nrf_short_disable,
      @item nrf_short_disable_mask,
      @item nrf_reg_get,
      @item nrf_reg_set.
    @end list

    All these accessors take device base address and task/event/register
    number as arguments.  These accessors make the code obvious about
    what the driver intends to do.
  @end section
  
  @section PPI
    PPIs are statically allocated by drivers as needed.  This is done
    through the @tt CONFIG_DRIVER_NRF5X_PPI_ENUM enum config token.
  @end section

  @section GPIOTE
    GPIOTE channels are partitioned between GPIO ICU input and PWM
    outputs.  Allocation between those two modules is static.
  @end section

@end section
@end section
