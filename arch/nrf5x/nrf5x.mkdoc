@section TP {nRF51 Architecture support}

Nordic's nRF51 architecture support.

@parse{
arch/nrf5x/ids.h
arch/nrf5x/peripheral.h
}

@section {Drivers}

  @section {Clocks}
    Clocking in nRF51 is quite simple because most clock dependencies
    are handled automatically by hardware, and because there are only
    two clock sources, using fixed frequencies.  Nevertheless, clock
    driver handles many tedious aspects of the clocking of the device:

    @list
      @item it handles LFCLK calibration when there is no external
        crystal available,
      @item it monitors temperature to see whether to calibrate LFCLK,
      @item it tries to delay LFCLK calibration to a later time where
        HFCLK runs,
      @item it handles switching source for LFCLK when requested, and
        indicates when precision changes,
      @item it handles switching source for HFCLK when requested, and
        indicates when precision changes.
    @end list

    Clock tree is designed to be as straightforward as possible to
    use. Clock driver exports four clocks:
    @list
      @item @ref {NRF_CLOCK_LF} {Low Frequency clock, with unspecified
        precision},
      @item @ref {NRF_CLOCK_LF_PRECISE} {Low Frequency clock, with
        specified precision}, calibrated or not (depending on whether
        LFCLK source is internal RC or an external crystal),
      @item @ref {NRF_CLOCK_HF} {High Frequency clock, with
        unspecified precision},
      @item @ref {NRF_CLOCK_HF_PRECISE} {High Frequency clock, with
        specified precision}.
    @end list

    Both the low frequency and both the high frequency clocks
    described here actually are the same internal clock tree, but
    requesting the precise version enables crystal oscillator or
    calibration.  This way, in the device tree, platform designer may
    connect either the low precision or high precision clock,
    depending on needs.
  @end section
  
@end section

@section {Implementation notes}

  @section {Device register access}
    nRF51 devices all look the same and regular.  Device at address
    0x4000000 has number 0 and interrupt 0, device at address 0x40001000
    has number 1 and interrupt 1, and so on.  Inside a device register
    map, there are tasks, events, shorts, interrupt handling, and then
    configuration registers.

    This regular pattern explains why nRF51 architecture declaration
    adds an overlay on top of cpu_mem_read_32 and cpu_mem_write_32 to
    access hardware registers.  nRF51 code use the following accessors:
    @list
      @item nrf_task_trigger,
      @item nrf_event_check,
      @item nrf_event_clear,
      @item nrf_event_wait,
      @item nrf_event_wait_clear,
      @item nrf_it_is_enabled,
      @item nrf_it_set_mask,
      @item nrf_it_enable,
      @item nrf_it_enable_mask,
      @item nrf_it_disable,
      @item nrf_it_disable_mask,
      @item nrf_short_set,
      @item nrf_short_enable,
      @item nrf_short_enable_mask,
      @item nrf_short_disable,
      @item nrf_short_disable_mask,
      @item nrf_reg_get,
      @item nrf_reg_set.
    @end list

    All these accessors take device base address and task/event/register
    number as arguments.  These accessors make the code obvious about
    what the driver intends to do.

    @insert {@arch/nrf5x/ids.h} decl_inline_doc
    @insert {@arch/nrf5x/peripheral.h} decl_inline_doc

  @end section
  
  @section {PPI}
    PPIs are statically allocated by drivers as needed.  This is done
    through the @tt CONFIG_DRIVER_NRF5X_PPI_ENUM enum config token.
  @end section

@end section
@end section
