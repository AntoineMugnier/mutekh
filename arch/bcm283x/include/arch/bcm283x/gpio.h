/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -o cdefs -O bcm283x/gpio_regs.h cdefs_use_reg_mask=1
*/

#ifndef _BCM283X_GPIO_BFGEN_DEFS_
#define _BCM283X_GPIO_BFGEN_DEFS_

/** The function select registers are used to define the operation of the
   general-purpose I/O pins. Each of the 54 GPIO pins has at least two
   alternative functions. The FSEL{n} field determines the functionality of the
   nth GPIO pin. All unused alternative function lines are tied to ground and
   will output a “0” if selected. All pins resets to normal GPIO input
   operation. @multiple */
#define BCM283X_GPIO_GPFSEL_ADDR(ridx)               (0x00000000 + (ridx) * 4)
#define BCM283X_GPIO_GPFSEL_COUNT                    6
#define BCM283X_GPIO_GPFSEL_MASK                     0x3fffffff
  #define BCM283X_GPIO_GPFSEL_FSEL_COUNT           10
  #define BCM283X_GPIO_GPFSEL_FSEL(fidx, v)        ((BCM283X_GPIO_GPFSEL_FSEL_##v) << ((fidx) * 3 + 0))
  #define BCM283X_GPIO_GPFSEL_FSEL_SET(fidx, x, v) do { (x) = (((x) & ~(0x7 << ((fidx) * 3))) | ((BCM283X_GPIO_GPFSEL_FSEL_##v) << ((fidx) * 3 + 0))); } while(0)
  #define BCM283X_GPIO_GPFSEL_FSEL_GET(fidx, x)    (((x) >> ((fidx) * 3 + 0)) & 0x7)
  #define BCM283X_GPIO_GPFSEL_FSEL_INPUT           0x00000000
  #define BCM283X_GPIO_GPFSEL_FSEL_OUTPUT          0x00000001
  #define BCM283X_GPIO_GPFSEL_FSEL_FUNCTION5       0x00000002
  #define BCM283X_GPIO_GPFSEL_FSEL_FUNCTION4       0x00000003
  #define BCM283X_GPIO_GPFSEL_FSEL_FUNCTION0       0x00000004
  #define BCM283X_GPIO_GPFSEL_FSEL_FUNCTION1       0x00000005
  #define BCM283X_GPIO_GPFSEL_FSEL_FUNCTION2       0x00000006
  #define BCM283X_GPIO_GPFSEL_FSEL_FUNCTION3       0x00000007

/** The output set registers are used to set a GPIO pin. The SET{n} field defines
   the respective GPIO pin to set, writing a “0” to the field has no effect.
   If the GPIO pin is being used as in input (by default) then the value in the
   SET{n} field is ignored. However, if the pin is subsequently defined as an
   output then the bit will be set according to the last set/clear operation.
   Separating the set and clear functions removes the need for read-modify-write
   operations @multiple */
#define BCM283X_GPIO_GPSET_ADDR(ridx)                (0x0000001c + (ridx) * 4)
#define BCM283X_GPIO_GPSET_COUNT                     2
#define BCM283X_GPIO_GPSET_MASK                      0xffffffff
  #define BCM283X_GPIO_GPSET_SET_COUNT             32
  #define BCM283X_GPIO_GPSET_SET(fidx)             (0x00000001 << ((fidx)))

/** The output clear registers are used to clear a GPIO pin. The CLR{n} field
   defines the respective GPIO pin to clear, writing a “0” to the field has
   no effect. If the GPIO pin is being used as in input (by default) then the
   value in the CLR{n} field is ignored. However, if the pin is subsequently
   defined as an output then the bit will be cleared according to the last
   set/clear operation. Separating the set and clear functions removes the need
   for read-modify-write operations @multiple */
#define BCM283X_GPIO_GPCLR_ADDR(ridx)                (0x00000028 + (ridx) * 4)
#define BCM283X_GPIO_GPCLR_COUNT                     2
#define BCM283X_GPIO_GPCLR_MASK                      0xffffffff
  #define BCM283X_GPIO_GPCLR_CLR_COUNT             32
  #define BCM283X_GPIO_GPCLR_CLR(fidx)             (0x00000001 << ((fidx)))

/** The pin level registers return the actual value of the pin. The LEV{n} field
   gives the value of the respective GPIO pin. @multiple */
#define BCM283X_GPIO_GPLEV_ADDR(ridx)                (0x00000034 + (ridx) * 4)
#define BCM283X_GPIO_GPLEV_COUNT                     2
#define BCM283X_GPIO_GPLEV_MASK                      0xffffffff
  #define BCM283X_GPIO_GPLEV_LEV_COUNT             32
  #define BCM283X_GPIO_GPLEV_LEV(fidx)             (0x00000001 << ((fidx)))

/** The event detect status registers are used to record level and edge events on
   the GPIO pins. The relevant bit in the event detect status registers is set
   whenever: 1) an edge is detected that matches the type of edge programmed in
   the rising/falling edge detect enable registers, or 2) a level is detected
   that matches the type of level programmed in the high/low level detect enable
   registers. The bit is cleared by writing a “1” to the relevant bit. The
   interrupt controller can be programmed to interrupt the processor when any of
   the status bits are set. The GPIO peripheral has three dedicated interrupt
   lines. Each GPIO bank can generate an independent interrupt. The third line
   generates a single interrupt whenever any bit is set. @multiple */
#define BCM283X_GPIO_GPEDS_ADDR(ridx)                (0x00000040 + (ridx) * 4)
#define BCM283X_GPIO_GPEDS_COUNT                     2
#define BCM283X_GPIO_GPEDS_MASK                      0xffffffff
  #define BCM283X_GPIO_GPEDS_EDS_COUNT             32
  #define BCM283X_GPIO_GPEDS_EDS(fidx, v)          ((BCM283X_GPIO_GPEDS_EDS_##v) << ((fidx) + 0))
  #define BCM283X_GPIO_GPEDS_EDS_SET(fidx, x, v)   do { (x) = (((x) & ~(0x1 << ((fidx)))) | ((BCM283X_GPIO_GPEDS_EDS_##v) << ((fidx) + 0))); } while(0)
  #define BCM283X_GPIO_GPEDS_EDS_GET(fidx, x)      (((x) >> ((fidx) + 0)) & 0x1)
  #define BCM283X_GPIO_GPEDS_EDS_NONE              0x00000000
  #define BCM283X_GPIO_GPEDS_EDS_EVENT             0x00000001

/** The rising edge detect enable registers define the pins for which a rising
   edge transition sets a bit in the event detect status registers (GPEDSn). When
   the relevant bits are set in both the GPRENn and GPFENn registers, any
   transition (1 to 0 and 0 to 1) will set a bit in the GPEDSn registers. The
   GPRENn registers use synchronous edge detection. This means the input signal
   is sampled using the system clock and then it is looking for a “011”
   pattern on the sampled signal. This has the effect of suppressing glitches.
   @multiple */
#define BCM283X_GPIO_GPREN_ADDR(ridx)                (0x0000004c + (ridx) * 4)
#define BCM283X_GPIO_GPREN_COUNT                     2
#define BCM283X_GPIO_GPREN_MASK                      0xffffffff
  #define BCM283X_GPIO_GPREN_REN_COUNT             32
  #define BCM283X_GPIO_GPREN_REN(fidx, v)          ((BCM283X_GPIO_GPREN_REN_##v) << ((fidx) + 0))
  #define BCM283X_GPIO_GPREN_REN_SET(fidx, x, v)   do { (x) = (((x) & ~(0x1 << ((fidx)))) | ((BCM283X_GPIO_GPREN_REN_##v) << ((fidx) + 0))); } while(0)
  #define BCM283X_GPIO_GPREN_REN_GET(fidx, x)      (((x) >> ((fidx) + 0)) & 0x1)
  #define BCM283X_GPIO_GPREN_REN_DISABLED          0x00000000
  #define BCM283X_GPIO_GPREN_REN_ENABLED           0x00000001

/** The rising edge detect enable registers define the pins for which a rising
   edge transition sets a bit in the event detect status registers (GPEDSn). When
   the relevant bits are set in both the GPRENn and GPFENn registers, any
   transition (1 to 0 and 0 to 1) will set a bit in the GPEDSn registers. The
   GPRENn registers use synchronous edge detection. This means the input signal
   is sampled using the system clock and then it is looking for a “011”
   pattern on the sampled signal. This has the effect of suppressing glitches.
   @multiple */
#define BCM283X_GPIO_GPFEN_ADDR(ridx)                (0x00000058 + (ridx) * 4)
#define BCM283X_GPIO_GPFEN_COUNT                     2
#define BCM283X_GPIO_GPFEN_MASK                      0xffffffff
  #define BCM283X_GPIO_GPFEN_FEN_COUNT             32
  #define BCM283X_GPIO_GPFEN_FEN(fidx, v)          ((BCM283X_GPIO_GPFEN_FEN_##v) << ((fidx) + 0))
  #define BCM283X_GPIO_GPFEN_FEN_SET(fidx, x, v)   do { (x) = (((x) & ~(0x1 << ((fidx)))) | ((BCM283X_GPIO_GPFEN_FEN_##v) << ((fidx) + 0))); } while(0)
  #define BCM283X_GPIO_GPFEN_FEN_GET(fidx, x)      (((x) >> ((fidx) + 0)) & 0x1)
  #define BCM283X_GPIO_GPFEN_FEN_DISABLED          0x00000000
  #define BCM283X_GPIO_GPFEN_FEN_ENABLED           0x00000001

/** The high level detect enable registers define the pins for which a high level
   sets a bit in the event detect status register (GPEDSn). If the pin is still
   high when an attempt is made to clear the status bit in GPEDSn then the status
   bit will remain set. @multiple */
#define BCM283X_GPIO_GPHEN_ADDR(ridx)                (0x00000064 + (ridx) * 4)
#define BCM283X_GPIO_GPHEN_COUNT                     2
#define BCM283X_GPIO_GPHEN_MASK                      0xffffffff
  #define BCM283X_GPIO_GPHEN_HEN_COUNT             32
  #define BCM283X_GPIO_GPHEN_HEN(fidx, v)          ((BCM283X_GPIO_GPHEN_HEN_##v) << ((fidx) + 0))
  #define BCM283X_GPIO_GPHEN_HEN_SET(fidx, x, v)   do { (x) = (((x) & ~(0x1 << ((fidx)))) | ((BCM283X_GPIO_GPHEN_HEN_##v) << ((fidx) + 0))); } while(0)
  #define BCM283X_GPIO_GPHEN_HEN_GET(fidx, x)      (((x) >> ((fidx) + 0)) & 0x1)
  #define BCM283X_GPIO_GPHEN_HEN_DISABLED          0x00000000
  #define BCM283X_GPIO_GPHEN_HEN_ENABLED           0x00000001

/** The low level detect enable registers define the pins for which a low level
   sets a bit in the event detect status register (GPEDSn). If the pin is still
   low when an attempt is made to clear the status bit in GPEDSn then the status
   bit will remain set. @multiple */
#define BCM283X_GPIO_GPLEN_ADDR(ridx)                (0x00000070 + (ridx) * 4)
#define BCM283X_GPIO_GPLEN_COUNT                     2
#define BCM283X_GPIO_GPLEN_MASK                      0xffffffff
  #define BCM283X_GPIO_GPLEN_LEN_COUNT             32
  #define BCM283X_GPIO_GPLEN_LEN(fidx, v)          ((BCM283X_GPIO_GPLEN_LEN_##v) << ((fidx) + 0))
  #define BCM283X_GPIO_GPLEN_LEN_SET(fidx, x, v)   do { (x) = (((x) & ~(0x1 << ((fidx)))) | ((BCM283X_GPIO_GPLEN_LEN_##v) << ((fidx) + 0))); } while(0)
  #define BCM283X_GPIO_GPLEN_LEN_GET(fidx, x)      (((x) >> ((fidx) + 0)) & 0x1)
  #define BCM283X_GPIO_GPLEN_LEN_DISABLED          0x00000000
  #define BCM283X_GPIO_GPLEN_LEN_ENABLED           0x00000001

/** The asynchronous rising edge detect enable registers define the pins for
   which a asynchronous rising edge transition sets a bit in the event detect
   status registers (GPEDSn). Asynchronous means the incoming signal is not
   sampled by the system clock. As such rising edges of very short duration can
   be detected. @multiple */
#define BCM283X_GPIO_GPAREN_ADDR(ridx)               (0x0000007c + (ridx) * 4)
#define BCM283X_GPIO_GPAREN_COUNT                    2
#define BCM283X_GPIO_GPAREN_MASK                     0xffffffff
  #define BCM283X_GPIO_GPAREN_AREN_COUNT           32
  #define BCM283X_GPIO_GPAREN_AREN(fidx, v)        ((BCM283X_GPIO_GPAREN_AREN_##v) << ((fidx) + 0))
  #define BCM283X_GPIO_GPAREN_AREN_SET(fidx, x, v) do { (x) = (((x) & ~(0x1 << ((fidx)))) | ((BCM283X_GPIO_GPAREN_AREN_##v) << ((fidx) + 0))); } while(0)
  #define BCM283X_GPIO_GPAREN_AREN_GET(fidx, x)    (((x) >> ((fidx) + 0)) & 0x1)
  #define BCM283X_GPIO_GPAREN_AREN_DISABLED        0x00000000
  #define BCM283X_GPIO_GPAREN_AREN_ENABLED         0x00000001

/** The asynchronous falling edge detect enable registers define the pins for
   which a asynchronous falling edge transition sets a bit in the event detect
   status registers (GPEDSn). Asynchronous means the incoming signal is not
   sampled by the system clock. As such falling edges of very short duration can
   be detected. @multiple */
#define BCM283X_GPIO_GPAFEN_ADDR(ridx)               (0x00000088 + (ridx) * 4)
#define BCM283X_GPIO_GPAFEN_COUNT                    2
#define BCM283X_GPIO_GPAFEN_MASK                     0xffffffff
  #define BCM283X_GPIO_GPAFEN_AFEN_COUNT           32
  #define BCM283X_GPIO_GPAFEN_AFEN(fidx, v)        ((BCM283X_GPIO_GPAFEN_AFEN_##v) << ((fidx) + 0))
  #define BCM283X_GPIO_GPAFEN_AFEN_SET(fidx, x, v) do { (x) = (((x) & ~(0x1 << ((fidx)))) | ((BCM283X_GPIO_GPAFEN_AFEN_##v) << ((fidx) + 0))); } while(0)
  #define BCM283X_GPIO_GPAFEN_AFEN_GET(fidx, x)    (((x) >> ((fidx) + 0)) & 0x1)
  #define BCM283X_GPIO_GPAFEN_AFEN_DISABLED        0x00000000
  #define BCM283X_GPIO_GPAFEN_AFEN_ENABLED         0x00000001

/** The GPIO Pull-up/down Register controls the actuation of the internal
   pull-up/down control line to ALL the GPIO pins. This register must be used in
   conjunction with the 2 GPPUDCLKn registers. Note that it is not possible to
   read back the current Pull-up/down settings and so it is the users’
   responsibility to ‘remember’ which pull-up/downs are active. The reason
   for this is that GPIO pull-ups are maintained even in power-down mode when the
   core is off, when all register contents is lost. The Alternate function table
   also has the pull state which is applied after a power down. @multiple */
#define BCM283X_GPIO_GPPUD_ADDR                      0x00000094
#define BCM283X_GPIO_GPPUD_MASK                      0x00000003
  #define BCM283X_GPIO_GPPUD_PUD(v)                ((BCM283X_GPIO_GPPUD_PUD_##v) << 0)
  #define BCM283X_GPIO_GPPUD_PUD_SET(x, v)         do { (x) = (((x) & ~0x3) | ((BCM283X_GPIO_GPPUD_PUD_##v) << 0)); } while(0)
  #define BCM283X_GPIO_GPPUD_PUD_GET(x)            (((x) >> 0) & 0x3)
    #define BCM283X_GPIO_GPPUD_PUD_OFF               0x00000000
    #define BCM283X_GPIO_GPPUD_PUD_PULLDOWN          0x00000001
    #define BCM283X_GPIO_GPPUD_PUD_PULLUP            0x00000002

/** The GPIO Pull-up/down Clock Registers control the actuation of internal
   pull-downs on the respective GPIO pins. These registers must be used in
   conjunction with the GPPUD register to effect GPIO Pull-up/down changes. The
   following sequence of events is required: 1. Write to GPPUD to set the
   required control signal (i.e. Pull-up or Pull-Down or neither to remove the
   current Pull-up/down) 2. Wait 150 cycles – this provides the required set-up
   time for the control signal 3. Write to GPPUDCLK0/1 to clock the control
   signal into the GPIO pads you wish to modify – NOTE only the pads which
   receive a clock will be modified, all others will retain their previous state.
   4. Wait 150 cycles – this provides the required hold time for the control
   signal 5. Write to GPPUD to remove the control signal 6. Write to GPPUDCLK0/1
   to remove the clock @multiple */
#define BCM283X_GPIO_GPPUDCLK_ADDR(ridx)             (0x00000098 + (ridx) * 4)
#define BCM283X_GPIO_GPPUDCLK_COUNT                  2
#define BCM283X_GPIO_GPPUDCLK_MASK                   0xffffffff
  #define BCM283X_GPIO_GPPUDCLK_PUDCLK_COUNT       32
  #define BCM283X_GPIO_GPPUDCLK_PUDCLK(fidx, v)    ((BCM283X_GPIO_GPPUDCLK_PUDCLK_##v) << ((fidx) + 0))
  #define BCM283X_GPIO_GPPUDCLK_PUDCLK_SET(fidx, x, v) do { (x) = (((x) & ~(0x1 << ((fidx)))) | ((BCM283X_GPIO_GPPUDCLK_PUDCLK_##v) << ((fidx) + 0))); } while(0)
  #define BCM283X_GPIO_GPPUDCLK_PUDCLK_GET(fidx, x) (((x) >> ((fidx) + 0)) & 0x1)
  #define BCM283X_GPIO_GPPUDCLK_PUDCLK_NONE        0x00000000
  #define BCM283X_GPIO_GPPUDCLK_PUDCLK_CLKASSERT   0x00000001

#endif

