#include "mb_interface.h"		// generated by LibGen
#include <device/device.h>
#include <device/driver.h>

#include "platform.h"

uint32_t	mtk_TmrCtr_Initialize(mtk_XTmrCtr * InstancePtr, uint32_t  DeviceId);
void 		mtk_TmrCtr_Interrupt_Clear(mtk_XTmrCtr * InstancePtr, uint32_t  DeviceId);
void 		__my_it_handler(void);

uint32_t cpt_it = 0;
mtk_XTmrCtr my_struct_timer;
static uint32_t cpt_my_it_handler = 0;

/**
*	Interrupt handler.
*/
static CPU_INTERRUPT_HANDLER(fct_it)
{
	cpt_it++;
	 __my_it_handler();
}

/**
*	Initialize the timer used to count OS ticks and set the interrupt handler.
*/
void arch_specific_init()
{
   mtk_TmrCtr_Initialize(&my_struct_timer, XPAR_XPS_TIMER_1_DEVICE_ID);
   /* pour le test:il ne faut pas avoir d'IT sans avoir positionné la routine cpu_interrupt_handler */
   cpu_interrupt_sethandler(fct_it);
}


/**
*	Interrupt handler. Clear the interrupt.
*/
void __my_it_handler(void)
{
	mtk_XTmrCtr *my_struct_timer;

	printk(" Acq IT reçue !!\n");
	cpt_my_it_handler++;
	mtk_TmrCtr_Interrupt_Clear(my_struct_timer, XPAR_XPS_TIMER_1_DEVICE_ID);
}


/**
*	Timer initialization function.
*/
uint32_t mtk_TmrCtr_Initialize(mtk_XTmrCtr * InstancePtr, uint32_t  DeviceId)
{
	uint32_t CounterValue = 0x000f4240 ;//0x000f4240 = 10ms - 20ms=0x001e8480 - 0x989680=100ms
	uint8_t *intc_adr;
	uint32_t reg_tmp = 0;
	/*
	 * Disable IRQ output signal
	 * Disable all interrupt sources
	 * Acknowledge all sources
	 */
	intc_adr = (uint8_t *)XPAR_XPS_INTC_0_BASEADDR;

	*(intc_adr + XIN_MER_OFFSET) = 0;
	*(intc_adr + XIN_IER_OFFSET) = 0;
	*(intc_adr + XIN_IAR_OFFSET) = 0xffffffff;
	*(intc_adr + XIN_MER_OFFSET) = XIN_INT_HARDWARE_ENABLE_MASK | XIN_INT_MASTER_ENABLE_MASK;//0x3

	 /* Set some default values */
	InstancePtr->BaseAddress = 	XPAR_XPS_TIMER_1_BASEADDR;
	InstancePtr->Handler = NULL;
	InstancePtr->CallBackRef = NULL;

	/* Set the load register to 0 */
	WriteReg(InstancePtr->BaseAddress, TmrCtrNumber,
			XTC_TLR_OFFSET, 0); /* offset 4 */

	reg_tmp |= XTC_CSR_INT_OCCURED_MASK; /* 0x00000100 */

	/* Reset the timer and the interrupt, the reset bit will need to be cleared after this */
	WriteReg(InstancePtr->BaseAddress, TmrCtrNumber,
			XTC_TCSR_OFFSET,	/* offset 0 */
			reg_tmp ); /* valeur  0x100 */

	WriteReg(InstancePtr->BaseAddress, TmrCtrNumber,
			  XTC_TLR_OFFSET, CounterValue); /* offset 4 */

	WriteReg(InstancePtr->BaseAddress, TmrCtrNumber,
			XTC_TCSR_OFFSET,	/* offset 0 */
			XTC_CSR_LOAD_MASK);  /* 0x00000020 */

	/* Set the control/status register to complete initialization by
	clearing the reset bit which was just set */
	WriteReg(InstancePtr->BaseAddress, TmrCtrNumber,
			XTC_TCSR_OFFSET, 0);/* offset 0 */

	reg_tmp =  XTC_CSR_ENABLE_INT_MASK | XTC_CSR_AUTO_RELOAD_MASK | XTC_CSR_DOWN_COUNT_MASK; //0x00000052;

	WriteReg(InstancePtr->BaseAddress, TmrCtrNumber,
			  XTC_TCSR_OFFSET, reg_tmp); /* offset 0,valeur 0x00000052 */

	*(intc_adr + XIN_IER_OFFSET) |= 1; /* validation IT 0 pour timer */

	ReadReg(InstancePtr->BaseAddress,TmrCtrNumber, XTC_TCSR_OFFSET, reg_tmp);

	reg_tmp |= XTC_CSR_ENABLE_TMR_MASK;

	 /* Remove the reset condition such that the timer counter starts running
	    with the value loaded from the compare register */
	WriteReg(InstancePtr->BaseAddress, 0, XTC_TCSR_OFFSET, reg_tmp);/* offset 0 valeur 0x00000080 */

	return 0;
}


/**
*	Clear timer interrupt.
*/
void mtk_TmrCtr_Interrupt_Clear(mtk_XTmrCtr * InstancePtr, uint32_t  DeviceId)
{
	uint32_t reg_tmp = 0;

	ReadReg( XPAR_XPS_TIMER_1_BASEADDR, TmrCtrNumber, XTC_TCSR_OFFSET, reg_tmp);
	reg_tmp |= XTC_CSR_INT_OCCURED_MASK;	// 0x00000100
	WriteReg(XPAR_XPS_TIMER_1_BASEADDR,TmrCtrNumber,XTC_TCSR_OFFSET, reg_tmp);

	uint8_t *intc_adr ;
	intc_adr = (uint8_t *)XPAR_XPS_INTC_0_BASEADDR;
	*(intc_adr + XIN_IAR_OFFSET) = 0x1;
}

