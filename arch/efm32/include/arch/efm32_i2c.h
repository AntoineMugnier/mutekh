/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -o cdefs cdefs_use_reg_mask=1 cdefs_use_field_setval=1                \
     -I ../fbxhome/software/bitfields/efm32_i2c.bf cdefs_use_field_shift=1     \
     cdefs_use_field_shifted_mask=1 cdefs_sfx_field_shifter=_SHIFT_VAL
*/

#ifndef _EFM32_I2C_BFGEN_DEFS_
#define _EFM32_I2C_BFGEN_DEFS_

#define EFM32_I2C_CTRL_ADDR                          0x00000000
#define EFM32_I2C_CTRL_MASK                          0x0007b37f
/** Use this bit to enable or disable the I C module. @multiple */
  #define EFM32_I2C_CTRL_EN                        0x00000001
  #define EFM32_I2C_CTRL_EN_SHIFT                  0
/** Set this bit to allow the device to be selected as an I C slave. @multiple */
  #define EFM32_I2C_CTRL_SLAVE                     0x00000002
  #define EFM32_I2C_CTRL_SLAVE_SHIFT               1
  #define EFM32_I2C_CTRL_SLAVE_SHIFT_VAL(v)        ((EFM32_I2C_CTRL_SLAVE_##v) << 1)
  #define EFM32_I2C_CTRL_SLAVE_SET(x, v)           do { (x) = (((x) & ~0x2) | ((EFM32_I2C_CTRL_SLAVE_##v) << 1)); } while(0)
  #define EFM32_I2C_CTRL_SLAVE_SETVAL(x, v)        do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define EFM32_I2C_CTRL_SLAVE_GET(x)              (((x) >> 1) & 0x1)
    #define EFM32_I2C_CTRL_SLAVE_NOT_SLAVE           0x00000000
    #define EFM32_I2C_CTRL_SLAVE_SLAVE               0x00000001
/** Set to enable automatic acknowledges. @multiple */
  #define EFM32_I2C_CTRL_AUTOACK                   0x00000004
  #define EFM32_I2C_CTRL_AUTOACK_SHIFT             2
/** Write to 1 to make a master transmitter send a STOP when no more data is
   available for transmission. @multiple */
  #define EFM32_I2C_CTRL_AUTOSE                    0x00000008
  #define EFM32_I2C_CTRL_AUTOSE_SHIFT              3
  #define EFM32_I2C_CTRL_AUTOSE_SHIFT_VAL(v)       ((EFM32_I2C_CTRL_AUTOSE_##v) << 3)
  #define EFM32_I2C_CTRL_AUTOSE_SET(x, v)          do { (x) = (((x) & ~0x8) | ((EFM32_I2C_CTRL_AUTOSE_##v) << 3)); } while(0)
  #define EFM32_I2C_CTRL_AUTOSE_SETVAL(x, v)       do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define EFM32_I2C_CTRL_AUTOSE_GET(x)             (((x) >> 3) & 0x1)
    #define EFM32_I2C_CTRL_AUTOSE_MANUAL             0x00000000
    #define EFM32_I2C_CTRL_AUTOSE_AUTOMATIC          0x00000001
/** Write to 1 to make a master transmitter send a STOP when a NACK is received
   from a slave. @multiple */
  #define EFM32_I2C_CTRL_AUTOSN                    0x00000010
  #define EFM32_I2C_CTRL_AUTOSN_SHIFT              4
  #define EFM32_I2C_CTRL_AUTOSN_SHIFT_VAL(v)       ((EFM32_I2C_CTRL_AUTOSN_##v) << 4)
  #define EFM32_I2C_CTRL_AUTOSN_SET(x, v)          do { (x) = (((x) & ~0x10) | ((EFM32_I2C_CTRL_AUTOSN_##v) << 4)); } while(0)
  #define EFM32_I2C_CTRL_AUTOSN_SETVAL(x, v)       do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define EFM32_I2C_CTRL_AUTOSN_GET(x)             (((x) >> 4) & 0x1)
    #define EFM32_I2C_CTRL_AUTOSN_NO_AUTOMATOC       0x00000000
    #define EFM32_I2C_CTRL_AUTOSN_AUTOMATIC          0x00000001
/** A master or slave will not release the bus upon losing arbitration. @multiple
   */
  #define EFM32_I2C_CTRL_ARBDIS                    0x00000020
  #define EFM32_I2C_CTRL_ARBDIS_SHIFT              5
  #define EFM32_I2C_CTRL_ARBDIS_SHIFT_VAL(v)       ((EFM32_I2C_CTRL_ARBDIS_##v) << 5)
  #define EFM32_I2C_CTRL_ARBDIS_SET(x, v)          do { (x) = (((x) & ~0x20) | ((EFM32_I2C_CTRL_ARBDIS_##v) << 5)); } while(0)
  #define EFM32_I2C_CTRL_ARBDIS_SETVAL(x, v)       do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define EFM32_I2C_CTRL_ARBDIS_GET(x)             (((x) >> 5) & 0x1)
    #define EFM32_I2C_CTRL_ARBDIS_RELEASED           0x00000000
    #define EFM32_I2C_CTRL_ARBDIS_PROCEED            0x00000001
/** Set to enable address match on general call in addition to the programmed
   slave address. @multiple */
  #define EFM32_I2C_CTRL_GCAMEN                    0x00000040
  #define EFM32_I2C_CTRL_GCAMEN_SHIFT              6
  #define EFM32_I2C_CTRL_GCAMEN_SHIFT_VAL(v)       ((EFM32_I2C_CTRL_GCAMEN_##v) << 6)
  #define EFM32_I2C_CTRL_GCAMEN_SET(x, v)          do { (x) = (((x) & ~0x40) | ((EFM32_I2C_CTRL_GCAMEN_##v) << 6)); } while(0)
  #define EFM32_I2C_CTRL_GCAMEN_SETVAL(x, v)       do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
  #define EFM32_I2C_CTRL_GCAMEN_GET(x)             (((x) >> 6) & 0x1)
    #define EFM32_I2C_CTRL_GCAMEN_IDLE_LOW           0x00000000
    #define EFM32_I2C_CTRL_GCAMEN_IDLE_HIGH          0x00000001
/** Determines the ratio between the low and high parts of the clock signal
   generated on SCL as master. @multiple */
  #define EFM32_I2C_CTRL_CLHR                      0x00000300
  #define EFM32_I2C_CTRL_CLHR_SHIFT                8
  #define EFM32_I2C_CTRL_CLHR_SHIFT_VAL(v)         ((EFM32_I2C_CTRL_CLHR_##v) << 8)
  #define EFM32_I2C_CTRL_CLHR_SET(x, v)            do { (x) = (((x) & ~0x300) | ((EFM32_I2C_CTRL_CLHR_##v) << 8)); } while(0)
  #define EFM32_I2C_CTRL_CLHR_SETVAL(x, v)         do { (x) = (((x) & ~0x300) | ((v) << 8)); } while(0)
  #define EFM32_I2C_CTRL_CLHR_GET(x)               (((x) >> 8) & 0x3)
    #define EFM32_I2C_CTRL_CLHR_STANDARD             0x00000000
    #define EFM32_I2C_CTRL_CLHR_ASYMMETRIC           0x00000001
    #define EFM32_I2C_CTRL_CLHR_FAST                 0x00000002
/** Use to generate a timeout when SCL has been high for a given amount time
   between a START and STOP condition. When in a bus transaction, i.e. the BUSY
   flag is set, a timer is started whenever SCL goes high. When the timer reaches
   the value defined by BITO, it sets the BITO interrupt flag. The BITO interrupt
   flag will then be set periodically as long as SCL remains high. The bus idle
   timeout is active as long as BUSY is set. It is thus stopped automatically on
   a timeout if GIBITO is set. It is also stopped a STOP condition is detected
   and when the ABORT command is issued. The timeout is activated whenever the
   bus goes BUSY, i.e. a START condition is detected. @multiple */
  #define EFM32_I2C_CTRL_BITO                      0x00003000
  #define EFM32_I2C_CTRL_BITO_SHIFT                12
  #define EFM32_I2C_CTRL_BITO_SHIFT_VAL(v)         ((EFM32_I2C_CTRL_BITO_##v) << 12)
  #define EFM32_I2C_CTRL_BITO_SET(x, v)            do { (x) = (((x) & ~0x3000) | ((EFM32_I2C_CTRL_BITO_##v) << 12)); } while(0)
  #define EFM32_I2C_CTRL_BITO_SETVAL(x, v)         do { (x) = (((x) & ~0x3000) | ((v) << 12)); } while(0)
  #define EFM32_I2C_CTRL_BITO_GET(x)               (((x) >> 12) & 0x3)
    #define EFM32_I2C_CTRL_BITO_OFF                  0x00000000
    #define EFM32_I2C_CTRL_BITO_40PCC                0x00000001
    #define EFM32_I2C_CTRL_BITO_80PCC                0x00000002
    #define EFM32_I2C_CTRL_BITO_160PCC               0x00000003
/** When set, the bus automatically goes idle on a bus idle timeout, allowing new
   transfers to be initiated. @multiple */
  #define EFM32_I2C_CTRL_GIBITO                    0x00008000
  #define EFM32_I2C_CTRL_GIBITO_SHIFT              15
  #define EFM32_I2C_CTRL_GIBITO_SHIFT_VAL(v)       ((EFM32_I2C_CTRL_GIBITO_##v) << 15)
  #define EFM32_I2C_CTRL_GIBITO_SET(x, v)          do { (x) = (((x) & ~0x8000) | ((EFM32_I2C_CTRL_GIBITO_##v) << 15)); } while(0)
  #define EFM32_I2C_CTRL_GIBITO_SETVAL(x, v)       do { (x) = (((x) & ~0x8000) | ((v) << 15)); } while(0)
  #define EFM32_I2C_CTRL_GIBITO_GET(x)             (((x) >> 15) & 0x1)
    #define EFM32_I2C_CTRL_GIBITO_NO_ACTION          0x00000000
    #define EFM32_I2C_CTRL_GIBITO_NEW_TRANSFER       0x00000001
/** Use to generate a timeout when CLK has been low for the given amount of time.
   Wraps around and continues counting when the timeout is reached. @multiple */
  #define EFM32_I2C_CTRL_CLTO                      0x00070000
  #define EFM32_I2C_CTRL_CLTO_SHIFT                16
  #define EFM32_I2C_CTRL_CLTO_SHIFT_VAL(v)         ((EFM32_I2C_CTRL_CLTO_##v) << 16)
  #define EFM32_I2C_CTRL_CLTO_SET(x, v)            do { (x) = (((x) & ~0x70000) | ((EFM32_I2C_CTRL_CLTO_##v) << 16)); } while(0)
  #define EFM32_I2C_CTRL_CLTO_SETVAL(x, v)         do { (x) = (((x) & ~0x70000) | ((v) << 16)); } while(0)
  #define EFM32_I2C_CTRL_CLTO_GET(x)               (((x) >> 16) & 0x7)
    #define EFM32_I2C_CTRL_CLTO_OFF                  0x00000000
    #define EFM32_I2C_CTRL_CLTO_40PCC                0x00000001
    #define EFM32_I2C_CTRL_CLTO_80PCC                0x00000002
    #define EFM32_I2C_CTRL_CLTO_160PCC               0x00000003
    #define EFM32_I2C_CTRL_CLTO_320PCC               0x00000004
    #define EFM32_I2C_CTRL_CLTO_1024PCC0             0x00000005

#define EFM32_I2C_CMD_ADDR                           0x00000004
#define EFM32_I2C_CMD_MASK                           0x000000ff
/** Set to send start condition as soon as possible. If a transmission is ongoing
   and not owned, the start condition will be sent as soon as the bus is idle. If
   the current transmission is owned by this module, a repeated start condition
   will be sent. Use in combination with a STOP command to automatically send a
   STOP, then a START when the bus becomes idle. @multiple */
  #define EFM32_I2C_CMD_START                      0x00000001
  #define EFM32_I2C_CMD_START_SHIFT                0
/** Set to send stop condition as soon as possible. @multiple */
  #define EFM32_I2C_CMD_STOP                       0x00000002
  #define EFM32_I2C_CMD_STOP_SHIFT                 1
/** Set to transmit an ACK the next time an acknowledge is required. @multiple */
  #define EFM32_I2C_CMD_ACK                        0x00000004
  #define EFM32_I2C_CMD_ACK_SHIFT                  2
/** Set to transmit a NACK the next time an acknowledge is required. @multiple */
  #define EFM32_I2C_CMD_NACK                       0x00000008
  #define EFM32_I2C_CMD_NACK_SHIFT                 3
/** Set to continue transmission after a NACK has been received. @multiple */
  #define EFM32_I2C_CMD_CONT                       0x00000010
  #define EFM32_I2C_CMD_CONT_SHIFT                 4
/** Abort the current transmission making the bus go idle. When used in
   combination with STOP, a STOP condition is sent as soon as possible before
   aborting the transmission. The stop condition is subject to clock
   synchronization. @multiple */
  #define EFM32_I2C_CMD_ABORT                      0x00000020
  #define EFM32_I2C_CMD_ABORT_SHIFT                5
/** Set to clear transmit buffer and shift register. Will not abort ongoing
   transfer. @multiple */
  #define EFM32_I2C_CMD_CLEARTX                    0x00000040
  #define EFM32_I2C_CMD_CLEARTX_SHIFT              6
/** Set to clear pending commands. @multiple */
  #define EFM32_I2C_CMD_CLEARPC                    0x00000080
  #define EFM32_I2C_CMD_CLEARPC_SHIFT              7

#define EFM32_I2C_STATE_ADDR                         0x00000008
#define EFM32_I2C_STATE_MASK                         0x000000ff
/** Set when the bus is busy. Whether the I C module is in control of the bus or
   not has no effect on the value of this bit. When the MCU comes out of reset,
   the state of the bus is not known, and thus BUSY is set. Use the ABORT command
   or a bus idle timeout to force the I2C module out of the BUSY state. @multiple
   */
  #define EFM32_I2C_STATE_BUSY                     0x00000001
  #define EFM32_I2C_STATE_BUSY_SHIFT               0
/** Set when operating as an I C master. When cleared, the system may be
   operating as an I C slave. @multiple */
  #define EFM32_I2C_STATE_MASTER                   0x00000002
  #define EFM32_I2C_STATE_MASTER_SHIFT             1
/** Set when operating as a master transmitter or a slave transmitter. When
   cleared, the system may be operating as a master receiver, a slave receiver or
   the current mode is not known. @multiple */
  #define EFM32_I2C_STATE_TRANSMITTER              0x00000004
  #define EFM32_I2C_STATE_TRANSMITTER_SHIFT        2
/** Set if a NACK was received and STATE is ADDRACK or DATAACK. @multiple */
  #define EFM32_I2C_STATE_NACKED                   0x00000008
  #define EFM32_I2C_STATE_NACKED_SHIFT             3
/** Set if the bus is currently being held by this I C module. @multiple */
  #define EFM32_I2C_STATE_BUSHOLD                  0x00000010
  #define EFM32_I2C_STATE_BUSHOLD_SHIFT            4
/** The state of any current transmission. Cleared if the I C module is idle.
   @multiple */
  #define EFM32_I2C_STATE_STATE                    0x000000e0
  #define EFM32_I2C_STATE_STATE_SHIFT              5
  #define EFM32_I2C_STATE_STATE_SHIFT_VAL(v)       ((EFM32_I2C_STATE_STATE_##v) << 5)
  #define EFM32_I2C_STATE_STATE_SET(x, v)          do { (x) = (((x) & ~0xe0) | ((EFM32_I2C_STATE_STATE_##v) << 5)); } while(0)
  #define EFM32_I2C_STATE_STATE_SETVAL(x, v)       do { (x) = (((x) & ~0xe0) | ((v) << 5)); } while(0)
  #define EFM32_I2C_STATE_STATE_GET(x)             (((x) >> 5) & 0x7)
    #define EFM32_I2C_STATE_STATE_IDLE               0x00000000
    #define EFM32_I2C_STATE_STATE_WAIT               0x00000001
    #define EFM32_I2C_STATE_STATE_START              0x00000002
    #define EFM32_I2C_STATE_STATE_ADDR               0x00000003
    #define EFM32_I2C_STATE_STATE_ADDRACK            0x00000004
    #define EFM32_I2C_STATE_STATE_DATA               0x00000005
    #define EFM32_I2C_STATE_STATE_DATAACK            0x00000006

#define EFM32_I2C_STATUS_ADDR                        0x0000000c
#define EFM32_I2C_STATUS_MASK                        0x000001ff
/** A start condition is pending and will be transmitted as soon as possible.
   @multiple */
  #define EFM32_I2C_STATUS_PSTART                  0x00000001
  #define EFM32_I2C_STATUS_PSTART_SHIFT            0
/** A stop condition is pending and will be transmitted as soon as possible.
   @multiple */
  #define EFM32_I2C_STATUS_PSTOP                   0x00000002
  #define EFM32_I2C_STATUS_PSTOP_SHIFT             1
/** An acknowledge is pending and will be transmitted as soon as possible. a
   slave receiver or the current mode is not known. @multiple */
  #define EFM32_I2C_STATUS_PACK                    0x00000004
  #define EFM32_I2C_STATUS_PACK_SHIFT              2
/** A not-acknowledge is pending and will be transmitted as soon as possible.
   @multiple */
  #define EFM32_I2C_STATUS_PNACK                   0x00000008
  #define EFM32_I2C_STATUS_PNACK_SHIFT             3
/** A continue is pending and will be transmitted as soon as possible. @multiple
   */
  #define EFM32_I2C_STATUS_PCONT                   0x00000010
  #define EFM32_I2C_STATUS_PCONT_SHIFT             4
/** An abort is pending and will be transmitted as soon as possible. @multiple */
  #define EFM32_I2C_STATUS_PABORT                  0x00000020
  #define EFM32_I2C_STATUS_PABORT_SHIFT            5
/** Set when a transmission has completed and no more data is available in the
   transmit buffer. Cleared when a new transmission starts. @multiple */
  #define EFM32_I2C_STATUS_TXC                     0x00000040
  #define EFM32_I2C_STATUS_TXC_SHIFT               6
/** Indicates the level of the transmit buffer. Set when the transmit buffer is
   empty, and cleared when it is full. @multiple */
  #define EFM32_I2C_STATUS_TXBL                    0x00000080
  #define EFM32_I2C_STATUS_TXBL_SHIFT              7
/** Set when data is available in the receive buffer. Cleared when the receive
   buffer is empty. @multiple */
  #define EFM32_I2C_STATUS_RXDATAV                 0x00000100
  #define EFM32_I2C_STATUS_RXDATAV_SHIFT           8

#define EFM32_I2C_CLKDIV_ADDR                        0x00000010
#define EFM32_I2C_CLKDIV_MASK                        0x000001ff
/** Specifies the clock divider for the I C. Note that DIV must be 1 or higher
   when slave is enabled. @multiple */
  #define EFM32_I2C_CLKDIV_VAL                     0x000001ff
  #define EFM32_I2C_CLKDIV_VAL_SHIFT               0
  #define EFM32_I2C_CLKDIV_VAL_SHIFT_VAL(v)        ((v) << 0)
  #define EFM32_I2C_CLKDIV_VAL_SET(x, v)           do { (x) = (((x) & ~0x1ff) | ((v) << 0)); } while(0)
  #define EFM32_I2C_CLKDIV_VAL_GET(x)              (((x) >> 0) & 0x1ff)

#define EFM32_I2C_SADDR_ADDR                         0x00000014
#define EFM32_I2C_SADDR_MASK                         0x000000fe
/** Specifies the slave address of the device. @multiple */
  #define EFM32_I2C_SADDR_VAL                      0x000000fe
  #define EFM32_I2C_SADDR_VAL_SHIFT                1
  #define EFM32_I2C_SADDR_VAL_SHIFT_VAL(v)         ((v) << 1)
  #define EFM32_I2C_SADDR_VAL_SET(x, v)            do { (x) = (((x) & ~0xfe) | ((v) << 1)); } while(0)
  #define EFM32_I2C_SADDR_VAL_GET(x)               (((x) >> 1) & 0x7f)

#define EFM32_I2C_SADDRMASK_ADDR                     0x00000018
#define EFM32_I2C_SADDRMASK_MASK                     0x000000fe
/** Specifies the significant bits of the slave address. Setting the mask to 0x00
   will match all addresses, while setting it to 0x7F will only match the exact
   address specified by ADDR. @multiple */
  #define EFM32_I2C_SADDRMASK_VAL                  0x000000fe
  #define EFM32_I2C_SADDRMASK_VAL_SHIFT            1
  #define EFM32_I2C_SADDRMASK_VAL_SHIFT_VAL(v)     ((v) << 1)
  #define EFM32_I2C_SADDRMASK_VAL_SET(x, v)        do { (x) = (((x) & ~0xfe) | ((v) << 1)); } while(0)
  #define EFM32_I2C_SADDRMASK_VAL_GET(x)           (((x) >> 1) & 0x7f)

#define EFM32_I2C_RXDATA_ADDR                        0x0000001c
#define EFM32_I2C_RXDATA_MASK                        0x000000ff
/** Use this register to read from the receive buffer. Buffer is emptied on read
   access. @multiple */
  #define EFM32_I2C_RXDATA_VAL                     0x000000ff
  #define EFM32_I2C_RXDATA_VAL_SHIFT               0
  #define EFM32_I2C_RXDATA_VAL_SHIFT_VAL(v)        ((v) << 0)
  #define EFM32_I2C_RXDATA_VAL_SET(x, v)           do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define EFM32_I2C_RXDATA_VAL_GET(x)              (((x) >> 0) & 0xff)

#define EFM32_I2C_RXDATAP_ADDR                       0x00000020
#define EFM32_I2C_RXDATAP_MASK                       0x000000ff
/** Use this register to read from the receive buffer. Buffer is not emptied on
   read access. @multiple */
  #define EFM32_I2C_RXDATAP_VAL                    0x000000ff
  #define EFM32_I2C_RXDATAP_VAL_SHIFT              0
  #define EFM32_I2C_RXDATAP_VAL_SHIFT_VAL(v)       ((v) << 0)
  #define EFM32_I2C_RXDATAP_VAL_SET(x, v)          do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define EFM32_I2C_RXDATAP_VAL_GET(x)             (((x) >> 0) & 0xff)

#define EFM32_I2C_TXDATA_ADDR                        0x00000024
#define EFM32_I2C_TXDATA_MASK                        0x000000ff
/** Use this register to write a byte to the transmit buffer. @multiple */
  #define EFM32_I2C_TXDATA_VAL                     0x000000ff
  #define EFM32_I2C_TXDATA_VAL_SHIFT               0
  #define EFM32_I2C_TXDATA_VAL_SHIFT_VAL(v)        ((v) << 0)
  #define EFM32_I2C_TXDATA_VAL_SET(x, v)           do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define EFM32_I2C_TXDATA_VAL_GET(x)              (((x) >> 0) & 0xff)

#define EFM32_I2C_IF_ADDR                            0x00000028
#define EFM32_I2C_IF_MASK                            0x0001ffff
/** Set when a start condition is successfully transmitted. @multiple */
  #define EFM32_I2C_IF_START                       0x00000001
  #define EFM32_I2C_IF_START_SHIFT                 0
/** Set when a repeated start condition is detected. @multiple */
  #define EFM32_I2C_IF_RSTART                      0x00000002
  #define EFM32_I2C_IF_RSTART_SHIFT                1
/** Set when incoming address is accepted, i.e. own address or general call
   address is received. @multiple */
  #define EFM32_I2C_IF_ADDRA                       0x00000004
  #define EFM32_I2C_IF_ADDRA_SHIFT                 2
/** Set when the transmit shift register becomes empty and there is no more data
   in the transmit buffer. @multiple */
  #define EFM32_I2C_IF_TXC                         0x00000008
  #define EFM32_I2C_IF_TXC_SHIFT                   3
/** Set when the transmit buffer becomes empty. Cleared automatically when new
   data is written to the transmit buffer. @multiple */
  #define EFM32_I2C_IF_TXBL                        0x00000010
  #define EFM32_I2C_IF_TXBL_SHIFT                  4
/** Set when data is available in the receive buffer. Cleared automatically when
   the receive buffer is read. @multiple */
  #define EFM32_I2C_IF_RXDATAV                     0x00000020
  #define EFM32_I2C_IF_RXDATAV_SHIFT               5
/** Set when an ACK has been received. @multiple */
  #define EFM32_I2C_IF_ACK                         0x00000040
  #define EFM32_I2C_IF_ACK_SHIFT                   6
/** Set when a NACK has been received. @multiple */
  #define EFM32_I2C_IF_NACK                        0x00000080
  #define EFM32_I2C_IF_NACK_SHIFT                  7
/** Set when a STOP condition has been successfully transmitted. If arbitration
   is lost during the transmission of the STOP condition, then the MSTOP
   interrupt flag is not set. @multiple */
  #define EFM32_I2C_IF_MSTOP                       0x00000100
  #define EFM32_I2C_IF_MSTOP_SHIFT                 8
/** Set when arbitration is lost. @multiple */
  #define EFM32_I2C_IF_ARBLOST                     0x00000200
  #define EFM32_I2C_IF_ARBLOST_SHIFT               9
/** Set when a bus error is detected. The bus error is resolved automatically,
   but the current transfer is aborted. @multiple */
  #define EFM32_I2C_IF_BUSERR                      0x00000400
  #define EFM32_I2C_IF_BUSERR_SHIFT                10
/** Set when the bus becomes held by the I C module. @multiple */
  #define EFM32_I2C_IF_BUSHOLD                     0x00000800
  #define EFM32_I2C_IF_BUSHOLD_SHIFT               11
/** Set when data is written to the transmit buffer while the transmit buffer is
   full. @multiple */
  #define EFM32_I2C_IF_TXOF                        0x00001000
  #define EFM32_I2C_IF_TXOF_SHIFT                  12
/** Set when data is read from the receive buffer through the I2Cn_RXDATA
   register while the receive buffer is empty. @multiple */
  #define EFM32_I2C_IF_RXUF                        0x00002000
  #define EFM32_I2C_IF_RXUF_SHIFT                  13
/** Set on each bus idle timeout. The timeout value can be set in the BITO bit
   field in the I2Cn_CTRL register. @multiple */
  #define EFM32_I2C_IF_BITO                        0x00004000
  #define EFM32_I2C_IF_BITO_SHIFT                  14
/** Set on each clock low timeout. The timeout value can be set in CLTO bit field
   in the I2Cn_CTRL register. @multiple */
  #define EFM32_I2C_IF_CLTO                        0x00008000
  #define EFM32_I2C_IF_CLTO_SHIFT                  15
/** Set when a STOP condition has been received. Will be set regardless of the
   EFM32 being involved in the transaction or not. @multiple */
  #define EFM32_I2C_IF_SSTOP                       0x00010000
  #define EFM32_I2C_IF_SSTOP_SHIFT                 16

#define EFM32_I2C_IFS_ADDR                           0x0000002c
#define EFM32_I2C_IFS_MASK                           0x0001ffcf
/** Write to 1 to set the START interrupt flag. @multiple */
  #define EFM32_I2C_IFS_START                      0x00000001
  #define EFM32_I2C_IFS_START_SHIFT                0
/** Write to 1 to set the RSTART interrupt flag. @multiple */
  #define EFM32_I2C_IFS_RSTART                     0x00000002
  #define EFM32_I2C_IFS_RSTART_SHIFT               1
/** Write to 1 to set the ADDR interrupt flag. @multiple */
  #define EFM32_I2C_IFS_ADDRA                      0x00000004
  #define EFM32_I2C_IFS_ADDRA_SHIFT                2
/** Write to 1 to set the TXC interrupt flag. @multiple */
  #define EFM32_I2C_IFS_TXC                        0x00000008
  #define EFM32_I2C_IFS_TXC_SHIFT                  3
/** Write to 1 to set the ACK interrupt flag. @multiple */
  #define EFM32_I2C_IFS_ACK                        0x00000040
  #define EFM32_I2C_IFS_ACK_SHIFT                  6
/** Write to 1 to set the NACK interrupt flag. @multiple */
  #define EFM32_I2C_IFS_NACK                       0x00000080
  #define EFM32_I2C_IFS_NACK_SHIFT                 7
/** Write to 1 to set the MSTOP interrupt flag. @multiple */
  #define EFM32_I2C_IFS_MSTOP                      0x00000100
  #define EFM32_I2C_IFS_MSTOP_SHIFT                8
/** Write to 1 to set the ARBLOST interrupt flag. @multiple */
  #define EFM32_I2C_IFS_ARBLOST                    0x00000200
  #define EFM32_I2C_IFS_ARBLOST_SHIFT              9
/** Write to 1 to set the BUSERR interrupt flag. @multiple */
  #define EFM32_I2C_IFS_BUSERR                     0x00000400
  #define EFM32_I2C_IFS_BUSERR_SHIFT               10
/** Write to 1 to set the BUSHOLD interrupt flag. @multiple */
  #define EFM32_I2C_IFS_BUSHOLD                    0x00000800
  #define EFM32_I2C_IFS_BUSHOLD_SHIFT              11
/** Write to 1 to set the TXOF interrupt flag. @multiple */
  #define EFM32_I2C_IFS_TXOF                       0x00001000
  #define EFM32_I2C_IFS_TXOF_SHIFT                 12
/** Write to 1 to set the RXUF interrupt flag. @multiple */
  #define EFM32_I2C_IFS_RXUF                       0x00002000
  #define EFM32_I2C_IFS_RXUF_SHIFT                 13
/** Write to 1 to set the BITO interrupt flag. @multiple */
  #define EFM32_I2C_IFS_BITO                       0x00004000
  #define EFM32_I2C_IFS_BITO_SHIFT                 14
/** Write to 1 to set the CLTO interrupt flag. @multiple */
  #define EFM32_I2C_IFS_CLTO                       0x00008000
  #define EFM32_I2C_IFS_CLTO_SHIFT                 15
/** Write to 1 to set the SSTOP interrupt flag. @multiple */
  #define EFM32_I2C_IFS_SSTOP                      0x00010000
  #define EFM32_I2C_IFS_SSTOP_SHIFT                16

#define EFM32_I2C_IFC_ADDR                           0x00000030
#define EFM32_I2C_IFC_MASK                           0x0001ffcf
/** Write to 1 to clear the START interrupt flag. @multiple */
  #define EFM32_I2C_IFC_START                      0x00000001
  #define EFM32_I2C_IFC_START_SHIFT                0
/** Write to 1 to clear the RSTART interrupt flag. @multiple */
  #define EFM32_I2C_IFC_RSTART                     0x00000002
  #define EFM32_I2C_IFC_RSTART_SHIFT               1
/** Write to 1 to clear the ADDR interrupt flag. @multiple */
  #define EFM32_I2C_IFC_ADDRA                      0x00000004
  #define EFM32_I2C_IFC_ADDRA_SHIFT                2
/** Write to 1 to clear the TXC interrupt flag. @multiple */
  #define EFM32_I2C_IFC_TXC                        0x00000008
  #define EFM32_I2C_IFC_TXC_SHIFT                  3
/** Write to 1 to clear the ACK interrupt flag. @multiple */
  #define EFM32_I2C_IFC_ACK                        0x00000040
  #define EFM32_I2C_IFC_ACK_SHIFT                  6
/** Write to 1 to clear the NACK interrupt flag. @multiple */
  #define EFM32_I2C_IFC_NACK                       0x00000080
  #define EFM32_I2C_IFC_NACK_SHIFT                 7
/** Write to 1 to clear the MSTOP interrupt flag. @multiple */
  #define EFM32_I2C_IFC_MSTOP                      0x00000100
  #define EFM32_I2C_IFC_MSTOP_SHIFT                8
/** Write to 1 to clear the ARBLOST interrupt flag. @multiple */
  #define EFM32_I2C_IFC_ARBLOST                    0x00000200
  #define EFM32_I2C_IFC_ARBLOST_SHIFT              9
/** Write to 1 to clear the BUSERR interrupt flag. @multiple */
  #define EFM32_I2C_IFC_BUSERR                     0x00000400
  #define EFM32_I2C_IFC_BUSERR_SHIFT               10
/** Write to 1 to clear the BUSHOLD interrupt flag. @multiple */
  #define EFM32_I2C_IFC_BUSHOLD                    0x00000800
  #define EFM32_I2C_IFC_BUSHOLD_SHIFT              11
/** Write to 1 to clear the TXOF interrupt flag. @multiple */
  #define EFM32_I2C_IFC_TXOF                       0x00001000
  #define EFM32_I2C_IFC_TXOF_SHIFT                 12
/** Write to 1 to clear the RXUF interrupt flag. @multiple */
  #define EFM32_I2C_IFC_RXUF                       0x00002000
  #define EFM32_I2C_IFC_RXUF_SHIFT                 13
/** Write to 1 to clear the BITO interrupt flag. @multiple */
  #define EFM32_I2C_IFC_BITO                       0x00004000
  #define EFM32_I2C_IFC_BITO_SHIFT                 14
/** Write to 1 to clear the CLTO interrupt flag. @multiple */
  #define EFM32_I2C_IFC_CLTO                       0x00008000
  #define EFM32_I2C_IFC_CLTO_SHIFT                 15
/** Write to 1 to clear the SSTOP interrupt flag. @multiple */
  #define EFM32_I2C_IFC_SSTOP                      0x00010000
  #define EFM32_I2C_IFC_SSTOP_SHIFT                16

#define EFM32_I2C_IEN_ADDR                           0x00000034
#define EFM32_I2C_IEN_MASK                           0x0001ffff
/** Enable interrupt on transmitted or received START condition. @multiple */
  #define EFM32_I2C_IEN_START                      0x00000001
  #define EFM32_I2C_IEN_START_SHIFT                0
/** Enable interrupt on transmitted or received repeated START condition.
   @multiple */
  #define EFM32_I2C_IEN_RSTART                     0x00000002
  #define EFM32_I2C_IEN_RSTART_SHIFT               1
/** Enable interrupt on recognized address. @multiple */
  #define EFM32_I2C_IEN_ADDRA                      0x00000004
  #define EFM32_I2C_IEN_ADDRA_SHIFT                2
/** Enable interrupt on transfer completed. @multiple */
  #define EFM32_I2C_IEN_TXC                        0x00000008
  #define EFM32_I2C_IEN_TXC_SHIFT                  3
/** Enable interrupt on transmit buffer level. @multiple */
  #define EFM32_I2C_IEN_TXBL                       0x00000010
  #define EFM32_I2C_IEN_TXBL_SHIFT                 4
/** Enable interrupt on receive buffer full. @multiple */
  #define EFM32_I2C_IEN_RXDATAV                    0x00000020
  #define EFM32_I2C_IEN_RXDATAV_SHIFT              5
/** Enable interrupt on acknowledge received. @multiple */
  #define EFM32_I2C_IEN_ACK                        0x00000040
  #define EFM32_I2C_IEN_ACK_SHIFT                  6
/** Enable interrupt when not-acknowledge is received. @multiple */
  #define EFM32_I2C_IEN_NACK                       0x00000080
  #define EFM32_I2C_IEN_NACK_SHIFT                 7
/** Enable interrupt on MSTOP. @multiple */
  #define EFM32_I2C_IEN_MSTOP                      0x00000100
  #define EFM32_I2C_IEN_MSTOP_SHIFT                8
/** Enable interrupt on loss of arbitration. @multiple */
  #define EFM32_I2C_IEN_ARBLOST                    0x00000200
  #define EFM32_I2C_IEN_ARBLOST_SHIFT              9
/** Enable interrupt on bus error. @multiple */
  #define EFM32_I2C_IEN_BUSERR                     0x00000400
  #define EFM32_I2C_IEN_BUSERR_SHIFT               10
/** Enable interrupt on bus-held. @multiple */
  #define EFM32_I2C_IEN_BUSHOLD                    0x00000800
  #define EFM32_I2C_IEN_BUSHOLD_SHIFT              11
/** Enable interrupt on transmit buffer overflow. @multiple */
  #define EFM32_I2C_IEN_TXOF                       0x00001000
  #define EFM32_I2C_IEN_TXOF_SHIFT                 12
/** Enable interrupt on receive buffer underflow. @multiple */
  #define EFM32_I2C_IEN_RXUF                       0x00002000
  #define EFM32_I2C_IEN_RXUF_SHIFT                 13
/** Enable interrupt on bus idle timeout. @multiple */
  #define EFM32_I2C_IEN_BITO                       0x00004000
  #define EFM32_I2C_IEN_BITO_SHIFT                 14
/** Enable interrupt on clock low timeout. @multiple */
  #define EFM32_I2C_IEN_CLTO                       0x00008000
  #define EFM32_I2C_IEN_CLTO_SHIFT                 15
/** Enable interrupt on SSTOP. @multiple */
  #define EFM32_I2C_IEN_SSTOP                      0x00010000
  #define EFM32_I2C_IEN_SSTOP_SHIFT                16

#define EFM32_I2C_ROUTE_ADDR                         0x00000038
#define EFM32_I2C_ROUTE_MASK                         0x00000303
/** When set, the SDA pin of the I C is enabled. @multiple */
  #define EFM32_I2C_ROUTE_SDAPEN                   0x00000001
  #define EFM32_I2C_ROUTE_SDAPEN_SHIFT             0
/** When set, the SCL pin of the I C is enabled. @multiple */
  #define EFM32_I2C_ROUTE_SCLPEN                   0x00000002
  #define EFM32_I2C_ROUTE_SCLPEN_SHIFT             1
/** Decides the location of the I C I/O pins. @multiple */
  #define EFM32_I2C_ROUTE_LOCATION                 0x00000300
  #define EFM32_I2C_ROUTE_LOCATION_SHIFT           8
  #define EFM32_I2C_ROUTE_LOCATION_SHIFT_VAL(v)    ((EFM32_I2C_ROUTE_LOCATION_##v) << 8)
  #define EFM32_I2C_ROUTE_LOCATION_SET(x, v)       do { (x) = (((x) & ~0x300) | ((EFM32_I2C_ROUTE_LOCATION_##v) << 8)); } while(0)
  #define EFM32_I2C_ROUTE_LOCATION_SETVAL(x, v)    do { (x) = (((x) & ~0x300) | ((v) << 8)); } while(0)
  #define EFM32_I2C_ROUTE_LOCATION_GET(x)          (((x) >> 8) & 0x3)
    #define EFM32_I2C_ROUTE_LOCATION_LOC0            0x00000000
    #define EFM32_I2C_ROUTE_LOCATION_LOC1            0x00000001
    #define EFM32_I2C_ROUTE_LOCATION_LOC2            0x00000002
    #define EFM32_I2C_ROUTE_LOCATION_LOC3            0x00000003

#endif

