/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -o cdefs -O arch/efm32/include/arch/efm32_cmu.h cdefs_use_reg_mask=1  \
     cdefs_use_field_setval=1 cdefs_use_field_shift=1 cdefs_use_field_set=1
*/

#ifndef _EFM32_CMU_BFGEN_DEFS_
#define _EFM32_CMU_BFGEN_DEFS_

#define EFM32_CMU_CTRL_ADDR                          0x00000000
#define EFM32_CMU_CTRL_MASK                          0x007e3eef
/** Set this to configure the external source for the HFXO. The oscillator
   setting takes effect when 1 is written to HFXOEN in CMU_OSCENCMD. The
   oscillator setting is reset to default when 1 is written to HFXODIS in
   CMU_OSCENCMD. @multiple */
  #define EFM32_CMU_CTRL_HFXOMODE_SHIFT            0
  #define EFM32_CMU_CTRL_HFXOMODE(v)               ((EFM32_CMU_CTRL_HFXOMODE_##v) << 0)
  #define EFM32_CMU_CTRL_HFXOMODE_SET(x, v)        do { (x) = (((x) & ~0x3) | ((EFM32_CMU_CTRL_HFXOMODE_##v) << 0)); } while(0)
  #define EFM32_CMU_CTRL_HFXOMODE_SETVAL(x, v)     do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define EFM32_CMU_CTRL_HFXOMODE_GET(x)           (((x) >> 0) & 0x3)
    #define EFM32_CMU_CTRL_HFXOMODE_XTAL             0x00000000
    #define EFM32_CMU_CTRL_HFXOMODE_BUFEXTCLK        0x00000001
    #define EFM32_CMU_CTRL_HFXOMODE_DIGEEXTCLK       0x00000002
/** Used to adjust start-up boost current for HFXO. @multiple */
  #define EFM32_CMU_CTRL_HFXOBOOST_SHIFT           2
  #define EFM32_CMU_CTRL_HFXOBOOST(v)              ((EFM32_CMU_CTRL_HFXOBOOST_##v) << 2)
  #define EFM32_CMU_CTRL_HFXOBOOST_SET(x, v)       do { (x) = (((x) & ~0xc) | ((EFM32_CMU_CTRL_HFXOBOOST_##v) << 2)); } while(0)
  #define EFM32_CMU_CTRL_HFXOBOOST_SETVAL(x, v)    do { (x) = (((x) & ~0xc) | ((v) << 2)); } while(0)
  #define EFM32_CMU_CTRL_HFXOBOOST_GET(x)          (((x) >> 2) & 0x3)
    #define EFM32_CMU_CTRL_HFXOBOOST_50PCENT         0x00000000
    #define EFM32_CMU_CTRL_HFXOBOOST_70PCENT         0x00000001
    #define EFM32_CMU_CTRL_HFXOBOOST_80PCENT         0x00000002
    #define EFM32_CMU_CTRL_HFXOBOOST_100PCENT        0x00000003
/** This value has been set during calibration and should not be changed.
   @multiple */
  #define EFM32_CMU_CTRL_HFXOBUFCUR_SHIFT          5
  #define EFM32_CMU_CTRL_HFXOBUFCUR(v)             ((v) << 5)
  #define EFM32_CMU_CTRL_HFXOBUFCUR_SET(x, v)      do { (x) = (((x) & ~0x60) | ((v) << 5)); } while(0)
  #define EFM32_CMU_CTRL_HFXOBUFCUR_GET(x)         (((x) >> 5) & 0x3)
/** This bit enables the glitch detector which is active as long as the start-up
   ripple-counter is counting. A detected glitch will reset the ripple-counter
   effectively increasing the start-up time. Once the ripple-counter has
   timed-out, glitches will not be detected. @multiple */
  #define EFM32_CMU_CTRL_HFXOGLITCHDETEN           0x00000080
  #define EFM32_CMU_CTRL_HFXOGLITCHDETEN_SHIFT     7
  #define EFM32_CMU_CTRL_HFXOGLITCHDETEN_SET(x, v) do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
/** Configures the start-up delay for HFXO. @multiple */
  #define EFM32_CMU_CTRL_HFXOTIMEOUT_SHIFT         9
  #define EFM32_CMU_CTRL_HFXOTIMEOUT(v)            ((EFM32_CMU_CTRL_HFXOTIMEOUT_##v) << 9)
  #define EFM32_CMU_CTRL_HFXOTIMEOUT_SET(x, v)     do { (x) = (((x) & ~0x600) | ((EFM32_CMU_CTRL_HFXOTIMEOUT_##v) << 9)); } while(0)
  #define EFM32_CMU_CTRL_HFXOTIMEOUT_SETVAL(x, v)  do { (x) = (((x) & ~0x600) | ((v) << 9)); } while(0)
  #define EFM32_CMU_CTRL_HFXOTIMEOUT_GET(x)        (((x) >> 9) & 0x3)
    #define EFM32_CMU_CTRL_HFXOTIMEOUT_8             0x00000000
    #define EFM32_CMU_CTRL_HFXOTIMEOUT_256           0x00000001
    #define EFM32_CMU_CTRL_HFXOTIMEOUT_1K            0x00000002
    #define EFM32_CMU_CTRL_HFXOTIMEOUT_16K           0x00000003
/** Set this to configure the external source for the LFXO. The oscillator
   setting takes effect when 1 is written to LFXOEN in CMU_OSCENCMD. The
   oscillator setting is reset to default when 1 is written to LFXODIS in
   CMU_OSCENCMD. @multiple */
  #define EFM32_CMU_CTRL_LXOMODE_SHIFT             11
  #define EFM32_CMU_CTRL_LXOMODE(v)                ((EFM32_CMU_CTRL_LXOMODE_##v) << 11)
  #define EFM32_CMU_CTRL_LXOMODE_SET(x, v)         do { (x) = (((x) & ~0x1800) | ((EFM32_CMU_CTRL_LXOMODE_##v) << 11)); } while(0)
  #define EFM32_CMU_CTRL_LXOMODE_SETVAL(x, v)      do { (x) = (((x) & ~0x1800) | ((v) << 11)); } while(0)
  #define EFM32_CMU_CTRL_LXOMODE_GET(x)            (((x) >> 11) & 0x3)
    #define EFM32_CMU_CTRL_LXOMODE_XTAL              0x00000000
    #define EFM32_CMU_CTRL_LXOMODE_BUFEXTCLK         0x00000001
    #define EFM32_CMU_CTRL_LXOMODE_DIGEXTCLK         0x00000002
/** Adjusts start-up boost current for LFXO. @multiple */
  #define EFM32_CMU_CTRL_LFXOBOOST_SHIFT           13
  #define EFM32_CMU_CTRL_LFXOBOOST(v)              ((EFM32_CMU_CTRL_LFXOBOOST_##v) << 13)
  #define EFM32_CMU_CTRL_LFXOBOOST_SET(x, v)       do { (x) = (((x) & ~0x2000) | ((EFM32_CMU_CTRL_LFXOBOOST_##v) << 13)); } while(0)
  #define EFM32_CMU_CTRL_LFXOBOOST_SETVAL(x, v)    do { (x) = (((x) & ~0x2000) | ((v) << 13)); } while(0)
  #define EFM32_CMU_CTRL_LFXOBOOST_GET(x)          (((x) >> 13) & 0x1)
    #define EFM32_CMU_CTRL_LFXOBOOST_70PCENT         0x00000000
    #define EFM32_CMU_CTRL_LFXOBOOST_100PCENT        0x00000001
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
/** Use to divide HFCLK frequency by (hfclkdiv + 1) @multiple */
  #define EFM32_CMU_CTRL_HFCLKDIV_SHIFT            14
  #define EFM32_CMU_CTRL_HFCLKDIV(v)               ((v) << 14)
  #define EFM32_CMU_CTRL_HFCLKDIV_SET(x, v)        do { (x) = (((x) & ~0x1c000) | ((v) << 14)); } while(0)
  #define EFM32_CMU_CTRL_HFCLKDIV_GET(x)           (((x) >> 14) & 0x7)
# endif
/** This value has been updated to the correct level during calibration and
   should not be changed. @multiple */
  #define EFM32_CMU_CTRL_LFXOBUFCUR                0x00020000
  #define EFM32_CMU_CTRL_LFXOBUFCUR_SHIFT          17
  #define EFM32_CMU_CTRL_LFXOBUFCUR_SET(x, v)      do { (x) = (((x) & ~0x20000) | ((v) << 17)); } while(0)
/** Configures the start-up delay for LFXO. @multiple */
  #define EFM32_CMU_CTRL_LFXOTIMEOUT_SHIFT         18
  #define EFM32_CMU_CTRL_LFXOTIMEOUT(v)            ((EFM32_CMU_CTRL_LFXOTIMEOUT_##v) << 18)
  #define EFM32_CMU_CTRL_LFXOTIMEOUT_SET(x, v)     do { (x) = (((x) & ~0xc0000) | ((EFM32_CMU_CTRL_LFXOTIMEOUT_##v) << 18)); } while(0)
  #define EFM32_CMU_CTRL_LFXOTIMEOUT_SETVAL(x, v)  do { (x) = (((x) & ~0xc0000) | ((v) << 18)); } while(0)
  #define EFM32_CMU_CTRL_LFXOTIMEOUT_GET(x)        (((x) >> 18) & 0x3)
    #define EFM32_CMU_CTRL_LFXOTIMEOUT_8             0x00000000
    #define EFM32_CMU_CTRL_LFXOTIMEOUT_1K            0x00000001
    #define EFM32_CMU_CTRL_LFXOTIMEOUT_16K           0x00000002
    #define EFM32_CMU_CTRL_LFXOTIMEOUT_32K           0x00000003
/** Controls the clock output multiplexer. To actually output on the pin, set
   CLKOUT0PEN in CMU_ROUTE. @multiple */
  #define EFM32_CMU_CTRL_CLKOUTSEL0_SHIFT          20
  #define EFM32_CMU_CTRL_CLKOUTSEL0(v)             ((EFM32_CMU_CTRL_CLKOUTSEL0_##v) << 20)
  #define EFM32_CMU_CTRL_CLKOUTSEL0_SET(x, v)      do { (x) = (((x) & ~0x700000) | ((EFM32_CMU_CTRL_CLKOUTSEL0_##v) << 20)); } while(0)
  #define EFM32_CMU_CTRL_CLKOUTSEL0_SETVAL(x, v)   do { (x) = (((x) & ~0x700000) | ((v) << 20)); } while(0)
  #define EFM32_CMU_CTRL_CLKOUTSEL0_GET(x)         (((x) >> 20) & 0x7)
    #define EFM32_CMU_CTRL_CLKOUTSEL0_HFRCO          0x00000000
    #define EFM32_CMU_CTRL_CLKOUTSEL0_HFX0           0x00000001
    #define EFM32_CMU_CTRL_CLKOUTSEL0_HFCLK2         0x00000002
    #define EFM32_CMU_CTRL_CLKOUTSEL0_HFCLK4         0x00000003
    #define EFM32_CMU_CTRL_CLKOUTSEL0_HFCLK8         0x00000004
    #define EFM32_CMU_CTRL_CLKOUTSEL0_HFCLK16        0x00000005
    #define EFM32_CMU_CTRL_CLKOUTSEL0_ULFRCO         0x00000006
    #define EFM32_CMU_CTRL_CLKOUTSEL0_AUXHFRC0       0x00000007
# if defined(CONFIG_EFM32_GECKO)
/** Controls the clock output multiplexer. To actually output on the pin, set
   CLKOUT1PEN in CMU_ROUTE. @multiple */
  #define EFM32_CMU_CTRL_CLKOUTSEL1_SHIFT          23
  #define EFM32_CMU_CTRL_CLKOUTSEL1(v)             ((EFM32_CMU_CTRL_CLKOUTSEL1_##v) << 23)
  #define EFM32_CMU_CTRL_CLKOUTSEL1_SET(x, v)      do { (x) = (((x) & ~0x800000) | ((EFM32_CMU_CTRL_CLKOUTSEL1_##v) << 23)); } while(0)
  #define EFM32_CMU_CTRL_CLKOUTSEL1_SETVAL(x, v)   do { (x) = (((x) & ~0x800000) | ((v) << 23)); } while(0)
  #define EFM32_CMU_CTRL_CLKOUTSEL1_GET(x)         (((x) >> 23) & 0x1)
    #define EFM32_CMU_CTRL_CLKOUTSEL1_LFRCO          0x00000000
    #define EFM32_CMU_CTRL_CLKOUTSEL1_LFX0           0x00000001
# endif
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Controls the clock output multiplexer. To actually output on the pin, set
   CLKOUT1PEN in CMU_ROUTE. @multiple */
  #define EFM32_CMU_CTRL_CLKOUTSEL1_SHIFT          23
  #define EFM32_CMU_CTRL_CLKOUTSEL1(v)             ((EFM32_CMU_CTRL_CLKOUTSEL1_##v) << 23)
  #define EFM32_CMU_CTRL_CLKOUTSEL1_SET(x, v)      do { (x) = (((x) & ~0x3800000) | ((EFM32_CMU_CTRL_CLKOUTSEL1_##v) << 23)); } while(0)
  #define EFM32_CMU_CTRL_CLKOUTSEL1_SETVAL(x, v)   do { (x) = (((x) & ~0x3800000) | ((v) << 23)); } while(0)
  #define EFM32_CMU_CTRL_CLKOUTSEL1_GET(x)         (((x) >> 23) & 0x7)
    #define EFM32_CMU_CTRL_CLKOUTSEL1_LFRCO          0x00000000
    #define EFM32_CMU_CTRL_CLKOUTSEL1_LFX0           0x00000001
    #define EFM32_CMU_CTRL_CLKOUTSEL1_HFCLK          0x00000002
    #define EFM32_CMU_CTRL_CLKOUTSEL1_LFXOQ          0x00000003
    #define EFM32_CMU_CTRL_CLKOUTSEL1_HFXOQ          0x00000004
    #define EFM32_CMU_CTRL_CLKOUTSEL1_LFRCOQ         0x00000005
    #define EFM32_CMU_CTRL_CLKOUTSEL1_HFRCOQ         0x00000006
    #define EFM32_CMU_CTRL_CLKOUTSEL1_AUXHFCOQ       0x00000007
# endif
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
/** Select clock used for the debug system @multiple */
  #define EFM32_CMU_CTRL_DBGCLK_SHIFT              28
  #define EFM32_CMU_CTRL_DBGCLK(v)                 ((EFM32_CMU_CTRL_DBGCLK_##v) << 28)
  #define EFM32_CMU_CTRL_DBGCLK_SET(x, v)          do { (x) = (((x) & ~0x10000000) | ((EFM32_CMU_CTRL_DBGCLK_##v) << 28)); } while(0)
  #define EFM32_CMU_CTRL_DBGCLK_SETVAL(x, v)       do { (x) = (((x) & ~0x10000000) | ((v) << 28)); } while(0)
  #define EFM32_CMU_CTRL_DBGCLK_GET(x)             (((x) >> 28) & 0x1)
    #define EFM32_CMU_CTRL_DBGCLK_AUXHFRCO           0x00000000
    #define EFM32_CMU_CTRL_DBGCLK_HFCLK              0x00000001
/** Set to allow access to LE peripheral when running at frequencis higher than
   24Mhz. @multiple */
  #define EFM32_CMU_CTRL_HFLE                      0x40000000
  #define EFM32_CMU_CTRL_HFLE_SHIFT                30
  #define EFM32_CMU_CTRL_HFLE_SET(x, v)            do { (x) = (((x) & ~0x40000000) | ((v) << 30)); } while(0)
# endif

#define EFM32_CMU_HFCORECLKDIV_ADDR                  0x00000004
#define EFM32_CMU_HFCORECLKDIV_MASK                  0x0000000f
/** Specifies the clock divider for the HFCORECLK. @multiple */
  #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_SHIFT 0
  #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV(v)   ((EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_##v) << 0)
  #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_SET(x, v) do { (x) = (((x) & ~0xf) | ((EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_##v) << 0)); } while(0)
  #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_SETVAL(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_GET(x) (((x) >> 0) & 0xf)
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK 0x00000000
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK2 0x00000001
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK4 0x00000002
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK8 0x00000003
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK16 0x00000004
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK32 0x00000005
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK64 0x00000006
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK128 0x00000007
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK256 0x00000008
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK512 0x00000009
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Specifies additional divider for HFCORECLKLE. @multiple */
  #define EFM32_CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT 8
  #define EFM32_CMU_HFCORECLKDIV_HFCORECLKLEDIV(v) ((EFM32_CMU_HFCORECLKDIV_HFCORECLKLEDIV_##v) << 8)
  #define EFM32_CMU_HFCORECLKDIV_HFCORECLKLEDIV_SET(x, v) do { (x) = (((x) & ~0x100) | ((EFM32_CMU_HFCORECLKDIV_HFCORECLKLEDIV_##v) << 8)); } while(0)
  #define EFM32_CMU_HFCORECLKDIV_HFCORECLKLEDIV_SETVAL(x, v) do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
  #define EFM32_CMU_HFCORECLKDIV_HFCORECLKLEDIV_GET(x) (((x) >> 8) & 0x1)
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKLEDIV_DIV2 0x00000000
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKLEDIV_DIV4 0x00000001
# endif

#define EFM32_CMU_HFPERCLKDIV_ADDR                   0x00000008
#define EFM32_CMU_HFPERCLKDIV_MASK                   0x0000010f
/** Specifies the clock divider for the HFPERCLK. @multiple */
  #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_SHIFT  0
  #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV(v)     ((EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_##v) << 0)
  #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_SET(x, v) do { (x) = (((x) & ~0xf) | ((EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_##v) << 0)); } while(0)
  #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_SETVAL(x, v) do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_GET(x) (((x) >> 0) & 0xf)
    #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_HFCLK  0x00000000
    #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_HFCLK2 0x00000001
    #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_HFCLK4 0x00000002
    #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_HFCLK8 0x00000003
    #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_HFCLK16 0x00000004
    #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_HFCLK32 0x00000005
    #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_HFCLK64 0x00000006
    #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_HFCLK128 0x00000007
    #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_HFCLK256 0x00000008
    #define EFM32_CMU_HFPERCLKDIV_HFPERCLKDIV_HFCLK512 0x00000009
/** Set to enable the HFPERCLK. @multiple */
  #define EFM32_CMU_HFPERCLKDIV_HFPERCLKEN         0x00000100
  #define EFM32_CMU_HFPERCLKDIV_HFPERCLKEN_SHIFT   8
  #define EFM32_CMU_HFPERCLKDIV_HFPERCLKEN_SET(x, v) do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)

#define EFM32_CMU_HFRCOCTRL_ADDR                     0x0000000c
#define EFM32_CMU_HFRCOCTRL_MASK                     0x0001f7ff
/** Writing this field adjusts the HFRCO frequency (the higher value, the higher
   frequency). This field is updated with the production calibrated value for the
   14 MHz band during reset, and the reset value might therefore vary between
   devices. @multiple */
  #define EFM32_CMU_HFRCOCTRL_TUNNING_SHIFT        0
  #define EFM32_CMU_HFRCOCTRL_TUNNING(v)           ((v) << 0)
  #define EFM32_CMU_HFRCOCTRL_TUNNING_SET(x, v)    do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define EFM32_CMU_HFRCOCTRL_TUNNING_GET(x)       (((x) >> 0) & 0xff)
/** Write this field to set the frequency band in which the HFRCO is to operate.
   When changing this setting there will be no glitches on the HFRCO output,
   hence it is safe to change this setting even while the system is running on
   the HFRCO. To ensure an accurate frequency, the HFTUNING value should also be
   written when changing the frequency band. The calibrated tuning value for the
   different bands can be read from the Device Information page. @multiple */
  #define EFM32_CMU_HFRCOCTRL_BAND_SHIFT           8
  #define EFM32_CMU_HFRCOCTRL_BAND(v)              ((EFM32_CMU_HFRCOCTRL_BAND_##v) << 8)
  #define EFM32_CMU_HFRCOCTRL_BAND_SET(x, v)       do { (x) = (((x) & ~0x700) | ((EFM32_CMU_HFRCOCTRL_BAND_##v) << 8)); } while(0)
  #define EFM32_CMU_HFRCOCTRL_BAND_SETVAL(x, v)    do { (x) = (((x) & ~0x700) | ((v) << 8)); } while(0)
  #define EFM32_CMU_HFRCOCTRL_BAND_GET(x)          (((x) >> 8) & 0x7)
    #define EFM32_CMU_HFRCOCTRL_BAND_1MHZ            0x00000000
    #define EFM32_CMU_HFRCOCTRL_BAND_7MHZ            0x00000001
    #define EFM32_CMU_HFRCOCTRL_BAND_11MHZ           0x00000002
    #define EFM32_CMU_HFRCOCTRL_BAND_14MHZ           0x00000003
    #define EFM32_CMU_HFRCOCTRL_BAND_21MHZ           0x00000004
/** not available on all devices */
    #define EFM32_CMU_HFRCOCTRL_BAND_28MHZ           0x00000005
/** Always write this field to 0. @multiple */
  #define EFM32_CMU_HFRCOCTRL_SUDELAY_SHIFT        12
  #define EFM32_CMU_HFRCOCTRL_SUDELAY(v)           ((v) << 12)
  #define EFM32_CMU_HFRCOCTRL_SUDELAY_SET(x, v)    do { (x) = (((x) & ~0x1f000) | ((v) << 12)); } while(0)
  #define EFM32_CMU_HFRCOCTRL_SUDELAY_GET(x)       (((x) >> 12) & 0x1f)

#define EFM32_CMU_LFRCOCTRL_ADDR                     0x00000010
#define EFM32_CMU_LFRCOCTRL_MASK                     0x0000007f
/** Writing this field adjusts the LFRCO frequency (the higher value, the higher
   frequency). This field is updated with the production calibrated value during
   reset, and the reset value might therefore vary between devices. @multiple */
  #define EFM32_CMU_LFRCOCTRL_TUNNING_SHIFT        0
  #define EFM32_CMU_LFRCOCTRL_TUNNING(v)           ((v) << 0)
  #define EFM32_CMU_LFRCOCTRL_TUNNING_SET(x, v)    do { (x) = (((x) & ~0x7f) | ((v) << 0)); } while(0)
  #define EFM32_CMU_LFRCOCTRL_TUNNING_GET(x)       (((x) >> 0) & 0x7f)

#define EFM32_CMU_AUXHFRCOCTRL_ADDR                  0x00000014
#define EFM32_CMU_AUXHFRCOCTRL_MASK                  0x000000ff
/** Writing this field adjusts the AUXHFRCO frequency (the higher value, the
   higher frequency). This field is updated with the production calibrated value
   during reset, and the reset value might therefore vary between devices.
   @multiple */
  #define EFM32_CMU_AUXHFRCOCTRL_TUNNING_SHIFT     0
  #define EFM32_CMU_AUXHFRCOCTRL_TUNNING(v)        ((v) << 0)
  #define EFM32_CMU_AUXHFRCOCTRL_TUNNING_SET(x, v) do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define EFM32_CMU_AUXHFRCOCTRL_TUNNING_GET(x)    (((x) >> 0) & 0xff)
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Write this field to set the frequency band in which the HFRCO is to operate.
   When changing this setting there will be no glitches on the AUXHFRCO output,
   hence it is safe to change this setting even while the system is running on
   the AUXHFRCO. To ensure an accurate frequency, the AUXTUNING value should also
   be written when changing the frequency band. The calibrated tuning value for
   the different bands can be read from the Device Information page. Flash erase
   and write use this clock. If it is changed to another value than the default,
   MSC_TIMEBASE must also be configured to ensure correct flash erase and write
   operation. @multiple */
  #define EFM32_CMU_AUXHFRCOCTRL_BAND_SHIFT        8
  #define EFM32_CMU_AUXHFRCOCTRL_BAND(v)           ((EFM32_CMU_AUXHFRCOCTRL_BAND_##v) << 8)
  #define EFM32_CMU_AUXHFRCOCTRL_BAND_SET(x, v)    do { (x) = (((x) & ~0x700) | ((EFM32_CMU_AUXHFRCOCTRL_BAND_##v) << 8)); } while(0)
  #define EFM32_CMU_AUXHFRCOCTRL_BAND_SETVAL(x, v) do { (x) = (((x) & ~0x700) | ((v) << 8)); } while(0)
  #define EFM32_CMU_AUXHFRCOCTRL_BAND_GET(x)       (((x) >> 8) & 0x7)
    #define EFM32_CMU_AUXHFRCOCTRL_BAND_14MHZ        0x00000000
    #define EFM32_CMU_AUXHFRCOCTRL_BAND_11MHZ        0x00000001
    #define EFM32_CMU_AUXHFRCOCTRL_BAND_7MHZ         0x00000002
    #define EFM32_CMU_AUXHFRCOCTRL_BAND_1MHZ         0x00000003
/** not available on all devices */
    #define EFM32_CMU_AUXHFRCOCTRL_BAND_28MHZ        0x00000006
    #define EFM32_CMU_AUXHFRCOCTRL_BAND_21MHZ        0x00000007
# endif

#define EFM32_CMU_CALCTRL_ADDR                       0x00000018
#define EFM32_CMU_CALCTRL_MASK                       0x00000007
/** Selects clock source for the calibration up-counter. @multiple */
  #define EFM32_CMU_CALCTRL_UPSEL_SHIFT            0
  #define EFM32_CMU_CALCTRL_UPSEL(v)               ((EFM32_CMU_CALCTRL_UPSEL_##v) << 0)
  #define EFM32_CMU_CALCTRL_UPSEL_SET(x, v)        do { (x) = (((x) & ~0x7) | ((EFM32_CMU_CALCTRL_UPSEL_##v) << 0)); } while(0)
  #define EFM32_CMU_CALCTRL_UPSEL_SETVAL(x, v)     do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define EFM32_CMU_CALCTRL_UPSEL_GET(x)           (((x) >> 0) & 0x7)
    #define EFM32_CMU_CALCTRL_UPSEL_HFXO             0x00000000
    #define EFM32_CMU_CALCTRL_UPSEL_LFXO             0x00000001
    #define EFM32_CMU_CALCTRL_UPSEL_HFRCO            0x00000002
    #define EFM32_CMU_CALCTRL_UPSEL_LFRCO            0x00000003
    #define EFM32_CMU_CALCTRL_UPSEL_AUXHFRCO         0x00000004
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Selects clock source for the calibration down-counter. @multiple */
  #define EFM32_CMU_CALCTRL_DOWNSEL_SHIFT          3
  #define EFM32_CMU_CALCTRL_DOWNSEL(v)             ((EFM32_CMU_CALCTRL_DOWNSEL_##v) << 3)
  #define EFM32_CMU_CALCTRL_DOWNSEL_SET(x, v)      do { (x) = (((x) & ~0x38) | ((EFM32_CMU_CALCTRL_DOWNSEL_##v) << 3)); } while(0)
  #define EFM32_CMU_CALCTRL_DOWNSEL_SETVAL(x, v)   do { (x) = (((x) & ~0x38) | ((v) << 3)); } while(0)
  #define EFM32_CMU_CALCTRL_DOWNSEL_GET(x)         (((x) >> 3) & 0x7)
    #define EFM32_CMU_CALCTRL_DOWNSEL_HFCLK          0x00000000
    #define EFM32_CMU_CALCTRL_DOWNSEL_HFXO           0x00000001
    #define EFM32_CMU_CALCTRL_DOWNSEL_LFXO           0x00000002
    #define EFM32_CMU_CALCTRL_DOWNSEL_HFRCO          0x00000003
    #define EFM32_CMU_CALCTRL_DOWNSEL_LFRCO          0x00000004
    #define EFM32_CMU_CALCTRL_DOWNSEL_AUXHFRCO       0x00000005
/** Set this bit to enable continuous calibration. @multiple */
  #define EFM32_CMU_CALCTRL_CONT                   0x00000040
  #define EFM32_CMU_CALCTRL_CONT_SHIFT             6
  #define EFM32_CMU_CALCTRL_CONT_SET(x, v)         do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
# endif

#define EFM32_CMU_CALCNT_ADDR                        0x0000001c
#define EFM32_CMU_CALCNT_MASK                        0x000fffff
/** Write top value before calibration. Read calibration result from this
   register when Calibration Ready flag has been set. @multiple */
  #define EFM32_CMU_CALCNT_CALCNT_SHIFT            0
  #define EFM32_CMU_CALCNT_CALCNT(v)               ((v) << 0)
  #define EFM32_CMU_CALCNT_CALCNT_SET(x, v)        do { (x) = (((x) & ~0xfffff) | ((v) << 0)); } while(0)
  #define EFM32_CMU_CALCNT_CALCNT_GET(x)           (((x) >> 0) & 0xfffff)

#define EFM32_CMU_OSCENCMD_ADDR                      0x00000020
#define EFM32_CMU_OSCENCMD_MASK                      0x000003ff
/** Enables the HFRCO. @multiple */
  #define EFM32_CMU_OSCENCMD_HFRCOEN               0x00000001
  #define EFM32_CMU_OSCENCMD_HFRCOEN_SHIFT         0
  #define EFM32_CMU_OSCENCMD_HFRCOEN_SET(x, v)     do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** Disables the HFRCO. HFRCOEN has higher priority if written simultaneously.
   WARNING: Do not disable the HFRCO if this oscillator is selected as the source
   for HFCLK. @multiple */
  #define EFM32_CMU_OSCENCMD_HFRCODIS              0x00000002
  #define EFM32_CMU_OSCENCMD_HFRCODIS_SHIFT        1
  #define EFM32_CMU_OSCENCMD_HFRCODIS_SET(x, v)    do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
/** Enables the HFXO. @multiple */
  #define EFM32_CMU_OSCENCMD_HFXOEN                0x00000004
  #define EFM32_CMU_OSCENCMD_HFXOEN_SHIFT          2
  #define EFM32_CMU_OSCENCMD_HFXOEN_SET(x, v)      do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
/** Disables the HFXO. HFXOEN has higher priority if written simultaneously.
   WARNING: Do not disable the HFRXO if this oscillator is selected as the source
   for HFCLK. @multiple */
  #define EFM32_CMU_OSCENCMD_HFXODIS               0x00000008
  #define EFM32_CMU_OSCENCMD_HFXODIS_SHIFT         3
  #define EFM32_CMU_OSCENCMD_HFXODIS_SET(x, v)     do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
/** Enables the AUXHFRCO. @multiple */
  #define EFM32_CMU_OSCENCMD_AUXHFRCOEN            0x00000010
  #define EFM32_CMU_OSCENCMD_AUXHFRCOEN_SHIFT      4
  #define EFM32_CMU_OSCENCMD_AUXHFRCOEN_SET(x, v)  do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
/** Disables the AUXHFRCO. AUXHFRCOEN has higher priority if written
   simultaneously. WARNING: Do not disable this clock during a flash erase/write
   operation. @multiple */
  #define EFM32_CMU_OSCENCMD_AUXHFRCODIS           0x00000020
  #define EFM32_CMU_OSCENCMD_AUXHFRCODIS_SHIFT     5
  #define EFM32_CMU_OSCENCMD_AUXHFRCODIS_SET(x, v) do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
/** Enables the LFRCO. @multiple */
  #define EFM32_CMU_OSCENCMD_LFRCOEN               0x00000040
  #define EFM32_CMU_OSCENCMD_LFRCOEN_SHIFT         6
  #define EFM32_CMU_OSCENCMD_LFRCOEN_SET(x, v)     do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
/** Disables the LFRCO. LFRCOEN has higher priority if written simultaneously.
   @multiple */
  #define EFM32_CMU_OSCENCMD_LFRCODIS              0x00000080
  #define EFM32_CMU_OSCENCMD_LFRCODIS_SHIFT        7
  #define EFM32_CMU_OSCENCMD_LFRCODIS_SET(x, v)    do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
/** Enables the LFXOEN. @multiple */
  #define EFM32_CMU_OSCENCMD_LFXOEN                0x00000100
  #define EFM32_CMU_OSCENCMD_LFXOEN_SHIFT          8
  #define EFM32_CMU_OSCENCMD_LFXOEN_SET(x, v)      do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
/** Disables the LFXO. LFXOEN has higher priority if written simultaneously.
   @multiple */
  #define EFM32_CMU_OSCENCMD_LFXODIS               0x00000200
  #define EFM32_CMU_OSCENCMD_LFXODIS_SHIFT         9
  #define EFM32_CMU_OSCENCMD_LFXODIS_SET(x, v)     do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)

#define EFM32_CMU_CMD_ADDR                           0x00000024
#define EFM32_CMU_CMD_MASK                           0x0000000f
/** Selects the clock source for HFCLK. Note that selecting an oscillator that is
   disabled will cause the system clock to stop. Check the status register and
   confirm that oscillator is ready before switching. @multiple */
  #define EFM32_CMU_CMD_HFCLKSEL_SHIFT             0
  #define EFM32_CMU_CMD_HFCLKSEL(v)                ((EFM32_CMU_CMD_HFCLKSEL_##v) << 0)
  #define EFM32_CMU_CMD_HFCLKSEL_SET(x, v)         do { (x) = (((x) & ~0x7) | ((EFM32_CMU_CMD_HFCLKSEL_##v) << 0)); } while(0)
  #define EFM32_CMU_CMD_HFCLKSEL_SETVAL(x, v)      do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define EFM32_CMU_CMD_HFCLKSEL_GET(x)            (((x) >> 0) & 0x7)
    #define EFM32_CMU_CMD_HFCLKSEL_HFRCO             0x00000001
    #define EFM32_CMU_CMD_HFCLKSEL_HFXO              0x00000002
    #define EFM32_CMU_CMD_HFCLKSEL_LFRCO             0x00000003
    #define EFM32_CMU_CMD_HFCLKSEL_LFXO              0x00000004
/** Starts the calibration, effectively loading the CMU_CALCNT into the
   down-counter and start decrementing. @multiple */
  #define EFM32_CMU_CMD_CALSTART                   0x00000008
  #define EFM32_CMU_CMD_CALSTART_SHIFT             3
  #define EFM32_CMU_CMD_CALSTART_SET(x, v)         do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Stops the calibration counters. @multiple */
  #define EFM32_CMU_CMD_CALSTOP                    0x00000010
  #define EFM32_CMU_CMD_CALSTOP_SHIFT              4
  #define EFM32_CMU_CMD_CALSTOP_SET(x, v)          do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
# endif
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
/** Selects the clock for HFCORECLKUSBC. Thes tatus register is updated chen the
   clock switch has taken effect. @multiple */
  #define EFM32_CMU_CMD_USBCCLKSEL_SHIFT           5
  #define EFM32_CMU_CMD_USBCCLKSEL(v)              ((EFM32_CMU_CMD_USBCCLKSEL_##v) << 5)
  #define EFM32_CMU_CMD_USBCCLKSEL_SET(x, v)       do { (x) = (((x) & ~0x60) | ((EFM32_CMU_CMD_USBCCLKSEL_##v) << 5)); } while(0)
  #define EFM32_CMU_CMD_USBCCLKSEL_SETVAL(x, v)    do { (x) = (((x) & ~0x60) | ((v) << 5)); } while(0)
  #define EFM32_CMU_CMD_USBCCLKSEL_GET(x)          (((x) >> 5) & 0x3)
    #define EFM32_CMU_CMD_USBCCLKSEL_HFCLKNODIV      0x00000001
    #define EFM32_CMU_CMD_USBCCLKSEL_LFXO            0x00000002
    #define EFM32_CMU_CMD_USBCCLKSEL_LFRCO           0x00000003
# endif

#define EFM32_CMU_LFCLKSEL_ADDR                      0x00000028
#define EFM32_CMU_LFCLKSEL_MASK                      0x0000000f
/** Selects the clock source for LFACLK. Tied to LFAE. @multiple */
  #define EFM32_CMU_LFCLKSEL_LFA_SHIFT             0
  #define EFM32_CMU_LFCLKSEL_LFA(v)                ((EFM32_CMU_LFCLKSEL_LFA_##v) << 0)
  #define EFM32_CMU_LFCLKSEL_LFA_SET(x, v)         do { (x) = (((x) & ~0x3) | ((EFM32_CMU_LFCLKSEL_LFA_##v) << 0)); } while(0)
  #define EFM32_CMU_LFCLKSEL_LFA_SETVAL(x, v)      do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define EFM32_CMU_LFCLKSEL_LFA_GET(x)            (((x) >> 0) & 0x3)
    #define EFM32_CMU_LFCLKSEL_LFA_DISABLED_OR_ULFRCO 0x00000000
    #define EFM32_CMU_LFCLKSEL_LFA_LFRCO             0x00000001
    #define EFM32_CMU_LFCLKSEL_LFA_LFXO              0x00000002
    #define EFM32_CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2   0x00000003
/** Selects the clock source for LFBCLK. Tied to LFBE. @multiple */
  #define EFM32_CMU_LFCLKSEL_LFB_SHIFT             2
  #define EFM32_CMU_LFCLKSEL_LFB(v)                ((EFM32_CMU_LFCLKSEL_LFB_##v) << 2)
  #define EFM32_CMU_LFCLKSEL_LFB_SET(x, v)         do { (x) = (((x) & ~0xc) | ((EFM32_CMU_LFCLKSEL_LFB_##v) << 2)); } while(0)
  #define EFM32_CMU_LFCLKSEL_LFB_SETVAL(x, v)      do { (x) = (((x) & ~0xc) | ((v) << 2)); } while(0)
  #define EFM32_CMU_LFCLKSEL_LFB_GET(x)            (((x) >> 2) & 0x3)
    #define EFM32_CMU_LFCLKSEL_LFB_DISABLED_OR_ULFRCO 0x00000000
    #define EFM32_CMU_LFCLKSEL_LFB_LFRCO             0x00000001
    #define EFM32_CMU_LFCLKSEL_LFB_LFXO              0x00000002
    #define EFM32_CMU_LFCLKSEL_LFB_HFCORECLKLEDIV2   0x00000003
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** This bit redefines the meaning of the LFA field. @multiple */
  #define EFM32_CMU_LFCLKSEL_LFAE_SHIFT            16
  #define EFM32_CMU_LFCLKSEL_LFAE(v)               ((EFM32_CMU_LFCLKSEL_LFAE_##v) << 16)
  #define EFM32_CMU_LFCLKSEL_LFAE_SET(x, v)        do { (x) = (((x) & ~0x10000) | ((EFM32_CMU_LFCLKSEL_LFAE_##v) << 16)); } while(0)
  #define EFM32_CMU_LFCLKSEL_LFAE_SETVAL(x, v)     do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
  #define EFM32_CMU_LFCLKSEL_LFAE_GET(x)           (((x) >> 16) & 0x1)
    #define EFM32_CMU_LFCLKSEL_LFAE_DISABLED         0x00000000
    #define EFM32_CMU_LFCLKSEL_LFAE_ULFRCO           0x00000001
/** This bit redefines the meaning of the LFB field. @multiple */
  #define EFM32_CMU_LFCLKSEL_LFBE_SHIFT            20
  #define EFM32_CMU_LFCLKSEL_LFBE(v)               ((EFM32_CMU_LFCLKSEL_LFBE_##v) << 20)
  #define EFM32_CMU_LFCLKSEL_LFBE_SET(x, v)        do { (x) = (((x) & ~0x100000) | ((EFM32_CMU_LFCLKSEL_LFBE_##v) << 20)); } while(0)
  #define EFM32_CMU_LFCLKSEL_LFBE_SETVAL(x, v)     do { (x) = (((x) & ~0x100000) | ((v) << 20)); } while(0)
  #define EFM32_CMU_LFCLKSEL_LFBE_GET(x)           (((x) >> 20) & 0x1)
    #define EFM32_CMU_LFCLKSEL_LFBE_DISABLED         0x00000000
    #define EFM32_CMU_LFCLKSEL_LFBE_ULFRCO           0x00000001
# endif

#define EFM32_CMU_STATUS_ADDR                        0x0000002c
#define EFM32_CMU_STATUS_MASK                        0x00007fff
/** HFRCO is enabled. @multiple */
  #define EFM32_CMU_STATUS_HFRCOENS                0x00000001
  #define EFM32_CMU_STATUS_HFRCOENS_SHIFT          0
  #define EFM32_CMU_STATUS_HFRCOENS_SET(x, v)      do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** HFRCO is enabled and start-up time has exceeded. @multiple */
  #define EFM32_CMU_STATUS_HFRCORDY                0x00000002
  #define EFM32_CMU_STATUS_HFRCORDY_SHIFT          1
  #define EFM32_CMU_STATUS_HFRCORDY_SET(x, v)      do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
/** HFXO is enabled. @multiple */
  #define EFM32_CMU_STATUS_HFXOENS                 0x00000004
  #define EFM32_CMU_STATUS_HFXOENS_SHIFT           2
  #define EFM32_CMU_STATUS_HFXOENS_SET(x, v)       do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
/** HFXO is enabled and start-up time has exceeded. @multiple */
  #define EFM32_CMU_STATUS_HFXORDY                 0x00000008
  #define EFM32_CMU_STATUS_HFXORDY_SHIFT           3
  #define EFM32_CMU_STATUS_HFXORDY_SET(x, v)       do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
/** AUXHFRCO is enabled. @multiple */
  #define EFM32_CMU_STATUS_AUXHFRCOENS             0x00000010
  #define EFM32_CMU_STATUS_AUXHFRCOENS_SHIFT       4
  #define EFM32_CMU_STATUS_AUXHFRCOENS_SET(x, v)   do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
/** AUXHFRCO is enabled and start-up time has exceeded. @multiple */
  #define EFM32_CMU_STATUS_AUXHFRCORDY             0x00000020
  #define EFM32_CMU_STATUS_AUXHFRCORDY_SHIFT       5
  #define EFM32_CMU_STATUS_AUXHFRCORDY_SET(x, v)   do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
/** LFRCO is enabled. @multiple */
  #define EFM32_CMU_STATUS_LFRCOENS                0x00000040
  #define EFM32_CMU_STATUS_LFRCOENS_SHIFT          6
  #define EFM32_CMU_STATUS_LFRCOENS_SET(x, v)      do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
/** LFRCO is enabled and start-up time has exceeded. @multiple */
  #define EFM32_CMU_STATUS_LFRCORDY                0x00000080
  #define EFM32_CMU_STATUS_LFRCORDY_SHIFT          7
  #define EFM32_CMU_STATUS_LFRCORDY_SET(x, v)      do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
/** LFXO is enabled. @multiple */
  #define EFM32_CMU_STATUS_LFXOENS                 0x00000100
  #define EFM32_CMU_STATUS_LFXOENS_SHIFT           8
  #define EFM32_CMU_STATUS_LFXOENS_SET(x, v)       do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
/** LFXO is enabled and start-up time has exceeded. @multiple */
  #define EFM32_CMU_STATUS_LFXORDY                 0x00000200
  #define EFM32_CMU_STATUS_LFXORDY_SHIFT           9
  #define EFM32_CMU_STATUS_LFXORDY_SET(x, v)       do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
/** HFRCO is selected as HFCLK clock source. @multiple */
  #define EFM32_CMU_STATUS_HFRCOSEL                0x00000400
  #define EFM32_CMU_STATUS_HFRCOSEL_SHIFT          10
  #define EFM32_CMU_STATUS_HFRCOSEL_SET(x, v)      do { (x) = (((x) & ~0x400) | ((v) << 10)); } while(0)
/** HFXO is selected as HFCLK clock source. @multiple */
  #define EFM32_CMU_STATUS_HFXOSEL                 0x00000800
  #define EFM32_CMU_STATUS_HFXOSEL_SHIFT           11
  #define EFM32_CMU_STATUS_HFXOSEL_SET(x, v)       do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
/** LFRCO is selected as HFCLK clock source. @multiple */
  #define EFM32_CMU_STATUS_LFRCOSEL                0x00001000
  #define EFM32_CMU_STATUS_LFRCOSEL_SHIFT          12
  #define EFM32_CMU_STATUS_LFRCOSEL_SET(x, v)      do { (x) = (((x) & ~0x1000) | ((v) << 12)); } while(0)
/** LFXO is selected as HFCLK clock source. @multiple */
  #define EFM32_CMU_STATUS_LFXOSEL                 0x00002000
  #define EFM32_CMU_STATUS_LFXOSEL_SHIFT           13
  #define EFM32_CMU_STATUS_LFXOSEL_SET(x, v)       do { (x) = (((x) & ~0x2000) | ((v) << 13)); } while(0)
/** Calibration is on-going. @multiple */
  #define EFM32_CMU_STATUS_CALBSY                  0x00004000
  #define EFM32_CMU_STATUS_CALBSY_SHIFT            14
  #define EFM32_CMU_STATUS_CALBSY_SET(x, v)        do { (x) = (((x) & ~0x4000) | ((v) << 14)); } while(0)
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
/** HFCLK is selected (and active) as HFCORECLKUSBC @multiple */
  #define EFM32_CMU_STATUS_USBCHFCLKSEL            0x00008000
  #define EFM32_CMU_STATUS_USBCHFCLKSEL_SHIFT      15
  #define EFM32_CMU_STATUS_USBCHFCLKSEL_SET(x, v)  do { (x) = (((x) & ~0x8000) | ((v) << 15)); } while(0)
/** LFXO is selected (and active) as HFCORECLKUSBC @multiple */
  #define EFM32_CMU_STATUS_USBCLFXOSEL             0x00010000
  #define EFM32_CMU_STATUS_USBCLFXOSEL_SHIFT       16
  #define EFM32_CMU_STATUS_USBCLFXOSEL_SET(x, v)   do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
/** LFRCO is selected (and active) as HFCORECLKUSBC @multiple */
  #define EFM32_CMU_STATUS_USBCLFRCOSEL            0x00020000
  #define EFM32_CMU_STATUS_USBCLFRCOSEL_SHIFT      17
  #define EFM32_CMU_STATUS_USBCLFRCOSEL_SET(x, v)  do { (x) = (((x) & ~0x20000) | ((v) << 17)); } while(0)
# endif

#define EFM32_CMU_IF_ADDR                            0x00000030
#define EFM32_CMU_IF_MASK                            0x0000003f
/** Set when HFRCO is ready (start-up time exceeded). @multiple */
  #define EFM32_CMU_IF_HFRCORDY                    0x00000001
  #define EFM32_CMU_IF_HFRCORDY_SHIFT              0
  #define EFM32_CMU_IF_HFRCORDY_SET(x, v)          do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** Set when HFXO is ready (start-up time exceeded). @multiple */
  #define EFM32_CMU_IF_HFXORDY                     0x00000002
  #define EFM32_CMU_IF_HFXORDY_SHIFT               1
  #define EFM32_CMU_IF_HFXORDY_SET(x, v)           do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
/** Set when LFRCO is ready (start-up time exceeded). @multiple */
  #define EFM32_CMU_IF_LFRCORDY                    0x00000004
  #define EFM32_CMU_IF_LFRCORDY_SHIFT              2
  #define EFM32_CMU_IF_LFRCORDY_SET(x, v)          do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
/** Set when LFXO is ready (start-up time exceeded). @multiple */
  #define EFM32_CMU_IF_LFXORDY                     0x00000008
  #define EFM32_CMU_IF_LFXORDY_SHIFT               3
  #define EFM32_CMU_IF_LFXORDY_SET(x, v)           do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
/** Set when AUXHFRCO is ready (start-up time exceeded). @multiple */
  #define EFM32_CMU_IF_AUXHFRCORDY                 0x00000010
  #define EFM32_CMU_IF_AUXHFRCORDY_SHIFT           4
  #define EFM32_CMU_IF_AUXHFRCORDY_SET(x, v)       do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
/** Set when calibration is completed. @multiple */
  #define EFM32_CMU_IF_CALRDY                      0x00000020
  #define EFM32_CMU_IF_CALRDY_SHIFT                5
  #define EFM32_CMU_IF_CALRDY_SET(x, v)            do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Set when calibration overflow has occurred @multiple */
  #define EFM32_CMU_IF_CALOF                       0x00000040
  #define EFM32_CMU_IF_CALOF_SHIFT                 6
  #define EFM32_CMU_IF_CALOF_SET(x, v)             do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
# endif
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
/** set when HFCLK is selected as HFCORECLKUSBC @multiple */
  #define EFM32_CMU_IF_USBCHFCLKSEL                0x00000080
  #define EFM32_CMU_IF_USBCHFCLKSEL_SHIFT          7
  #define EFM32_CMU_IF_USBCHFCLKSEL_SET(x, v)      do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
# endif

#define EFM32_CMU_IFS_ADDR                           0x00000034
#define EFM32_CMU_IFS_MASK                           0x0000003f
/** Write to 1 to set the HFRCO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFS_HFRCORDY                   0x00000001
  #define EFM32_CMU_IFS_HFRCORDY_SHIFT             0
  #define EFM32_CMU_IFS_HFRCORDY_SET(x, v)         do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** Write to 1 to set the HFXO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFS_HFXORDY                    0x00000002
  #define EFM32_CMU_IFS_HFXORDY_SHIFT              1
  #define EFM32_CMU_IFS_HFXORDY_SET(x, v)          do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
/** Write to 1 to set the LFRCO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFS_LFRCORDY                   0x00000004
  #define EFM32_CMU_IFS_LFRCORDY_SHIFT             2
  #define EFM32_CMU_IFS_LFRCORDY_SET(x, v)         do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
/** Write to 1 to set the LFXO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFS_LFXORDY                    0x00000008
  #define EFM32_CMU_IFS_LFXORDY_SHIFT              3
  #define EFM32_CMU_IFS_LFXORDY_SET(x, v)          do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
/** Write to 1 to set the AUXHFRCO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFS_AUXHFRCORDY                0x00000010
  #define EFM32_CMU_IFS_AUXHFRCORDY_SHIFT          4
  #define EFM32_CMU_IFS_AUXHFRCORDY_SET(x, v)      do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
/** Write to 1 to set the Calibration Ready(completed) Interrupt Flag. @multiple
   */
  #define EFM32_CMU_IFS_CALRDY                     0x00000020
  #define EFM32_CMU_IFS_CALRDY_SHIFT               5
  #define EFM32_CMU_IFS_CALRDY_SET(x, v)           do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Write to 1 to set the Calibration Overflow Interrupt Flag. @multiple */
  #define EFM32_CMU_IFS_CALOF                      0x00000040
  #define EFM32_CMU_IFS_CALOF_SHIFT                6
  #define EFM32_CMU_IFS_CALOF_SET(x, v)            do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
# endif
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
/** set when HFCLK is selected as HFCORECLKUSBC @multiple */
  #define EFM32_CMU_IFS_USBCHFCLKSEL               0x00000080
  #define EFM32_CMU_IFS_USBCHFCLKSEL_SHIFT         7
  #define EFM32_CMU_IFS_USBCHFCLKSEL_SET(x, v)     do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
# endif

#define EFM32_CMU_IFC_ADDR                           0x00000038
#define EFM32_CMU_IFC_MASK                           0x0000003f
/** Write to 1 to clear the HFRCO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFC_HFRCORDY                   0x00000001
  #define EFM32_CMU_IFC_HFRCORDY_SHIFT             0
  #define EFM32_CMU_IFC_HFRCORDY_SET(x, v)         do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** Write to 1 to clear the HFXO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFC_HFXORDY                    0x00000002
  #define EFM32_CMU_IFC_HFXORDY_SHIFT              1
  #define EFM32_CMU_IFC_HFXORDY_SET(x, v)          do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
/** Write to 1 to clear the LFRCO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFC_LFRCORDY                   0x00000004
  #define EFM32_CMU_IFC_LFRCORDY_SHIFT             2
  #define EFM32_CMU_IFC_LFRCORDY_SET(x, v)         do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
/** Write to 1 to clear the LFXO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFC_LFXORDY                    0x00000008
  #define EFM32_CMU_IFC_LFXORDY_SHIFT              3
  #define EFM32_CMU_IFC_LFXORDY_SET(x, v)          do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
/** Write to 1 to clear the AUXHFRCO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFC_AUXHFRCORDY                0x00000010
  #define EFM32_CMU_IFC_AUXHFRCORDY_SHIFT          4
  #define EFM32_CMU_IFC_AUXHFRCORDY_SET(x, v)      do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
/** Write to 1 to clear the Calibration Ready(completed) Interrupt Flag.
   @multiple */
  #define EFM32_CMU_IFC_CALRDY                     0x00000020
  #define EFM32_CMU_IFC_CALRDY_SHIFT               5
  #define EFM32_CMU_IFC_CALRDY_SET(x, v)           do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Write to 1 to clear the Calibration Overflow Interrupt Flag. @multiple */
  #define EFM32_CMU_IFC_CALOF                      0x00000040
  #define EFM32_CMU_IFC_CALOF_SHIFT                6
  #define EFM32_CMU_IFC_CALOF_SET(x, v)            do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
# endif
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
/** set when HFCLK is selected as HFCORECLKUSBC @multiple */
  #define EFM32_CMU_IFC_USBCHFCLKSEL               0x00000080
  #define EFM32_CMU_IFC_USBCHFCLKSEL_SHIFT         7
  #define EFM32_CMU_IFC_USBCHFCLKSEL_SET(x, v)     do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
# endif

#define EFM32_CMU_IEN_ADDR                           0x0000003c
#define EFM32_CMU_IEN_MASK                           0x0000003f
/** Set to enable the HFRCO Ready Interrupt. @multiple */
  #define EFM32_CMU_IEN_HFRCORDY                   0x00000001
  #define EFM32_CMU_IEN_HFRCORDY_SHIFT             0
  #define EFM32_CMU_IEN_HFRCORDY_SET(x, v)         do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** Set to enable the HFXO Ready Interrupt. @multiple */
  #define EFM32_CMU_IEN_HFXORDY                    0x00000002
  #define EFM32_CMU_IEN_HFXORDY_SHIFT              1
  #define EFM32_CMU_IEN_HFXORDY_SET(x, v)          do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
/** Set to enable the LFRCO Ready Interrupt. @multiple */
  #define EFM32_CMU_IEN_LFRCORDY                   0x00000004
  #define EFM32_CMU_IEN_LFRCORDY_SHIFT             2
  #define EFM32_CMU_IEN_LFRCORDY_SET(x, v)         do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
/** Set to enable the LFXO Ready Interrupt. @multiple */
  #define EFM32_CMU_IEN_LFXORDY                    0x00000008
  #define EFM32_CMU_IEN_LFXORDY_SHIFT              3
  #define EFM32_CMU_IEN_LFXORDY_SET(x, v)          do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
/** Set to enable the AUXHFRCO Ready Interrupt. @multiple */
  #define EFM32_CMU_IEN_AUXHFRCORDY                0x00000010
  #define EFM32_CMU_IEN_AUXHFRCORDY_SHIFT          4
  #define EFM32_CMU_IEN_AUXHFRCORDY_SET(x, v)      do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
/** Set to enable the Calibration Ready(completed) Interrupt. @multiple */
  #define EFM32_CMU_IEN_CALRDY                     0x00000020
  #define EFM32_CMU_IEN_CALRDY_SHIFT               5
  #define EFM32_CMU_IEN_CALRDY_SET(x, v)           do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Set to enable the Calibration Overflow Interrupt. @multiple */
  #define EFM32_CMU_IEN_CALOF                      0x00000040
  #define EFM32_CMU_IEN_CALOF_SHIFT                6
  #define EFM32_CMU_IEN_CALOF_SET(x, v)            do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
# endif
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
/** set when HFCLK is selected as HFCORECLKUSBC @multiple */
  #define EFM32_CMU_IEN_USBCHFCLKSEL               0x00000080
  #define EFM32_CMU_IEN_USBCHFCLKSEL_SHIFT         7
  #define EFM32_CMU_IEN_USBCHFCLKSEL_SET(x, v)     do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
# endif

# if defined(CONFIG_EFM32_GECKO)
#define EFM32_CMU_HFCORECLKEN0_ADDR                  0x00000040
#define EFM32_CMU_HFCORECLKEN0_MASK                  0x0000000f
/** Set to enable the clock for AES. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_AES               0x00000001
  #define EFM32_CMU_HFCORECLKEN0_AES_SHIFT         0
  #define EFM32_CMU_HFCORECLKEN0_AES_SET(x, v)     do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** Set to enable the clock for DMA. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_DMA               0x00000002
  #define EFM32_CMU_HFCORECLKEN0_DMA_SHIFT         1
  #define EFM32_CMU_HFCORECLKEN0_DMA_SET(x, v)     do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
/** Set to enable the clock for LE. Interface used for bus access to Low Energy
   peripherals. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_LE                0x00000004
  #define EFM32_CMU_HFCORECLKEN0_LE_SHIFT          2
  #define EFM32_CMU_HFCORECLKEN0_LE_SET(x, v)      do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
/** Set to enable the clock for EBI. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_EBI               0x00000008
  #define EFM32_CMU_HFCORECLKEN0_EBI_SHIFT         3
  #define EFM32_CMU_HFCORECLKEN0_EBI_SET(x, v)     do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
# endif

# if defined(CONFIG_EFM32_ZERO_GECKO)
#define EFM32_CMU_HFCORECLKEN0_ADDR                  0x00000040
#define EFM32_CMU_HFCORECLKEN0_MASK                  0x00000007
/** Set to enable the clock for AES. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_AES               0x00000001
  #define EFM32_CMU_HFCORECLKEN0_AES_SHIFT         0
  #define EFM32_CMU_HFCORECLKEN0_AES_SET(x, v)     do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** Set to enable the clock for DMA. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_DMA               0x00000002
  #define EFM32_CMU_HFCORECLKEN0_DMA_SHIFT         1
  #define EFM32_CMU_HFCORECLKEN0_DMA_SET(x, v)     do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
/** Set to enable the clock for LE. Interface used for bus access to Low Energy
   peripherals. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_LE                0x00000004
  #define EFM32_CMU_HFCORECLKEN0_LE_SHIFT          2
  #define EFM32_CMU_HFCORECLKEN0_LE_SET(x, v)      do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
# endif

# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
#define EFM32_CMU_HFCORECLKEN0_ADDR                  0x00000040
#define EFM32_CMU_HFCORECLKEN0_MASK                  0x0000003f
/** Set to enable the clock for DMA. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_DMA               0x00000001
  #define EFM32_CMU_HFCORECLKEN0_DMA_SHIFT         0
  #define EFM32_CMU_HFCORECLKEN0_DMA_SET(x, v)     do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** Set to enable the clock for AES. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_AES               0x00000002
  #define EFM32_CMU_HFCORECLKEN0_AES_SHIFT         1
  #define EFM32_CMU_HFCORECLKEN0_AES_SET(x, v)     do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
/** Set to enable the clock for USBC. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_USBC              0x00000004
  #define EFM32_CMU_HFCORECLKEN0_USBC_SHIFT        2
  #define EFM32_CMU_HFCORECLKEN0_USBC_SET(x, v)    do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
/** Set to enable the clock for USB. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_USB               0x00000008
  #define EFM32_CMU_HFCORECLKEN0_USB_SHIFT         3
  #define EFM32_CMU_HFCORECLKEN0_USB_SET(x, v)     do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
/** Set to enable the clock for LE. Interface used for bus access to Low Energy
   peripherals. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_LE                0x00000010
  #define EFM32_CMU_HFCORECLKEN0_LE_SHIFT          4
  #define EFM32_CMU_HFCORECLKEN0_LE_SET(x, v)      do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
/** Set to enable the clock for EBI. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_EBI               0x00000020
  #define EFM32_CMU_HFCORECLKEN0_EBI_SHIFT         5
  #define EFM32_CMU_HFCORECLKEN0_EBI_SET(x, v)     do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
# endif

# if defined(CONFIG_EFM32_GECKO)
#define EFM32_CMU_HFPERCLKEN0_ADDR                   0x00000044
#define EFM32_CMU_HFPERCLKEN0_MASK                   0x0000fdff
/** Set to enable the clock for USART1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_USART0             0x00000001
  #define EFM32_CMU_HFPERCLKEN0_USART0_SHIFT       0
  #define EFM32_CMU_HFPERCLKEN0_USART0_SET(x, v)   do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** Set to enable the clock for USART1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_USART1             0x00000002
  #define EFM32_CMU_HFPERCLKEN0_USART1_SHIFT       1
  #define EFM32_CMU_HFPERCLKEN0_USART1_SET(x, v)   do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
/** Set to enable the clock for USART1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_USART2             0x00000004
  #define EFM32_CMU_HFPERCLKEN0_USART2_SHIFT       2
  #define EFM32_CMU_HFPERCLKEN0_USART2_SET(x, v)   do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
/** Set to enable the clock for USART1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_UART0              0x00000008
  #define EFM32_CMU_HFPERCLKEN0_UART0_SHIFT        3
  #define EFM32_CMU_HFPERCLKEN0_UART0_SET(x, v)    do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
/** Set to enable the clock for TIMER0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER0             0x00000010
  #define EFM32_CMU_HFPERCLKEN0_TIMER0_SHIFT       4
  #define EFM32_CMU_HFPERCLKEN0_TIMER0_SET(x, v)   do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
/** Set to enable the clock for TIMER1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER1             0x00000020
  #define EFM32_CMU_HFPERCLKEN0_TIMER1_SHIFT       5
  #define EFM32_CMU_HFPERCLKEN0_TIMER1_SET(x, v)   do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
/** Set to enable the clock for TIMER1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER2             0x00000040
  #define EFM32_CMU_HFPERCLKEN0_TIMER2_SHIFT       6
  #define EFM32_CMU_HFPERCLKEN0_TIMER2_SET(x, v)   do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
/** Set to enable the clock for ACMP0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ACMP0              0x00000080
  #define EFM32_CMU_HFPERCLKEN0_ACMP0_SHIFT        7
  #define EFM32_CMU_HFPERCLKEN0_ACMP0_SET(x, v)    do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
/** Set to enable the clock for ACMP0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ACMP1              0x00000100
  #define EFM32_CMU_HFPERCLKEN0_ACMP1_SHIFT        8
  #define EFM32_CMU_HFPERCLKEN0_ACMP1_SET(x, v)    do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
/** Set to enable the clock for PRS. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_PRS                0x00000400
  #define EFM32_CMU_HFPERCLKEN0_PRS_SHIFT          10
  #define EFM32_CMU_HFPERCLKEN0_PRS_SET(x, v)      do { (x) = (((x) & ~0x400) | ((v) << 10)); } while(0)
/** Set to enable the clock for DAC0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_DAC0               0x00000800
  #define EFM32_CMU_HFPERCLKEN0_DAC0_SHIFT         11
  #define EFM32_CMU_HFPERCLKEN0_DAC0_SET(x, v)     do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
/** Set to enable the clock for GPIO. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_GPIO               0x00001000
  #define EFM32_CMU_HFPERCLKEN0_GPIO_SHIFT         12
  #define EFM32_CMU_HFPERCLKEN0_GPIO_SET(x, v)     do { (x) = (((x) & ~0x1000) | ((v) << 12)); } while(0)
/** Set to enable the clock for VCMP. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_VCMP               0x00002000
  #define EFM32_CMU_HFPERCLKEN0_VCMP_SHIFT         13
  #define EFM32_CMU_HFPERCLKEN0_VCMP_SET(x, v)     do { (x) = (((x) & ~0x2000) | ((v) << 13)); } while(0)
/** Set to enable the clock for ADC0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ADC0               0x00004000
  #define EFM32_CMU_HFPERCLKEN0_ADC0_SHIFT         14
  #define EFM32_CMU_HFPERCLKEN0_ADC0_SET(x, v)     do { (x) = (((x) & ~0x4000) | ((v) << 14)); } while(0)
/** Set to enable the clock for I2C0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_I2C0               0x00008000
  #define EFM32_CMU_HFPERCLKEN0_I2C0_SHIFT         15
  #define EFM32_CMU_HFPERCLKEN0_I2C0_SET(x, v)     do { (x) = (((x) & ~0x8000) | ((v) << 15)); } while(0)
# endif

# if defined(CONFIG_EFM32_ZERO_GECKO)
#define EFM32_CMU_HFPERCLKEN0_ADDR                   0x00000044
#define EFM32_CMU_HFPERCLKEN0_MASK                   0x00000ddf
/** Set to enable the clock for TIMER0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER0             0x00000001
  #define EFM32_CMU_HFPERCLKEN0_TIMER0_SHIFT       0
  #define EFM32_CMU_HFPERCLKEN0_TIMER0_SET(x, v)   do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** Set to enable the clock for TIMER1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER1             0x00000002
  #define EFM32_CMU_HFPERCLKEN0_TIMER1_SHIFT       1
  #define EFM32_CMU_HFPERCLKEN0_TIMER1_SET(x, v)   do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
/** Set to enable the clock for ACMP0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ACMP0              0x00000004
  #define EFM32_CMU_HFPERCLKEN0_ACMP0_SHIFT        2
  #define EFM32_CMU_HFPERCLKEN0_ACMP0_SET(x, v)    do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
/** Set to enable the clock for USART1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_USART1             0x00000008
  #define EFM32_CMU_HFPERCLKEN0_USART1_SHIFT       3
  #define EFM32_CMU_HFPERCLKEN0_USART1_SET(x, v)   do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
/** Set to enable the clock for PRS. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_PRS                0x00000010
  #define EFM32_CMU_HFPERCLKEN0_PRS_SHIFT          4
  #define EFM32_CMU_HFPERCLKEN0_PRS_SET(x, v)      do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
/** Set to enable the clock for IDAC0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_IDAC0              0x00000040
  #define EFM32_CMU_HFPERCLKEN0_IDAC0_SHIFT        6
  #define EFM32_CMU_HFPERCLKEN0_IDAC0_SET(x, v)    do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
/** Set to enable the clock for GPIO. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_GPIO               0x00000080
  #define EFM32_CMU_HFPERCLKEN0_GPIO_SHIFT         7
  #define EFM32_CMU_HFPERCLKEN0_GPIO_SET(x, v)     do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
/** Set to enable the clock for VCMP. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_VCMP               0x00000100
  #define EFM32_CMU_HFPERCLKEN0_VCMP_SHIFT         8
  #define EFM32_CMU_HFPERCLKEN0_VCMP_SET(x, v)     do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
/** Set to enable the clock for ADC0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ADC0               0x00000400
  #define EFM32_CMU_HFPERCLKEN0_ADC0_SHIFT         10
  #define EFM32_CMU_HFPERCLKEN0_ADC0_SET(x, v)     do { (x) = (((x) & ~0x400) | ((v) << 10)); } while(0)
/** Set to enable the clock for I2C0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_I2C0               0x00000800
  #define EFM32_CMU_HFPERCLKEN0_I2C0_SHIFT         11
  #define EFM32_CMU_HFPERCLKEN0_I2C0_SET(x, v)     do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
# endif

# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
#define EFM32_CMU_HFPERCLKEN0_ADDR                   0x00000044
#define EFM32_CMU_HFPERCLKEN0_MASK                   0x0003ffff
/** Set to enable the clock for USART0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_USART0             0x00000001
  #define EFM32_CMU_HFPERCLKEN0_USART0_SHIFT       0
  #define EFM32_CMU_HFPERCLKEN0_USART0_SET(x, v)   do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** Set to enable the clock for USART1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_USART1             0x00000002
  #define EFM32_CMU_HFPERCLKEN0_USART1_SHIFT       1
  #define EFM32_CMU_HFPERCLKEN0_USART1_SET(x, v)   do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
/** Set to enable the clock for USART2. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_USART2             0x00000004
  #define EFM32_CMU_HFPERCLKEN0_USART2_SHIFT       2
  #define EFM32_CMU_HFPERCLKEN0_USART2_SET(x, v)   do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
/** Set to enable the clock for UART0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_UART0              0x00000008
  #define EFM32_CMU_HFPERCLKEN0_UART0_SHIFT        3
  #define EFM32_CMU_HFPERCLKEN0_UART0_SET(x, v)    do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
/** Set to enable the clock for UART1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_UART1              0x00000010
  #define EFM32_CMU_HFPERCLKEN0_UART1_SHIFT        4
  #define EFM32_CMU_HFPERCLKEN0_UART1_SET(x, v)    do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
/** Set to enable the clock for timer0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER0             0x00000020
  #define EFM32_CMU_HFPERCLKEN0_TIMER0_SHIFT       5
  #define EFM32_CMU_HFPERCLKEN0_TIMER0_SET(x, v)   do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
/** Set to enable the clock for timer1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER1             0x00000040
  #define EFM32_CMU_HFPERCLKEN0_TIMER1_SHIFT       6
  #define EFM32_CMU_HFPERCLKEN0_TIMER1_SET(x, v)   do { (x) = (((x) & ~0x40) | ((v) << 6)); } while(0)
/** Set to enable the clock for timer2. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER2             0x00000080
  #define EFM32_CMU_HFPERCLKEN0_TIMER2_SHIFT       7
  #define EFM32_CMU_HFPERCLKEN0_TIMER2_SET(x, v)   do { (x) = (((x) & ~0x80) | ((v) << 7)); } while(0)
/** Set to enable the clock for timer3. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER3             0x00000100
  #define EFM32_CMU_HFPERCLKEN0_TIMER3_SHIFT       8
  #define EFM32_CMU_HFPERCLKEN0_TIMER3_SET(x, v)   do { (x) = (((x) & ~0x100) | ((v) << 8)); } while(0)
/** Set to enable the clock for ACMP0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ACMP0              0x00000200
  #define EFM32_CMU_HFPERCLKEN0_ACMP0_SHIFT        9
  #define EFM32_CMU_HFPERCLKEN0_ACMP0_SET(x, v)    do { (x) = (((x) & ~0x200) | ((v) << 9)); } while(0)
/** Set to enable the clock for ACMP0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ACMP1              0x00000400
  #define EFM32_CMU_HFPERCLKEN0_ACMP1_SHIFT        10
  #define EFM32_CMU_HFPERCLKEN0_ACMP1_SET(x, v)    do { (x) = (((x) & ~0x400) | ((v) << 10)); } while(0)
/** Set to enable the clock for I2C0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_I2C0               0x00000800
  #define EFM32_CMU_HFPERCLKEN0_I2C0_SHIFT         11
  #define EFM32_CMU_HFPERCLKEN0_I2C0_SET(x, v)     do { (x) = (((x) & ~0x800) | ((v) << 11)); } while(0)
/** Set to enable the clock for I2C1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_I2C1               0x00001000
  #define EFM32_CMU_HFPERCLKEN0_I2C1_SHIFT         12
  #define EFM32_CMU_HFPERCLKEN0_I2C1_SET(x, v)     do { (x) = (((x) & ~0x1000) | ((v) << 12)); } while(0)
/** Set to enable the clock for GPIO. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_GPIO               0x00002000
  #define EFM32_CMU_HFPERCLKEN0_GPIO_SHIFT         13
  #define EFM32_CMU_HFPERCLKEN0_GPIO_SET(x, v)     do { (x) = (((x) & ~0x2000) | ((v) << 13)); } while(0)
/** Set to enable the clock for VCMP. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_VCMP               0x00004000
  #define EFM32_CMU_HFPERCLKEN0_VCMP_SHIFT         14
  #define EFM32_CMU_HFPERCLKEN0_VCMP_SET(x, v)     do { (x) = (((x) & ~0x4000) | ((v) << 14)); } while(0)
/** Set to enable the clock for PRS. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_PRS                0x00008000
  #define EFM32_CMU_HFPERCLKEN0_PRS_SHIFT          15
  #define EFM32_CMU_HFPERCLKEN0_PRS_SET(x, v)      do { (x) = (((x) & ~0x8000) | ((v) << 15)); } while(0)
/** Set to enable the clock for ADC0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ADC0               0x00010000
  #define EFM32_CMU_HFPERCLKEN0_ADC0_SHIFT         16
  #define EFM32_CMU_HFPERCLKEN0_ADC0_SET(x, v)     do { (x) = (((x) & ~0x10000) | ((v) << 16)); } while(0)
/** Set to enable the clock for DAC0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_DAC0               0x00020000
  #define EFM32_CMU_HFPERCLKEN0_DAC0_SHIFT         17
  #define EFM32_CMU_HFPERCLKEN0_DAC0_SET(x, v)     do { (x) = (((x) & ~0x20000) | ((v) << 17)); } while(0)
# endif

#define EFM32_CMU_SYNCBUSY_ADDR                      0x00000050
#define EFM32_CMU_SYNCBUSY_MASK                      0x00000035
/** Used to check the synchronization status of CMU_LFACLKEN0. @multiple */
  #define EFM32_CMU_SYNCBUSY_LFACLKEN0_SHIFT       0
  #define EFM32_CMU_SYNCBUSY_LFACLKEN0(v)          ((EFM32_CMU_SYNCBUSY_LFACLKEN0_##v) << 0)
  #define EFM32_CMU_SYNCBUSY_LFACLKEN0_SET(x, v)   do { (x) = (((x) & ~0x1) | ((EFM32_CMU_SYNCBUSY_LFACLKEN0_##v) << 0)); } while(0)
  #define EFM32_CMU_SYNCBUSY_LFACLKEN0_SETVAL(x, v) do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define EFM32_CMU_SYNCBUSY_LFACLKEN0_GET(x)      (((x) >> 0) & 0x1)
    #define EFM32_CMU_SYNCBUSY_LFACLKEN0_READY       0x00000000
    #define EFM32_CMU_SYNCBUSY_LFACLKEN0_BUSY        0x00000001
/** Used to check the synchronization status of CMU_LFAPRESC0. @multiple */
  #define EFM32_CMU_SYNCBUSY_LFAPRESC0_SHIFT       2
  #define EFM32_CMU_SYNCBUSY_LFAPRESC0(v)          ((EFM32_CMU_SYNCBUSY_LFAPRESC0_##v) << 2)
  #define EFM32_CMU_SYNCBUSY_LFAPRESC0_SET(x, v)   do { (x) = (((x) & ~0x4) | ((EFM32_CMU_SYNCBUSY_LFAPRESC0_##v) << 2)); } while(0)
  #define EFM32_CMU_SYNCBUSY_LFAPRESC0_SETVAL(x, v) do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define EFM32_CMU_SYNCBUSY_LFAPRESC0_GET(x)      (((x) >> 2) & 0x1)
    #define EFM32_CMU_SYNCBUSY_LFAPRESC0_READY       0x00000000
    #define EFM32_CMU_SYNCBUSY_LFAPRESC0_BUSY        0x00000001
/** Used to check the synchronization status of CMU_LFBCLKEN0. @multiple */
  #define EFM32_CMU_SYNCBUSY_LFBCLKEN0_SHIFT       4
  #define EFM32_CMU_SYNCBUSY_LFBCLKEN0(v)          ((EFM32_CMU_SYNCBUSY_LFBCLKEN0_##v) << 4)
  #define EFM32_CMU_SYNCBUSY_LFBCLKEN0_SET(x, v)   do { (x) = (((x) & ~0x10) | ((EFM32_CMU_SYNCBUSY_LFBCLKEN0_##v) << 4)); } while(0)
  #define EFM32_CMU_SYNCBUSY_LFBCLKEN0_SETVAL(x, v) do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
  #define EFM32_CMU_SYNCBUSY_LFBCLKEN0_GET(x)      (((x) >> 4) & 0x1)
    #define EFM32_CMU_SYNCBUSY_LFBCLKEN0_READY       0x00000000
    #define EFM32_CMU_SYNCBUSY_LFBCLKEN0_BUSY        0x00000001
/** Used to check the synchronization status of CMU_LFBPRESC0. @multiple */
  #define EFM32_CMU_SYNCBUSY_LFBPRESC0_SHIFT       5
  #define EFM32_CMU_SYNCBUSY_LFBPRESC0(v)          ((EFM32_CMU_SYNCBUSY_LFBPRESC0_##v) << 5)
  #define EFM32_CMU_SYNCBUSY_LFBPRESC0_SET(x, v)   do { (x) = (((x) & ~0x20) | ((EFM32_CMU_SYNCBUSY_LFBPRESC0_##v) << 5)); } while(0)
  #define EFM32_CMU_SYNCBUSY_LFBPRESC0_SETVAL(x, v) do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define EFM32_CMU_SYNCBUSY_LFBPRESC0_GET(x)      (((x) >> 5) & 0x1)
    #define EFM32_CMU_SYNCBUSY_LFBPRESC0_READY       0x00000000
    #define EFM32_CMU_SYNCBUSY_LFBPRESC0_BUSY        0x00000001

#define EFM32_CMU_FREEZE_ADDR                        0x00000054
#define EFM32_CMU_FREEZE_MASK                        0x00000001
/** When set, the update of the Low Frequency clock control registers is
   postponed until this bit is cleared. Use this bit to update several registers
   simultaneously. @multiple */
  #define EFM32_CMU_FREEZE_REGFREEZE_SHIFT         0
  #define EFM32_CMU_FREEZE_REGFREEZE(v)            ((EFM32_CMU_FREEZE_REGFREEZE_##v) << 0)
  #define EFM32_CMU_FREEZE_REGFREEZE_SET(x, v)     do { (x) = (((x) & ~0x1) | ((EFM32_CMU_FREEZE_REGFREEZE_##v) << 0)); } while(0)
  #define EFM32_CMU_FREEZE_REGFREEZE_SETVAL(x, v)  do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define EFM32_CMU_FREEZE_REGFREEZE_GET(x)        (((x) >> 0) & 0x1)
    #define EFM32_CMU_FREEZE_REGFREEZE_UPDATE        0x00000000
    #define EFM32_CMU_FREEZE_REGFREEZE_FREEZE        0x00000001

# if defined(CONFIG_EFM32_GECKO)
#define EFM32_CMU_LFACLKEN0_ADDR                     0x00000058
#define EFM32_CMU_LFACLKEN0_MASK                     0x00000007
/** Set to enable the clock for RTC. @multiple */
  #define EFM32_CMU_LFACLKEN0_RTC                  0x00000001
  #define EFM32_CMU_LFACLKEN0_RTC_SHIFT            0
  #define EFM32_CMU_LFACLKEN0_RTC_SET(x, v)        do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** Set to enable the clock for LETIMER0. @multiple */
  #define EFM32_CMU_LFACLKEN0_LETIMER0             0x00000002
  #define EFM32_CMU_LFACLKEN0_LETIMER0_SHIFT       1
  #define EFM32_CMU_LFACLKEN0_LETIMER0_SET(x, v)   do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
/** Set to enable the clock for LCD. @multiple */
  #define EFM32_CMU_LFACLKEN0_LCD                  0x00000004
  #define EFM32_CMU_LFACLKEN0_LCD_SHIFT            2
  #define EFM32_CMU_LFACLKEN0_LCD_SET(x, v)        do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
# endif

# if defined(CONFIG_EFM32_ZERO_GECKO)
#define EFM32_CMU_LFACLKEN0_ADDR                     0x00000058
#define EFM32_CMU_LFACLKEN0_MASK                     0x00000001
/** Set to enable the clock for RTC. @multiple */
  #define EFM32_CMU_LFACLKEN0_RTC                  0x00000001
  #define EFM32_CMU_LFACLKEN0_RTC_SHIFT            0
  #define EFM32_CMU_LFACLKEN0_RTC_SET(x, v)        do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
# endif

# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
#define EFM32_CMU_LFACLKEN0_ADDR                     0x00000058
#define EFM32_CMU_LFACLKEN0_MASK                     0x0000000f
/** Set to enable the clock for LESENSE. @multiple */
  #define EFM32_CMU_LFACLKEN0_LESENSE              0x00000001
  #define EFM32_CMU_LFACLKEN0_LESENSE_SHIFT        0
  #define EFM32_CMU_LFACLKEN0_LESENSE_SET(x, v)    do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** Set to enable the clock for RTC. @multiple */
  #define EFM32_CMU_LFACLKEN0_RTC                  0x00000002
  #define EFM32_CMU_LFACLKEN0_RTC_SHIFT            1
  #define EFM32_CMU_LFACLKEN0_RTC_SET(x, v)        do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
/** Set to enable the clock for LETIMER0. @multiple */
  #define EFM32_CMU_LFACLKEN0_LETIMER0             0x00000004
  #define EFM32_CMU_LFACLKEN0_LETIMER0_SHIFT       2
  #define EFM32_CMU_LFACLKEN0_LETIMER0_SET(x, v)   do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
/** Set to enable the clock for LCD. @multiple */
  #define EFM32_CMU_LFACLKEN0_LCD                  0x00000008
  #define EFM32_CMU_LFACLKEN0_LCD_SHIFT            3
  #define EFM32_CMU_LFACLKEN0_LCD_SET(x, v)        do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
# endif

# if defined(CONFIG_EFM32_ZERO_GECKO)
#define EFM32_CMU_LFBCLKEN0_ADDR                     0x00000060
#define EFM32_CMU_LFBCLKEN0_MASK                     0x00000001
/** Set to enable the clock for LEUART0. @multiple */
  #define EFM32_CMU_LFBCLKEN0_LEUART0              0x00000001
  #define EFM32_CMU_LFBCLKEN0_LEUART0_SHIFT        0
  #define EFM32_CMU_LFBCLKEN0_LEUART0_SET(x, v)    do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
# endif

# if defined(CONFIG_EFM32_GECKO) || defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
#define EFM32_CMU_LFBCLKEN0_ADDR                     0x00000060
#define EFM32_CMU_LFBCLKEN0_MASK                     0x00000003
/** Set to enable the clock for LEUART0. @multiple */
  #define EFM32_CMU_LFBCLKEN0_LEUART0              0x00000001
  #define EFM32_CMU_LFBCLKEN0_LEUART0_SHIFT        0
  #define EFM32_CMU_LFBCLKEN0_LEUART0_SET(x, v)    do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** Set to enable the clock for LEUART1. @multiple */
  #define EFM32_CMU_LFBCLKEN0_LEUART1              0x00000002
  #define EFM32_CMU_LFBCLKEN0_LEUART1_SHIFT        1
  #define EFM32_CMU_LFBCLKEN0_LEUART1_SET(x, v)    do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
# endif

# if defined(CONFIG_EFM32_GECKO)
#define EFM32_CMU_LFAPRESC0_ADDR                     0x00000068
#define EFM32_CMU_LFAPRESC0_MASK                     0x000003ff
/** Configure Real-Time Counter prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_RTC_SHIFT            0
  #define EFM32_CMU_LFAPRESC0_RTC(v)               ((EFM32_CMU_LFAPRESC0_RTC_##v) << 0)
  #define EFM32_CMU_LFAPRESC0_RTC_SET(x, v)        do { (x) = (((x) & ~0xf) | ((EFM32_CMU_LFAPRESC0_RTC_##v) << 0)); } while(0)
  #define EFM32_CMU_LFAPRESC0_RTC_SETVAL(x, v)     do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define EFM32_CMU_LFAPRESC0_RTC_GET(x)           (((x) >> 0) & 0xf)
    #define EFM32_CMU_LFAPRESC0_RTC_DIV1             0x00000000
    #define EFM32_CMU_LFAPRESC0_RTC_DIV2             0x00000001
    #define EFM32_CMU_LFAPRESC0_RTC_DIV4             0x00000002
    #define EFM32_CMU_LFAPRESC0_RTC_DIV8             0x00000003
    #define EFM32_CMU_LFAPRESC0_RTC_DIV16            0x00000004
    #define EFM32_CMU_LFAPRESC0_RTC_DIV32            0x00000005
    #define EFM32_CMU_LFAPRESC0_RTC_DIV64            0x00000006
    #define EFM32_CMU_LFAPRESC0_RTC_DIV128           0x00000007
    #define EFM32_CMU_LFAPRESC0_RTC_DIV256           0x00000008
    #define EFM32_CMU_LFAPRESC0_RTC_DIV512           0x00000009
    #define EFM32_CMU_LFAPRESC0_RTC_DIV1024          0x0000000a
    #define EFM32_CMU_LFAPRESC0_RTC_DIV2048          0x0000000b
    #define EFM32_CMU_LFAPRESC0_RTC_DIV4096          0x0000000c
    #define EFM32_CMU_LFAPRESC0_RTC_DIV8192          0x0000000d
    #define EFM32_CMU_LFAPRESC0_RTC_DIV16384         0x0000000e
    #define EFM32_CMU_LFAPRESC0_RTC_DIV32768         0x0000000f
/** Configure Real-Time Counter prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_LETIMER0_SHIFT       4
  #define EFM32_CMU_LFAPRESC0_LETIMER0(v)          ((EFM32_CMU_LFAPRESC0_LETIMER0_##v) << 4)
  #define EFM32_CMU_LFAPRESC0_LETIMER0_SET(x, v)   do { (x) = (((x) & ~0xf0) | ((EFM32_CMU_LFAPRESC0_LETIMER0_##v) << 4)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LETIMER0_SETVAL(x, v) do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LETIMER0_GET(x)      (((x) >> 4) & 0xf)
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV1        0x00000000
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV2        0x00000001
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV4        0x00000002
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV8        0x00000003
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV16       0x00000004
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV32       0x00000005
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV64       0x00000006
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV128      0x00000007
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV256      0x00000008
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV512      0x00000009
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV1024     0x0000000a
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV2048     0x0000000b
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV4096     0x0000000c
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV8192     0x0000000d
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV16384    0x0000000e
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV32768    0x0000000f
/** Configure LCD controller prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_LCD_SHIFT            8
  #define EFM32_CMU_LFAPRESC0_LCD(v)               ((EFM32_CMU_LFAPRESC0_LCD_##v) << 8)
  #define EFM32_CMU_LFAPRESC0_LCD_SET(x, v)        do { (x) = (((x) & ~0x300) | ((EFM32_CMU_LFAPRESC0_LCD_##v) << 8)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LCD_SETVAL(x, v)     do { (x) = (((x) & ~0x300) | ((v) << 8)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LCD_GET(x)           (((x) >> 8) & 0x3)
    #define EFM32_CMU_LFAPRESC0_LCD_DIV16            0x00000000
    #define EFM32_CMU_LFAPRESC0_LCD_DIV32            0x00000001
    #define EFM32_CMU_LFAPRESC0_LCD_DIV64            0x00000002
    #define EFM32_CMU_LFAPRESC0_LCD_DIV128           0x00000003
# endif

# if defined(CONFIG_EFM32_ZERO_GECKO)
#define EFM32_CMU_LFAPRESC0_ADDR                     0x00000068
#define EFM32_CMU_LFAPRESC0_MASK                     0x0000000f
/** Configure Real-Time Counter prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_RTC_SHIFT            0
  #define EFM32_CMU_LFAPRESC0_RTC(v)               ((EFM32_CMU_LFAPRESC0_RTC_##v) << 0)
  #define EFM32_CMU_LFAPRESC0_RTC_SET(x, v)        do { (x) = (((x) & ~0xf) | ((EFM32_CMU_LFAPRESC0_RTC_##v) << 0)); } while(0)
  #define EFM32_CMU_LFAPRESC0_RTC_SETVAL(x, v)     do { (x) = (((x) & ~0xf) | ((v) << 0)); } while(0)
  #define EFM32_CMU_LFAPRESC0_RTC_GET(x)           (((x) >> 0) & 0xf)
    #define EFM32_CMU_LFAPRESC0_RTC_DIV1             0x00000000
    #define EFM32_CMU_LFAPRESC0_RTC_DIV2             0x00000001
    #define EFM32_CMU_LFAPRESC0_RTC_DIV4             0x00000002
    #define EFM32_CMU_LFAPRESC0_RTC_DIV8             0x00000003
    #define EFM32_CMU_LFAPRESC0_RTC_DIV16            0x00000004
    #define EFM32_CMU_LFAPRESC0_RTC_DIV32            0x00000005
    #define EFM32_CMU_LFAPRESC0_RTC_DIV64            0x00000006
    #define EFM32_CMU_LFAPRESC0_RTC_DIV128           0x00000007
    #define EFM32_CMU_LFAPRESC0_RTC_DIV256           0x00000008
    #define EFM32_CMU_LFAPRESC0_RTC_DIV512           0x00000009
    #define EFM32_CMU_LFAPRESC0_RTC_DIV1024          0x0000000a
    #define EFM32_CMU_LFAPRESC0_RTC_DIV2048          0x0000000b
    #define EFM32_CMU_LFAPRESC0_RTC_DIV4096          0x0000000c
    #define EFM32_CMU_LFAPRESC0_RTC_DIV8192          0x0000000d
    #define EFM32_CMU_LFAPRESC0_RTC_DIV16384         0x0000000e
    #define EFM32_CMU_LFAPRESC0_RTC_DIV32768         0x0000000f
# endif

# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
#define EFM32_CMU_LFAPRESC0_ADDR                     0x00000068
#define EFM32_CMU_LFAPRESC0_MASK                     0x00007ff3
/** Configure Low Energy Interface prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_LESENSE_SHIFT        0
  #define EFM32_CMU_LFAPRESC0_LESENSE(v)           ((EFM32_CMU_LFAPRESC0_LESENSE_##v) << 0)
  #define EFM32_CMU_LFAPRESC0_LESENSE_SET(x, v)    do { (x) = (((x) & ~0x3) | ((EFM32_CMU_LFAPRESC0_LESENSE_##v) << 0)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LESENSE_SETVAL(x, v) do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LESENSE_GET(x)       (((x) >> 0) & 0x3)
    #define EFM32_CMU_LFAPRESC0_LESENSE_DIV1         0x00000000
    #define EFM32_CMU_LFAPRESC0_LESENSE_DIV2         0x00000001
    #define EFM32_CMU_LFAPRESC0_LESENSE_DIV4         0x00000002
    #define EFM32_CMU_LFAPRESC0_LESENSE_DIV8         0x00000003
/** Configure Real-Time Counter prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_RTC_SHIFT            4
  #define EFM32_CMU_LFAPRESC0_RTC(v)               ((EFM32_CMU_LFAPRESC0_RTC_##v) << 4)
  #define EFM32_CMU_LFAPRESC0_RTC_SET(x, v)        do { (x) = (((x) & ~0xf0) | ((EFM32_CMU_LFAPRESC0_RTC_##v) << 4)); } while(0)
  #define EFM32_CMU_LFAPRESC0_RTC_SETVAL(x, v)     do { (x) = (((x) & ~0xf0) | ((v) << 4)); } while(0)
  #define EFM32_CMU_LFAPRESC0_RTC_GET(x)           (((x) >> 4) & 0xf)
    #define EFM32_CMU_LFAPRESC0_RTC_DIV1             0x00000000
    #define EFM32_CMU_LFAPRESC0_RTC_DIV2             0x00000001
    #define EFM32_CMU_LFAPRESC0_RTC_DIV4             0x00000002
    #define EFM32_CMU_LFAPRESC0_RTC_DIV8             0x00000003
    #define EFM32_CMU_LFAPRESC0_RTC_DIV16            0x00000004
    #define EFM32_CMU_LFAPRESC0_RTC_DIV32            0x00000005
    #define EFM32_CMU_LFAPRESC0_RTC_DIV64            0x00000006
    #define EFM32_CMU_LFAPRESC0_RTC_DIV128           0x00000007
    #define EFM32_CMU_LFAPRESC0_RTC_DIV256           0x00000008
    #define EFM32_CMU_LFAPRESC0_RTC_DIV512           0x00000009
    #define EFM32_CMU_LFAPRESC0_RTC_DIV1024          0x0000000a
    #define EFM32_CMU_LFAPRESC0_RTC_DIV2048          0x0000000b
    #define EFM32_CMU_LFAPRESC0_RTC_DIV4096          0x0000000c
    #define EFM32_CMU_LFAPRESC0_RTC_DIV8192          0x0000000d
    #define EFM32_CMU_LFAPRESC0_RTC_DIV16384         0x0000000e
    #define EFM32_CMU_LFAPRESC0_RTC_DIV32768         0x0000000f
/** Configure Real-Time Counter prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_LETIMER0_SHIFT       8
  #define EFM32_CMU_LFAPRESC0_LETIMER0(v)          ((EFM32_CMU_LFAPRESC0_LETIMER0_##v) << 8)
  #define EFM32_CMU_LFAPRESC0_LETIMER0_SET(x, v)   do { (x) = (((x) & ~0xf00) | ((EFM32_CMU_LFAPRESC0_LETIMER0_##v) << 8)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LETIMER0_SETVAL(x, v) do { (x) = (((x) & ~0xf00) | ((v) << 8)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LETIMER0_GET(x)      (((x) >> 8) & 0xf)
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV1        0x00000000
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV2        0x00000001
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV4        0x00000002
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV8        0x00000003
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV16       0x00000004
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV32       0x00000005
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV64       0x00000006
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV128      0x00000007
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV256      0x00000008
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV512      0x00000009
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV1024     0x0000000a
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV2048     0x0000000b
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV4096     0x0000000c
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV8192     0x0000000d
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV16384    0x0000000e
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV32768    0x0000000f
/** Configure LCD controller prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_LCD_SHIFT            12
  #define EFM32_CMU_LFAPRESC0_LCD(v)               ((EFM32_CMU_LFAPRESC0_LCD_##v) << 12)
  #define EFM32_CMU_LFAPRESC0_LCD_SET(x, v)        do { (x) = (((x) & ~0x7000) | ((EFM32_CMU_LFAPRESC0_LCD_##v) << 12)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LCD_SETVAL(x, v)     do { (x) = (((x) & ~0x7000) | ((v) << 12)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LCD_GET(x)           (((x) >> 12) & 0x7)
    #define EFM32_CMU_LFAPRESC0_LCD_DIV16            0x00000000
    #define EFM32_CMU_LFAPRESC0_LCD_DIV32            0x00000001
    #define EFM32_CMU_LFAPRESC0_LCD_DIV64            0x00000002
    #define EFM32_CMU_LFAPRESC0_LCD_DIV128           0x00000003
# endif

# if defined(CONFIG_EFM32_ZERO_GECKO)
#define EFM32_CMU_LFBPRESC0_ADDR                     0x00000070
#define EFM32_CMU_LFBPRESC0_MASK                     0x00000003
/** Configure LEUART0 prescaler @multiple */
  #define EFM32_CMU_LFBPRESC0_LEUART0_SHIFT        0
  #define EFM32_CMU_LFBPRESC0_LEUART0(v)           ((EFM32_CMU_LFBPRESC0_LEUART0_##v) << 0)
  #define EFM32_CMU_LFBPRESC0_LEUART0_SET(x, v)    do { (x) = (((x) & ~0x3) | ((EFM32_CMU_LFBPRESC0_LEUART0_##v) << 0)); } while(0)
  #define EFM32_CMU_LFBPRESC0_LEUART0_SETVAL(x, v) do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define EFM32_CMU_LFBPRESC0_LEUART0_GET(x)       (((x) >> 0) & 0x3)
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV1         0x00000000
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV2         0x00000001
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV4         0x00000002
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV8         0x00000003
# endif

# if defined(CONFIG_EFM32_GECKO) || defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
#define EFM32_CMU_LFBPRESC0_ADDR                     0x00000070
#define EFM32_CMU_LFBPRESC0_MASK                     0x00000033
/** Configure LEUART0 prescaler @multiple */
  #define EFM32_CMU_LFBPRESC0_LEUART0_SHIFT        0
  #define EFM32_CMU_LFBPRESC0_LEUART0(v)           ((EFM32_CMU_LFBPRESC0_LEUART0_##v) << 0)
  #define EFM32_CMU_LFBPRESC0_LEUART0_SET(x, v)    do { (x) = (((x) & ~0x3) | ((EFM32_CMU_LFBPRESC0_LEUART0_##v) << 0)); } while(0)
  #define EFM32_CMU_LFBPRESC0_LEUART0_SETVAL(x, v) do { (x) = (((x) & ~0x3) | ((v) << 0)); } while(0)
  #define EFM32_CMU_LFBPRESC0_LEUART0_GET(x)       (((x) >> 0) & 0x3)
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV1         0x00000000
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV2         0x00000001
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV4         0x00000002
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV8         0x00000003
/** Configure LEUART1 prescaler @multiple */
  #define EFM32_CMU_LFBPRESC0_LEUART1_SHIFT        4
  #define EFM32_CMU_LFBPRESC0_LEUART1(v)           ((EFM32_CMU_LFBPRESC0_LEUART1_##v) << 4)
  #define EFM32_CMU_LFBPRESC0_LEUART1_SET(x, v)    do { (x) = (((x) & ~0x30) | ((EFM32_CMU_LFBPRESC0_LEUART1_##v) << 4)); } while(0)
  #define EFM32_CMU_LFBPRESC0_LEUART1_SETVAL(x, v) do { (x) = (((x) & ~0x30) | ((v) << 4)); } while(0)
  #define EFM32_CMU_LFBPRESC0_LEUART1_GET(x)       (((x) >> 4) & 0x3)
    #define EFM32_CMU_LFBPRESC0_LEUART1_DIV1         0x00000000
    #define EFM32_CMU_LFBPRESC0_LEUART1_DIV2         0x00000001
    #define EFM32_CMU_LFBPRESC0_LEUART1_DIV4         0x00000002
    #define EFM32_CMU_LFBPRESC0_LEUART1_DIV8         0x00000003
# endif

#define EFM32_CMU_PCNTCTRL_ADDR                      0x00000078
#define EFM32_CMU_PCNTCTRL_MASK                      0x00000003
/** This bit enables/disables the clock to the PCNT. @multiple */
  #define EFM32_CMU_PCNTCTRL_PCNT0CLKEN            0x00000001
  #define EFM32_CMU_PCNTCTRL_PCNT0CLKEN_SHIFT      0
  #define EFM32_CMU_PCNTCTRL_PCNT0CLKEN_SET(x, v)  do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** This bit controls which clock that is used for the PCNT. @multiple */
  #define EFM32_CMU_PCNTCTRL_PCNT0CLKSEL_SHIFT     1
  #define EFM32_CMU_PCNTCTRL_PCNT0CLKSEL(v)        ((EFM32_CMU_PCNTCTRL_PCNT0CLKSEL_##v) << 1)
  #define EFM32_CMU_PCNTCTRL_PCNT0CLKSEL_SET(x, v) do { (x) = (((x) & ~0x2) | ((EFM32_CMU_PCNTCTRL_PCNT0CLKSEL_##v) << 1)); } while(0)
  #define EFM32_CMU_PCNTCTRL_PCNT0CLKSEL_SETVAL(x, v) do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define EFM32_CMU_PCNTCTRL_PCNT0CLKSEL_GET(x)    (((x) >> 1) & 0x1)
    #define EFM32_CMU_PCNTCTRL_PCNT0CLKSEL_LFACLK    0x00000000
    #define EFM32_CMU_PCNTCTRL_PCNT0CLKSEL_PCNT0S0   0x00000001
# if defined(CONFIG_EFM32_GECKO) || defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
/** This bit enables/disables the clock to the PCNT. @multiple */
  #define EFM32_CMU_PCNTCTRL_PCNT1CLKEN            0x00000004
  #define EFM32_CMU_PCNTCTRL_PCNT1CLKEN_SHIFT      2
  #define EFM32_CMU_PCNTCTRL_PCNT1CLKEN_SET(x, v)  do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
/** This bit controls which clock that is used for the PCNT. @multiple */
  #define EFM32_CMU_PCNTCTRL_PCNT1CLKSEL_SHIFT     3
  #define EFM32_CMU_PCNTCTRL_PCNT1CLKSEL(v)        ((EFM32_CMU_PCNTCTRL_PCNT1CLKSEL_##v) << 3)
  #define EFM32_CMU_PCNTCTRL_PCNT1CLKSEL_SET(x, v) do { (x) = (((x) & ~0x8) | ((EFM32_CMU_PCNTCTRL_PCNT1CLKSEL_##v) << 3)); } while(0)
  #define EFM32_CMU_PCNTCTRL_PCNT1CLKSEL_SETVAL(x, v) do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
  #define EFM32_CMU_PCNTCTRL_PCNT1CLKSEL_GET(x)    (((x) >> 3) & 0x1)
    #define EFM32_CMU_PCNTCTRL_PCNT1CLKSEL_LFACLK    0x00000000
    #define EFM32_CMU_PCNTCTRL_PCNT1CLKSEL_PCNT1S0   0x00000001
/** This bit enables/disables the clock to the PCNT. @multiple */
  #define EFM32_CMU_PCNTCTRL_PCNT2CLKEN            0x00000010
  #define EFM32_CMU_PCNTCTRL_PCNT2CLKEN_SHIFT      4
  #define EFM32_CMU_PCNTCTRL_PCNT2CLKEN_SET(x, v)  do { (x) = (((x) & ~0x10) | ((v) << 4)); } while(0)
/** This bit controls which clock that is used for the PCNT. @multiple */
  #define EFM32_CMU_PCNTCTRL_PCNT2CLKSEL_SHIFT     5
  #define EFM32_CMU_PCNTCTRL_PCNT2CLKSEL(v)        ((EFM32_CMU_PCNTCTRL_PCNT2CLKSEL_##v) << 5)
  #define EFM32_CMU_PCNTCTRL_PCNT2CLKSEL_SET(x, v) do { (x) = (((x) & ~0x20) | ((EFM32_CMU_PCNTCTRL_PCNT2CLKSEL_##v) << 5)); } while(0)
  #define EFM32_CMU_PCNTCTRL_PCNT2CLKSEL_SETVAL(x, v) do { (x) = (((x) & ~0x20) | ((v) << 5)); } while(0)
  #define EFM32_CMU_PCNTCTRL_PCNT2CLKSEL_GET(x)    (((x) >> 5) & 0x1)
    #define EFM32_CMU_PCNTCTRL_PCNT2CLKSEL_LFACLK    0x00000000
    #define EFM32_CMU_PCNTCTRL_PCNT2CLKSEL_PCNT2S0   0x00000001
# endif

# if defined(CONFIG_EFM32_GECKO) || defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
#define EFM32_CMU_LCDCTRL_ADDR                       0x0000007c
#define EFM32_CMU_LCDCTRL_MASK                       0x0000007f
/** These bits controls the framerate according to this formula: LFACLKLCD =
   LFACLKLCDpre / (1 + FDIV). Do not change this value while the LCD bit in
   LFACLKEN0 is set to 1. @multiple */
  #define EFM32_CMU_LCDCTRL_FDIV_SHIFT             0
  #define EFM32_CMU_LCDCTRL_FDIV(v)                ((v) << 0)
  #define EFM32_CMU_LCDCTRL_FDIV_SET(x, v)         do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define EFM32_CMU_LCDCTRL_FDIV_GET(x)            (((x) >> 0) & 0x7)
/** This bit enables/disables the VBOOST function. @multiple */
  #define EFM32_CMU_LCDCTRL_VBOOSTEN               0x00000008
  #define EFM32_CMU_LCDCTRL_VBOOSTEN_SHIFT         3
  #define EFM32_CMU_LCDCTRL_VBOOSTEN_SET(x, v)     do { (x) = (((x) & ~0x8) | ((v) << 3)); } while(0)
/** These bits control the voltage boost update frequency division. Voltage Boost
   update Frequency = LFACLK / DIV. @multiple */
  #define EFM32_CMU_LCDCTRL_VBFDIV_SHIFT           4
  #define EFM32_CMU_LCDCTRL_VBFDIV(v)              ((EFM32_CMU_LCDCTRL_VBFDIV_##v) << 4)
  #define EFM32_CMU_LCDCTRL_VBFDIV_SET(x, v)       do { (x) = (((x) & ~0x70) | ((EFM32_CMU_LCDCTRL_VBFDIV_##v) << 4)); } while(0)
  #define EFM32_CMU_LCDCTRL_VBFDIV_SETVAL(x, v)    do { (x) = (((x) & ~0x70) | ((v) << 4)); } while(0)
  #define EFM32_CMU_LCDCTRL_VBFDIV_GET(x)          (((x) >> 4) & 0x7)
    #define EFM32_CMU_LCDCTRL_VBFDIV_DIV1            0x00000000
    #define EFM32_CMU_LCDCTRL_VBFDIV_DIV2            0x00000001
    #define EFM32_CMU_LCDCTRL_VBFDIV_DIV4            0x00000002
    #define EFM32_CMU_LCDCTRL_VBFDIV_DIV8            0x00000003
    #define EFM32_CMU_LCDCTRL_VBFDIV_DIV16           0x00000004
    #define EFM32_CMU_LCDCTRL_VBFDIV_DIV32           0x00000005
# endif

#define EFM32_CMU_ROUTE_ADDR                         0x00000080
#define EFM32_CMU_ROUTE_MASK                         0x00000003
/** When set, the CLKOUT0 pin is enabled. @multiple */
  #define EFM32_CMU_ROUTE_CLKOUT0PEN               0x00000001
  #define EFM32_CMU_ROUTE_CLKOUT0PEN_SHIFT         0
  #define EFM32_CMU_ROUTE_CLKOUT0PEN_SET(x, v)     do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
/** When set, the CLKOUT1 pin is enabled. @multiple */
  #define EFM32_CMU_ROUTE_CLKOUT1PEN               0x00000002
  #define EFM32_CMU_ROUTE_CLKOUT1PEN_SHIFT         1
  #define EFM32_CMU_ROUTE_CLKOUT1PEN_SET(x, v)     do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
# if defined(CONFIG_EFM32_GECKO)
/** Decides the location of the CMU I/O pins. @multiple */
  #define EFM32_CMU_ROUTE_LOCATION_SHIFT           2
  #define EFM32_CMU_ROUTE_LOCATION(v)              ((EFM32_CMU_ROUTE_LOCATION_##v) << 2)
  #define EFM32_CMU_ROUTE_LOCATION_SET(x, v)       do { (x) = (((x) & ~0x4) | ((EFM32_CMU_ROUTE_LOCATION_##v) << 2)); } while(0)
  #define EFM32_CMU_ROUTE_LOCATION_SETVAL(x, v)    do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define EFM32_CMU_ROUTE_LOCATION_GET(x)          (((x) >> 2) & 0x1)
    #define EFM32_CMU_ROUTE_LOCATION_LOC0            0x00000000
# endif
# if defined(CONFIG_EFM32_ZERO_GECKO) || defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_GIANT_GECKO)
/** Decides the location of the CMU I/O pins. @multiple */
  #define EFM32_CMU_ROUTE_LOCATION_SHIFT           2
  #define EFM32_CMU_ROUTE_LOCATION(v)              ((EFM32_CMU_ROUTE_LOCATION_##v) << 2)
  #define EFM32_CMU_ROUTE_LOCATION_SET(x, v)       do { (x) = (((x) & ~0x1c) | ((EFM32_CMU_ROUTE_LOCATION_##v) << 2)); } while(0)
  #define EFM32_CMU_ROUTE_LOCATION_SETVAL(x, v)    do { (x) = (((x) & ~0x1c) | ((v) << 2)); } while(0)
  #define EFM32_CMU_ROUTE_LOCATION_GET(x)          (((x) >> 2) & 0x7)
    #define EFM32_CMU_ROUTE_LOCATION_LOC0            0x00000000
    #define EFM32_CMU_ROUTE_LOCATION_LOC1            0x00000001
    #define EFM32_CMU_ROUTE_LOCATION_LOC2            0x00000002
# endif

#define EFM32_CMU_LOCK_ADDR                          0x00000084
#define EFM32_CMU_LOCK_MASK                          0x0000ffff
/** Write any other value than the unlock code to lock CMU_CTRL,
   CMU_HFCORECLKDIV, CMU_HFPERCLKDIV, CMU_HFRCOCTRL, CMU_LFRCOCTRL,
   CMU_AUXHFRCOCTRL, CMU_OSCENCMD, CMU_CMD, CMU_LFCLKSEL, CMU_HFCORECLKEN0,
   CMU_HFPERCLKEN0, CMU_LFACLKEN0, CMU_LFBCLKEN0, CMU_LFAPRESC0, CMU_LFBPRESC0,
   and CMU_PCNTCTRL from editing. Write the unlock code to unlock. When reading
   the register, bit 0 is set when the lock is enabled. @multiple */
  #define EFM32_CMU_LOCK_LOCKKEY_SHIFT             0
  #define EFM32_CMU_LOCK_LOCKKEY(v)                ((EFM32_CMU_LOCK_LOCKKEY_##v) << 0)
  #define EFM32_CMU_LOCK_LOCKKEY_SET(x, v)         do { (x) = (((x) & ~0xffff) | ((EFM32_CMU_LOCK_LOCKKEY_##v) << 0)); } while(0)
  #define EFM32_CMU_LOCK_LOCKKEY_SETVAL(x, v)      do { (x) = (((x) & ~0xffff) | ((v) << 0)); } while(0)
  #define EFM32_CMU_LOCK_LOCKKEY_GET(x)            (((x) >> 0) & 0xffff)
    #define EFM32_CMU_LOCK_LOCKKEY_UNLOCKED          0x00000000
    #define EFM32_CMU_LOCK_LOCKKEY_LOCKED            0x00000001
    #define EFM32_CMU_LOCK_LOCKKEY_UNLOCK            0x0000580e

#endif

