/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -o cdefs -O arch/efm32/include/arch/efm32_cmu.h cdefs_use_reg_mask=1
*/

#ifndef _EFM32_CMU_BFGEN_DEFS_
#define _EFM32_CMU_BFGEN_DEFS_

#define EFM32_CMU_CTRL_ADDR                          0x00000000
#define EFM32_CMU_CTRL_MASK                          0x007e3eef
/** Set this to configure the external source for the HFXO. The oscillator
   setting takes effect when 1 is written to HFXOEN in CMU_OSCENCMD. The
   oscillator setting is reset to default when 1 is written to HFXODIS in
   CMU_OSCENCMD. @multiple */
  #define EFM32_CMU_CTRL_HFXOMODE(v)               ((EFM32_CMU_CTRL_HFXOMODE_##v) << 0)
  #define EFM32_CMU_CTRL_HFXOMODE_SET(x, v)        do { (x) = (((x) & ~0x3) | ((EFM32_CMU_CTRL_HFXOMODE_##v) << 0)); } while(0)
  #define EFM32_CMU_CTRL_HFXOMODE_GET(x)           (((x) >> 0) & 0x3)
    #define EFM32_CMU_CTRL_HFXOMODE_XTAL             0x00000000
    #define EFM32_CMU_CTRL_HFXOMODE_BUFEXTCLK        0x00000001
    #define EFM32_CMU_CTRL_HFXOMODE_DIGEEXTCLK       0x00000002
/** Used to adjust start-up boost current for HFXO. @multiple */
  #define EFM32_CMU_CTRL_HFXOBOOST(v)              ((EFM32_CMU_CTRL_HFXOBOOST_##v) << 2)
  #define EFM32_CMU_CTRL_HFXOBOOST_SET(x, v)       do { (x) = (((x) & ~0xc) | ((EFM32_CMU_CTRL_HFXOBOOST_##v) << 2)); } while(0)
  #define EFM32_CMU_CTRL_HFXOBOOST_GET(x)          (((x) >> 2) & 0x3)
    #define EFM32_CMU_CTRL_HFXOBOOST_50PCENT         0x00000000
    #define EFM32_CMU_CTRL_HFXOBOOST_70PCENT         0x00000001
    #define EFM32_CMU_CTRL_HFXOBOOST_80PCENT         0x00000002
    #define EFM32_CMU_CTRL_HFXOBOOST_100PCENT        0x00000003
/** This value has been set during calibration and should not be changed.
   @multiple */
  #define EFM32_CMU_CTRL_HFXOBUFCUR(v)             ((v) << 5)
  #define EFM32_CMU_CTRL_HFXOBUFCUR_SET(x, v)      do { (x) = (((x) & ~0x60) | ((v) << 5)); } while(0)
  #define EFM32_CMU_CTRL_HFXOBUFCUR_GET(x)         (((x) >> 5) & 0x3)
/** This bit enables the glitch detector which is active as long as the start-up
   ripple-counter is counting. A detected glitch will reset the ripple-counter
   effectively increasing the start-up time. Once the ripple-counter has
   timed-out, glitches will not be detected. @multiple */
  #define EFM32_CMU_CTRL_HFXOGLITCHDETEN           0x00000080
/** Configures the start-up delay for HFXO. @multiple */
  #define EFM32_CMU_CTRL_HFXOTIMEOUT(v)            ((EFM32_CMU_CTRL_HFXOTIMEOUT_##v) << 9)
  #define EFM32_CMU_CTRL_HFXOTIMEOUT_SET(x, v)     do { (x) = (((x) & ~0x600) | ((EFM32_CMU_CTRL_HFXOTIMEOUT_##v) << 9)); } while(0)
  #define EFM32_CMU_CTRL_HFXOTIMEOUT_GET(x)        (((x) >> 9) & 0x3)
    #define EFM32_CMU_CTRL_HFXOTIMEOUT_8             0x00000000
    #define EFM32_CMU_CTRL_HFXOTIMEOUT_256           0x00000001
    #define EFM32_CMU_CTRL_HFXOTIMEOUT_1K            0x00000002
    #define EFM32_CMU_CTRL_HFXOTIMEOUT_16K           0x00000003
/** Set this to configure the external source for the LFXO. The oscillator
   setting takes effect when 1 is written to LFXOEN in CMU_OSCENCMD. The
   oscillator setting is reset to default when 1 is written to LFXODIS in
   CMU_OSCENCMD. @multiple */
  #define EFM32_CMU_CTRL_LXOMODE(v)                ((EFM32_CMU_CTRL_LXOMODE_##v) << 11)
  #define EFM32_CMU_CTRL_LXOMODE_SET(x, v)         do { (x) = (((x) & ~0x1800) | ((EFM32_CMU_CTRL_LXOMODE_##v) << 11)); } while(0)
  #define EFM32_CMU_CTRL_LXOMODE_GET(x)            (((x) >> 11) & 0x3)
    #define EFM32_CMU_CTRL_LXOMODE_XTAL              0x00000000
    #define EFM32_CMU_CTRL_LXOMODE_BUFEXTCLK         0x00000001
    #define EFM32_CMU_CTRL_LXOMODE_DIGEXTCLK         0x00000002
/** Adjusts start-up boost current for LFXO. @multiple */
  #define EFM32_CMU_CTRL_LFXOBOOST(v)              ((EFM32_CMU_CTRL_LFXOBOOST_##v) << 13)
  #define EFM32_CMU_CTRL_LFXOBOOST_SET(x, v)       do { (x) = (((x) & ~0x2000) | ((EFM32_CMU_CTRL_LFXOBOOST_##v) << 13)); } while(0)
  #define EFM32_CMU_CTRL_LFXOBOOST_GET(x)          (((x) >> 13) & 0x1)
    #define EFM32_CMU_CTRL_LFXOBOOST_70PCENT         0x00000000
    #define EFM32_CMU_CTRL_LFXOBOOST_100PCENT        0x00000001
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
/** Use to divide HFCLK frequency by (hfclkdiv + 1) @multiple */
  #define EFM32_CMU_CTRL_HFCLKDIV(v)               ((v) << 14)
  #define EFM32_CMU_CTRL_HFCLKDIV_SET(x, v)        do { (x) = (((x) & ~0x1c000) | ((v) << 14)); } while(0)
  #define EFM32_CMU_CTRL_HFCLKDIV_GET(x)           (((x) >> 14) & 0x7)
# endif
/** This value has been updated to the correct level during calibration and
   should not be changed. @multiple */
  #define EFM32_CMU_CTRL_LFXOBUFCUR                0x00020000
/** Configures the start-up delay for LFXO. @multiple */
  #define EFM32_CMU_CTRL_LFXOTIMEOUT(v)            ((EFM32_CMU_CTRL_LFXOTIMEOUT_##v) << 18)
  #define EFM32_CMU_CTRL_LFXOTIMEOUT_SET(x, v)     do { (x) = (((x) & ~0xc0000) | ((EFM32_CMU_CTRL_LFXOTIMEOUT_##v) << 18)); } while(0)
  #define EFM32_CMU_CTRL_LFXOTIMEOUT_GET(x)        (((x) >> 18) & 0x3)
    #define EFM32_CMU_CTRL_LFXOTIMEOUT_8             0x00000000
    #define EFM32_CMU_CTRL_LFXOTIMEOUT_1K            0x00000001
    #define EFM32_CMU_CTRL_LFXOTIMEOUT_16K           0x00000002
    #define EFM32_CMU_CTRL_LFXOTIMEOUT_32K           0x00000003
/** Controls the clock output multiplexer. To actually output on the pin, set
   CLKOUT0PEN in CMU_ROUTE. @multiple */
  #define EFM32_CMU_CTRL_CLKOUTSEL0(v)             ((EFM32_CMU_CTRL_CLKOUTSEL0_##v) << 20)
  #define EFM32_CMU_CTRL_CLKOUTSEL0_SET(x, v)      do { (x) = (((x) & ~0x700000) | ((EFM32_CMU_CTRL_CLKOUTSEL0_##v) << 20)); } while(0)
  #define EFM32_CMU_CTRL_CLKOUTSEL0_GET(x)         (((x) >> 20) & 0x7)
    #define EFM32_CMU_CTRL_CLKOUTSEL0_HFRCO          0x00000000
    #define EFM32_CMU_CTRL_CLKOUTSEL0_HFX0           0x00000001
    #define EFM32_CMU_CTRL_CLKOUTSEL0_HFCLK2         0x00000002
    #define EFM32_CMU_CTRL_CLKOUTSEL0_HFCLK4         0x00000003
    #define EFM32_CMU_CTRL_CLKOUTSEL0_HFCLK8         0x00000004
    #define EFM32_CMU_CTRL_CLKOUTSEL0_HFCLK16        0x00000005
    #define EFM32_CMU_CTRL_CLKOUTSEL0_ULFRCO         0x00000006
    #define EFM32_CMU_CTRL_CLKOUTSEL0_AUXHFRC0       0x00000007
# if defined(CONFIG_EFM32_GECKO)
/** Controls the clock output multiplexer. To actually output on the pin, set
   CLKOUT1PEN in CMU_ROUTE. @multiple */
  #define EFM32_CMU_CTRL_CLKOUTSEL1(v)             ((EFM32_CMU_CTRL_CLKOUTSEL1_##v) << 23)
  #define EFM32_CMU_CTRL_CLKOUTSEL1_SET(x, v)      do { (x) = (((x) & ~0x800000) | ((EFM32_CMU_CTRL_CLKOUTSEL1_##v) << 23)); } while(0)
  #define EFM32_CMU_CTRL_CLKOUTSEL1_GET(x)         (((x) >> 23) & 0x1)
    #define EFM32_CMU_CTRL_CLKOUTSEL1_LFRCO          0x00000000
    #define EFM32_CMU_CTRL_CLKOUTSEL1_LFX0           0x00000001
# endif
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Controls the clock output multiplexer. To actually output on the pin, set
   CLKOUT1PEN in CMU_ROUTE. @multiple */
  #define EFM32_CMU_CTRL_CLKOUTSEL1(v)             ((EFM32_CMU_CTRL_CLKOUTSEL1_##v) << 23)
  #define EFM32_CMU_CTRL_CLKOUTSEL1_SET(x, v)      do { (x) = (((x) & ~0x3800000) | ((EFM32_CMU_CTRL_CLKOUTSEL1_##v) << 23)); } while(0)
  #define EFM32_CMU_CTRL_CLKOUTSEL1_GET(x)         (((x) >> 23) & 0x7)
    #define EFM32_CMU_CTRL_CLKOUTSEL1_LFRCO          0x00000000
    #define EFM32_CMU_CTRL_CLKOUTSEL1_LFX0           0x00000001
    #define EFM32_CMU_CTRL_CLKOUTSEL1_HFCLK          0x00000002
    #define EFM32_CMU_CTRL_CLKOUTSEL1_LFXOQ          0x00000003
    #define EFM32_CMU_CTRL_CLKOUTSEL1_HFXOQ          0x00000004
    #define EFM32_CMU_CTRL_CLKOUTSEL1_LFRCOQ         0x00000005
    #define EFM32_CMU_CTRL_CLKOUTSEL1_HFRCOQ         0x00000006
    #define EFM32_CMU_CTRL_CLKOUTSEL1_AUXHFCOQ       0x00000007
# endif
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
/** Select clock used for the debug system @multiple */
  #define EFM32_CMU_CTRL_DBGCLK(v)                 ((EFM32_CMU_CTRL_DBGCLK_##v) << 28)
  #define EFM32_CMU_CTRL_DBGCLK_SET(x, v)          do { (x) = (((x) & ~0x10000000) | ((EFM32_CMU_CTRL_DBGCLK_##v) << 28)); } while(0)
  #define EFM32_CMU_CTRL_DBGCLK_GET(x)             (((x) >> 28) & 0x1)
    #define EFM32_CMU_CTRL_DBGCLK_AUXHFRCO           0x00000000
    #define EFM32_CMU_CTRL_DBGCLK_HFCLK              0x00000001
/** Set to allow access to LE peripheral when running at frequencis higher than
   24Mhz. @multiple */
  #define EFM32_CMU_CTRL_HFLE                      0x40000000
# endif

#define EFM32_CMU_HFCORECLKDIV_ADDR                  0x00000004
#define EFM32_CMU_HFCORECLKDIV_MASK                  0x0000010f
/** Specifies the clock divider for the HFPERCLK. @multiple */
  #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV(v)   ((EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_##v) << 0)
  #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_SET(x, v) do { (x) = (((x) & ~0xf) | ((EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_##v) << 0)); } while(0)
  #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_GET(x) (((x) >> 0) & 0xf)
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK 0x00000000
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK2 0x00000001
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK4 0x00000002
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK8 0x00000003
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK16 0x00000004
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK32 0x00000005
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK64 0x00000006
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK128 0x00000007
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK256 0x00000008
    #define EFM32_CMU_HFCORECLKDIV_HFCORECLKDIV_HFCLK512 0x00000009
/** Set to enable the HFPERCLK. @multiple */
  #define EFM32_CMU_HFCORECLKDIV_HFPERCLKEN        0x00000100

#define EFM32_CMU_HFPERCLKDIV_ADDR                   0x00000008
#define EFM32_CMU_HFPERCLKDIV_MASK                   0x0000010f
/** Specifies the clock divider for the HFPERCLK. @multiple */
  #define EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV(v)    ((EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV_##v) << 0)
  #define EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV_SET(x, v) do { (x) = (((x) & ~0xf) | ((EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV_##v) << 0)); } while(0)
  #define EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV_GET(x) (((x) >> 0) & 0xf)
    #define EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV_HFCLK 0x00000000
    #define EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV_HFCLK2 0x00000001
    #define EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV_HFCLK4 0x00000002
    #define EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV_HFCLK8 0x00000003
    #define EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV_HFCLK16 0x00000004
    #define EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV_HFCLK32 0x00000005
    #define EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV_HFCLK64 0x00000006
    #define EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV_HFCLK128 0x00000007
    #define EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV_HFCLK256 0x00000008
    #define EFM32_CMU_HFPERCLKDIV_HFCORECLKDIV_HFCLK512 0x00000009
/** Set to enable the HFPERCLK. @multiple */
  #define EFM32_CMU_HFPERCLKDIV_HFPERCLKEN         0x00000100

#define EFM32_CMU_HFRCOCTRL_ADDR                     0x0000000c
#define EFM32_CMU_HFRCOCTRL_MASK                     0x0001f7ff
/** Writing this field adjusts the HFRCO frequency (the higher value, the higher
   frequency). This field is updated with the production calibrated value for the
   14 MHz band during reset, and the reset value might therefore vary between
   devices. @multiple */
  #define EFM32_CMU_HFRCOCTRL_TUNNING(v)           ((v) << 0)
  #define EFM32_CMU_HFRCOCTRL_TUNNING_SET(x, v)    do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define EFM32_CMU_HFRCOCTRL_TUNNING_GET(x)       (((x) >> 0) & 0xff)
/** Write this field to set the frequency band in which the HFRCO is to operate.
   When changing this setting there will be no glitches on the HFRCO output,
   hence it is safe to change this setting even while the system is running on
   the HFRCO. To ensure an accurate frequency, the HFTUNING value should also be
   written when changing the frequency band. The calibrated tuning value for the
   different bands can be read from the Device Information page. @multiple */
  #define EFM32_CMU_HFRCOCTRL_BAND(v)              ((EFM32_CMU_HFRCOCTRL_BAND_##v) << 8)
  #define EFM32_CMU_HFRCOCTRL_BAND_SET(x, v)       do { (x) = (((x) & ~0x700) | ((EFM32_CMU_HFRCOCTRL_BAND_##v) << 8)); } while(0)
  #define EFM32_CMU_HFRCOCTRL_BAND_GET(x)          (((x) >> 8) & 0x7)
    #define EFM32_CMU_HFRCOCTRL_BAND_1MHZ            0x00000000
    #define EFM32_CMU_HFRCOCTRL_BAND_7MHZ            0x00000001
    #define EFM32_CMU_HFRCOCTRL_BAND_11MHZ           0x00000002
    #define EFM32_CMU_HFRCOCTRL_BAND_14MHZ           0x00000003
    #define EFM32_CMU_HFRCOCTRL_BAND_21MHZ           0x00000004
/** not available on all devices */
    #define EFM32_CMU_HFRCOCTRL_BAND_28MHZ           0x00000005
/** Always write this field to 0. @multiple */
  #define EFM32_CMU_HFRCOCTRL_SUDELAY(v)           ((v) << 12)
  #define EFM32_CMU_HFRCOCTRL_SUDELAY_SET(x, v)    do { (x) = (((x) & ~0x1f000) | ((v) << 12)); } while(0)
  #define EFM32_CMU_HFRCOCTRL_SUDELAY_GET(x)       (((x) >> 12) & 0x1f)

#define EFM32_CMU_LFRCOCTRL_ADDR                     0x00000010
#define EFM32_CMU_LFRCOCTRL_MASK                     0x0000007f
/** Writing this field adjusts the LFRCO frequency (the higher value, the higher
   frequency). This field is updated with the production calibrated value during
   reset, and the reset value might therefore vary between devices. @multiple */
  #define EFM32_CMU_LFRCOCTRL_TUNNING(v)           ((v) << 0)
  #define EFM32_CMU_LFRCOCTRL_TUNNING_SET(x, v)    do { (x) = (((x) & ~0x7f) | ((v) << 0)); } while(0)
  #define EFM32_CMU_LFRCOCTRL_TUNNING_GET(x)       (((x) >> 0) & 0x7f)

#define EFM32_CMU_AUXHFRCOCTRL_ADDR                  0x00000014
#define EFM32_CMU_AUXHFRCOCTRL_MASK                  0x000000ff
/** Writing this field adjusts the AUXHFRCO frequency (the higher value, the
   higher frequency). This field is updated with the production calibrated value
   during reset, and the reset value might therefore vary between devices.
   @multiple */
  #define EFM32_CMU_AUXHFRCOCTRL_TUNNING(v)        ((v) << 0)
  #define EFM32_CMU_AUXHFRCOCTRL_TUNNING_SET(x, v) do { (x) = (((x) & ~0xff) | ((v) << 0)); } while(0)
  #define EFM32_CMU_AUXHFRCOCTRL_TUNNING_GET(x)    (((x) >> 0) & 0xff)
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Write this field to set the frequency band in which the HFRCO is to operate.
   When changing this setting there will be no glitches on the AUXHFRCO output,
   hence it is safe to change this setting even while the system is running on
   the AUXHFRCO. To ensure an accurate frequency, the AUXTUNING value should also
   be written when changing the frequency band. The calibrated tuning value for
   the different bands can be read from the Device Information page. Flash erase
   and write use this clock. If it is changed to another value than the default,
   MSC_TIMEBASE must also be configured to ensure correct flash erase and write
   operation. @multiple */
  #define EFM32_CMU_AUXHFRCOCTRL_BAND(v)           ((EFM32_CMU_AUXHFRCOCTRL_BAND_##v) << 8)
  #define EFM32_CMU_AUXHFRCOCTRL_BAND_SET(x, v)    do { (x) = (((x) & ~0x700) | ((EFM32_CMU_AUXHFRCOCTRL_BAND_##v) << 8)); } while(0)
  #define EFM32_CMU_AUXHFRCOCTRL_BAND_GET(x)       (((x) >> 8) & 0x7)
    #define EFM32_CMU_AUXHFRCOCTRL_BAND_14MHZ        0x00000000
    #define EFM32_CMU_AUXHFRCOCTRL_BAND_11MHZ        0x00000001
    #define EFM32_CMU_AUXHFRCOCTRL_BAND_7MHZ         0x00000002
    #define EFM32_CMU_AUXHFRCOCTRL_BAND_1MHZ         0x00000003
/** not available on all devices */
    #define EFM32_CMU_AUXHFRCOCTRL_BAND_28MHZ        0x00000006
    #define EFM32_CMU_AUXHFRCOCTRL_BAND_21MHZ        0x00000007
# endif

#define EFM32_CMU_CALCTRL_ADDR                       0x00000018
#define EFM32_CMU_CALCTRL_MASK                       0x00000007
/** Selects clock source for the calibration up-counter. @multiple */
  #define EFM32_CMU_CALCTRL_UPSEL(v)               ((EFM32_CMU_CALCTRL_UPSEL_##v) << 0)
  #define EFM32_CMU_CALCTRL_UPSEL_SET(x, v)        do { (x) = (((x) & ~0x7) | ((EFM32_CMU_CALCTRL_UPSEL_##v) << 0)); } while(0)
  #define EFM32_CMU_CALCTRL_UPSEL_GET(x)           (((x) >> 0) & 0x7)
    #define EFM32_CMU_CALCTRL_UPSEL_HFXO             0x00000000
    #define EFM32_CMU_CALCTRL_UPSEL_LFXO             0x00000001
    #define EFM32_CMU_CALCTRL_UPSEL_HFRCO            0x00000002
    #define EFM32_CMU_CALCTRL_UPSEL_LFRCO            0x00000003
    #define EFM32_CMU_CALCTRL_UPSEL_AUXHFRCO         0x00000004
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Selects clock source for the calibration down-counter. @multiple */
  #define EFM32_CMU_CALCTRL_DOWNSEL(v)             ((EFM32_CMU_CALCTRL_DOWNSEL_##v) << 3)
  #define EFM32_CMU_CALCTRL_DOWNSEL_SET(x, v)      do { (x) = (((x) & ~0x38) | ((EFM32_CMU_CALCTRL_DOWNSEL_##v) << 3)); } while(0)
  #define EFM32_CMU_CALCTRL_DOWNSEL_GET(x)         (((x) >> 3) & 0x7)
    #define EFM32_CMU_CALCTRL_DOWNSEL_HFCLK          0x00000000
    #define EFM32_CMU_CALCTRL_DOWNSEL_HFXO           0x00000001
    #define EFM32_CMU_CALCTRL_DOWNSEL_LFXO           0x00000002
    #define EFM32_CMU_CALCTRL_DOWNSEL_HFRCO          0x00000003
    #define EFM32_CMU_CALCTRL_DOWNSEL_LFRCO          0x00000004
    #define EFM32_CMU_CALCTRL_DOWNSEL_AUXHFRCO       0x00000005
/** Set this bit to enable continuous calibration. @multiple */
  #define EFM32_CMU_CALCTRL_CONT                   0x00000040
# endif

#define EFM32_CMU_CALCNT_ADDR                        0x0000001c
#define EFM32_CMU_CALCNT_MASK                        0x000fffff
/** Write top value before calibration. Read calibration result from this
   register when Calibration Ready flag has been set. @multiple */
  #define EFM32_CMU_CALCNT_CALCNT(v)               ((v) << 0)
  #define EFM32_CMU_CALCNT_CALCNT_SET(x, v)        do { (x) = (((x) & ~0xfffff) | ((v) << 0)); } while(0)
  #define EFM32_CMU_CALCNT_CALCNT_GET(x)           (((x) >> 0) & 0xfffff)

#define EFM32_CMU_OSCENCMD_ADDR                      0x00000020
#define EFM32_CMU_OSCENCMD_MASK                      0x000003ff
/** Enables the HFRCO. @multiple */
  #define EFM32_CMU_OSCENCMD_HFRCOEN               0x00000001
/** Disables the HFRCO. HFRCOEN has higher priority if written simultaneously.
   WARNING: Do not disable the HFRCO if this oscillator is selected as the source
   for HFCLK. @multiple */
  #define EFM32_CMU_OSCENCMD_HFRCODIS              0x00000002
/** Enables the HFXO. @multiple */
  #define EFM32_CMU_OSCENCMD_HFXOEN                0x00000004
/** Disables the HFXO. HFXOEN has higher priority if written simultaneously.
   WARNING: Do not disable the HFRXO if this oscillator is selected as the source
   for HFCLK. @multiple */
  #define EFM32_CMU_OSCENCMD_HFXODIS               0x00000008
/** Enables the AUXHFRCO. @multiple */
  #define EFM32_CMU_OSCENCMD_AUXHFRCOEN            0x00000010
/** Disables the AUXHFRCO. AUXHFRCOEN has higher priority if written
   simultaneously. WARNING: Do not disable this clock during a flash erase/write
   operation. @multiple */
  #define EFM32_CMU_OSCENCMD_AUXHFRCODIS           0x00000020
/** Enables the LFRCO. @multiple */
  #define EFM32_CMU_OSCENCMD_LFRCOEN               0x00000040
/** Disables the LFRCO. LFRCOEN has higher priority if written simultaneously.
   @multiple */
  #define EFM32_CMU_OSCENCMD_LFRCODIS              0x00000080
/** Enables the LFXOEN. @multiple */
  #define EFM32_CMU_OSCENCMD_LFXOEN                0x00000100
/** Disables the LFXO. LFXOEN has higher priority if written simultaneously.
   @multiple */
  #define EFM32_CMU_OSCENCMD_LFXODIS               0x00000200

#define EFM32_CMU_CMD_ADDR                           0x00000024
#define EFM32_CMU_CMD_MASK                           0x0000000f
/** Selects the clock source for HFCLK. Note that selecting an oscillator that is
   disabled will cause the system clock to stop. Check the status register and
   confirm that oscillator is ready before switching. @multiple */
  #define EFM32_CMU_CMD_HFCLKSEL(v)                ((EFM32_CMU_CMD_HFCLKSEL_##v) << 0)
  #define EFM32_CMU_CMD_HFCLKSEL_SET(x, v)         do { (x) = (((x) & ~0x7) | ((EFM32_CMU_CMD_HFCLKSEL_##v) << 0)); } while(0)
  #define EFM32_CMU_CMD_HFCLKSEL_GET(x)            (((x) >> 0) & 0x7)
    #define EFM32_CMU_CMD_HFCLKSEL_HFRCO             0x00000001
    #define EFM32_CMU_CMD_HFCLKSEL_HFXO              0x00000002
    #define EFM32_CMU_CMD_HFCLKSEL_LFRCO             0x00000003
    #define EFM32_CMU_CMD_HFCLKSEL_LFXO              0x00000004
/** Starts the calibration, effectively loading the CMU_CALCNT into the
   down-counter and start decrementing. @multiple */
  #define EFM32_CMU_CMD_CALSTART                   0x00000008
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Stops the calibration counters. @multiple */
  #define EFM32_CMU_CMD_CALSTOP                    0x00000010
# endif
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
/** Selects the clock for HFCORECLKUSBC. Thes tatus register is updated chen the
   clock switch has taken effect. @multiple */
  #define EFM32_CMU_CMD_USBCCLKSEL(v)              ((EFM32_CMU_CMD_USBCCLKSEL_##v) << 5)
  #define EFM32_CMU_CMD_USBCCLKSEL_SET(x, v)       do { (x) = (((x) & ~0x60) | ((EFM32_CMU_CMD_USBCCLKSEL_##v) << 5)); } while(0)
  #define EFM32_CMU_CMD_USBCCLKSEL_GET(x)          (((x) >> 5) & 0x3)
    #define EFM32_CMU_CMD_USBCCLKSEL_HFCLKNODIV      0x00000001
    #define EFM32_CMU_CMD_USBCCLKSEL_LFXO            0x00000002
    #define EFM32_CMU_CMD_USBCCLKSEL_LFRCO           0x00000003
# endif

#define EFM32_CMU_LFCLKSEL_ADDR                      0x00000028
#define EFM32_CMU_LFCLKSEL_MASK                      0x0000000f
/** Selects the clock source for LFACLK. Tied to LFAE. @multiple */
  #define EFM32_CMU_LFCLKSEL_LFA(v)                ((EFM32_CMU_LFCLKSEL_LFA_##v) << 0)
  #define EFM32_CMU_LFCLKSEL_LFA_SET(x, v)         do { (x) = (((x) & ~0x3) | ((EFM32_CMU_LFCLKSEL_LFA_##v) << 0)); } while(0)
  #define EFM32_CMU_LFCLKSEL_LFA_GET(x)            (((x) >> 0) & 0x3)
    #define EFM32_CMU_LFCLKSEL_LFA_DISABLED_OR_ULFRCO 0x00000000
    #define EFM32_CMU_LFCLKSEL_LFA_LFRCO             0x00000001
    #define EFM32_CMU_LFCLKSEL_LFA_LFXO              0x00000002
    #define EFM32_CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2   0x00000003
/** Selects the clock source for LFBCLK. Tied to LFBE. @multiple */
  #define EFM32_CMU_LFCLKSEL_LFB(v)                ((EFM32_CMU_LFCLKSEL_LFB_##v) << 2)
  #define EFM32_CMU_LFCLKSEL_LFB_SET(x, v)         do { (x) = (((x) & ~0xc) | ((EFM32_CMU_LFCLKSEL_LFB_##v) << 2)); } while(0)
  #define EFM32_CMU_LFCLKSEL_LFB_GET(x)            (((x) >> 2) & 0x3)
    #define EFM32_CMU_LFCLKSEL_LFB_DISABLED_OR_ULFRCO 0x00000000
    #define EFM32_CMU_LFCLKSEL_LFB_LFRCO             0x00000001
    #define EFM32_CMU_LFCLKSEL_LFB_LFXO              0x00000002
    #define EFM32_CMU_LFCLKSEL_LFB_HFCORECLKLEDIV2   0x00000003
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** This bit redefines the meaning of the LFA field. @multiple */
  #define EFM32_CMU_LFCLKSEL_LFAE(v)               ((EFM32_CMU_LFCLKSEL_LFAE_##v) << 16)
  #define EFM32_CMU_LFCLKSEL_LFAE_SET(x, v)        do { (x) = (((x) & ~0x10000) | ((EFM32_CMU_LFCLKSEL_LFAE_##v) << 16)); } while(0)
  #define EFM32_CMU_LFCLKSEL_LFAE_GET(x)           (((x) >> 16) & 0x1)
    #define EFM32_CMU_LFCLKSEL_LFAE_DISABLED         0x00000000
    #define EFM32_CMU_LFCLKSEL_LFAE_ULFRCO           0x00000001
/** This bit redefines the meaning of the LFB field. @multiple */
  #define EFM32_CMU_LFCLKSEL_LFBE(v)               ((EFM32_CMU_LFCLKSEL_LFBE_##v) << 20)
  #define EFM32_CMU_LFCLKSEL_LFBE_SET(x, v)        do { (x) = (((x) & ~0x100000) | ((EFM32_CMU_LFCLKSEL_LFBE_##v) << 20)); } while(0)
  #define EFM32_CMU_LFCLKSEL_LFBE_GET(x)           (((x) >> 20) & 0x1)
    #define EFM32_CMU_LFCLKSEL_LFBE_DISABLED         0x00000000
    #define EFM32_CMU_LFCLKSEL_LFBE_ULFRCO           0x00000001
# endif

#define EFM32_CMU_STATUS_ADDR                        0x0000002c
#define EFM32_CMU_STATUS_MASK                        0x00007fff
/** HFRCO is enabled. @multiple */
  #define EFM32_CMU_STATUS_HFRCOENS                0x00000001
/** HFRCO is enabled and start-up time has exceeded. @multiple */
  #define EFM32_CMU_STATUS_HFRCORDY                0x00000002
/** HFXO is enabled. @multiple */
  #define EFM32_CMU_STATUS_HFXOENS                 0x00000004
/** HFXO is enabled and start-up time has exceeded. @multiple */
  #define EFM32_CMU_STATUS_HFXORDY                 0x00000008
/** AUXHFRCO is enabled. @multiple */
  #define EFM32_CMU_STATUS_AUXHFRCOENS             0x00000010
/** AUXHFRCO is enabled and start-up time has exceeded. @multiple */
  #define EFM32_CMU_STATUS_AUXHFRCORDY             0x00000020
/** LFRCO is enabled. @multiple */
  #define EFM32_CMU_STATUS_LFRCOENS                0x00000040
/** LFRCO is enabled and start-up time has exceeded. @multiple */
  #define EFM32_CMU_STATUS_LFRCORDY                0x00000080
/** LFXO is enabled. @multiple */
  #define EFM32_CMU_STATUS_LFXOENS                 0x00000100
/** LFXO is enabled and start-up time has exceeded. @multiple */
  #define EFM32_CMU_STATUS_LFXORDY                 0x00000200
/** HFRCO is selected as HFCLK clock source. @multiple */
  #define EFM32_CMU_STATUS_HFRCOSEL                0x00000400
/** HFXO is selected as HFCLK clock source. @multiple */
  #define EFM32_CMU_STATUS_HFXOSEL                 0x00000800
/** LFRCO is selected as HFCLK clock source. @multiple */
  #define EFM32_CMU_STATUS_LFRCOSEL                0x00001000
/** LFXO is selected as HFCLK clock source. @multiple */
  #define EFM32_CMU_STATUS_LFXOSEL                 0x00002000
/** Calibration is on-going. @multiple */
  #define EFM32_CMU_STATUS_CALBSY                  0x00004000
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
/** HFCLK is selected (and active) as HFCORECLKUSBC @multiple */
  #define EFM32_CMU_STATUS_USBCHFCLKSEL            0x00008000
/** LFXO is selected (and active) as HFCORECLKUSBC @multiple */
  #define EFM32_CMU_STATUS_USBCLFXOSEL             0x00010000
/** LFRCO is selected (and active) as HFCORECLKUSBC @multiple */
  #define EFM32_CMU_STATUS_USBCLFRCOSEL            0x00020000
# endif

#define EFM32_CMU_IF_ADDR                            0x00000030
#define EFM32_CMU_IF_MASK                            0x0000003f
/** Set when HFRCO is ready (start-up time exceeded). @multiple */
  #define EFM32_CMU_IF_HFRCORDY                    0x00000001
/** Set when HFXO is ready (start-up time exceeded). @multiple */
  #define EFM32_CMU_IF_HFXORDY                     0x00000002
/** Set when LFRCO is ready (start-up time exceeded). @multiple */
  #define EFM32_CMU_IF_LFRCORDY                    0x00000004
/** Set when LFXO is ready (start-up time exceeded). @multiple */
  #define EFM32_CMU_IF_LFXORDY                     0x00000008
/** Set when AUXHFRCO is ready (start-up time exceeded). @multiple */
  #define EFM32_CMU_IF_AUXHFRCORDY                 0x00000010
/** Set when calibration is completed. @multiple */
  #define EFM32_CMU_IF_CALRDY                      0x00000020
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Set when calibration overflow has occurred @multiple */
  #define EFM32_CMU_IF_CALOF                       0x00000040
# endif
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
/** set when HFCLK is selected as HFCORECLKUSBC @multiple */
  #define EFM32_CMU_IF_USBCHFCLKSEL                0x00000080
# endif

#define EFM32_CMU_IFS_ADDR                           0x00000034
#define EFM32_CMU_IFS_MASK                           0x0000003f
/** Write to 1 to set the HFRCO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFS_HFRCORDY                   0x00000001
/** Write to 1 to set the HFXO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFS_HFXORDY                    0x00000002
/** Write to 1 to set the LFRCO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFS_LFRCORDY                   0x00000004
/** Write to 1 to set the LFXO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFS_LFXORDY                    0x00000008
/** Write to 1 to set the AUXHFRCO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFS_AUXHFRCORDY                0x00000010
/** Write to 1 to set the Calibration Ready(completed) Interrupt Flag. @multiple
   */
  #define EFM32_CMU_IFS_CALRDY                     0x00000020
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Write to 1 to set the Calibration Overflow Interrupt Flag. @multiple */
  #define EFM32_CMU_IFS_CALOF                      0x00000040
# endif
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
/** set when HFCLK is selected as HFCORECLKUSBC @multiple */
  #define EFM32_CMU_IFS_USBCHFCLKSEL               0x00000080
# endif

#define EFM32_CMU_IFC_ADDR                           0x00000038
#define EFM32_CMU_IFC_MASK                           0x0000003f
/** Write to 1 to clear the HFRCO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFC_HFRCORDY                   0x00000001
/** Write to 1 to clear the HFXO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFC_HFXORDY                    0x00000002
/** Write to 1 to clear the LFRCO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFC_LFRCORDY                   0x00000004
/** Write to 1 to clear the LFXO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFC_LFXORDY                    0x00000008
/** Write to 1 to clear the AUXHFRCO Ready Interrupt Flag. @multiple */
  #define EFM32_CMU_IFC_AUXHFRCORDY                0x00000010
/** Write to 1 to clear the Calibration Ready(completed) Interrupt Flag.
   @multiple */
  #define EFM32_CMU_IFC_CALRDY                     0x00000020
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Write to 1 to clear the Calibration Overflow Interrupt Flag. @multiple */
  #define EFM32_CMU_IFC_CALOF                      0x00000040
# endif
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
/** set when HFCLK is selected as HFCORECLKUSBC @multiple */
  #define EFM32_CMU_IFC_USBCHFCLKSEL               0x00000080
# endif

#define EFM32_CMU_IEN_ADDR                           0x0000003c
#define EFM32_CMU_IEN_MASK                           0x0000003f
/** Set to enable the HFRCO Ready Interrupt. @multiple */
  #define EFM32_CMU_IEN_HFRCORDY                   0x00000001
/** Set to enable the HFXO Ready Interrupt. @multiple */
  #define EFM32_CMU_IEN_HFXORDY                    0x00000002
/** Set to enable the LFRCO Ready Interrupt. @multiple */
  #define EFM32_CMU_IEN_LFRCORDY                   0x00000004
/** Set to enable the LFXO Ready Interrupt. @multiple */
  #define EFM32_CMU_IEN_LFXORDY                    0x00000008
/** Set to enable the AUXHFRCO Ready Interrupt. @multiple */
  #define EFM32_CMU_IEN_AUXHFRCORDY                0x00000010
/** Set to enable the Calibration Ready(completed) Interrupt. @multiple */
  #define EFM32_CMU_IEN_CALRDY                     0x00000020
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO) || defined(CONFIG_EFM32_ZERO_GECKO)
/** Set to enable the Calibration Overflow Interrupt. @multiple */
  #define EFM32_CMU_IEN_CALOF                      0x00000040
# endif
# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
/** set when HFCLK is selected as HFCORECLKUSBC @multiple */
  #define EFM32_CMU_IEN_USBCHFCLKSEL               0x00000080
# endif

# if defined(CONFIG_EFM32_GECKO)
#define EFM32_CMU_HFCORECLKEN0_ADDR                  0x00000040
#define EFM32_CMU_HFCORECLKEN0_MASK                  0x0000000f
/** Set to enable the clock for AES. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_AES               0x00000001
/** Set to enable the clock for DMA. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_DMA               0x00000002
/** Set to enable the clock for LE. Interface used for bus access to Low Energy
   peripherals. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_LE                0x00000004
/** Set to enable the clock for EBI. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_EBI               0x00000008
# endif

# if defined(CONFIG_EFM32_ZERO_GECKO)
#define EFM32_CMU_HFCORECLKEN0_ADDR                  0x00000040
#define EFM32_CMU_HFCORECLKEN0_MASK                  0x00000007
/** Set to enable the clock for AES. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_AES               0x00000001
/** Set to enable the clock for DMA. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_DMA               0x00000002
/** Set to enable the clock for LE. Interface used for bus access to Low Energy
   peripherals. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_LE                0x00000004
# endif

# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
#define EFM32_CMU_HFCORECLKEN0_ADDR                  0x00000040
#define EFM32_CMU_HFCORECLKEN0_MASK                  0x0000003f
/** Set to enable the clock for DMA. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_DMA               0x00000001
/** Set to enable the clock for AES. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_AES               0x00000002
/** Set to enable the clock for USBC. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_USBC              0x00000004
/** Set to enable the clock for USB. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_USB               0x00000008
/** Set to enable the clock for LE. Interface used for bus access to Low Energy
   peripherals. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_LE                0x00000010
/** Set to enable the clock for EBI. @multiple */
  #define EFM32_CMU_HFCORECLKEN0_EBI               0x00000020
# endif

# if defined(CONFIG_EFM32_GECKO)
#define EFM32_CMU_HFPERCLKEN0_ADDR                   0x00000044
#define EFM32_CMU_HFPERCLKEN0_MASK                   0x0000fdff
/** Set to enable the clock for USART1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_USART0             0x00000001
/** Set to enable the clock for USART1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_USART1             0x00000002
/** Set to enable the clock for USART1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_USART2             0x00000004
/** Set to enable the clock for USART1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_UART0              0x00000008
/** Set to enable the clock for TIMER0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER0             0x00000010
/** Set to enable the clock for TIMER1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER1             0x00000020
/** Set to enable the clock for TIMER1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER2             0x00000040
/** Set to enable the clock for ACMP0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ACMP0              0x00000080
/** Set to enable the clock for ACMP0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ACMP1              0x00000100
/** Set to enable the clock for PRS. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_PRS                0x00000400
/** Set to enable the clock for DAC0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_DAC0               0x00000800
/** Set to enable the clock for GPIO. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_GPIO               0x00001000
/** Set to enable the clock for VCMP. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_VCMP               0x00002000
/** Set to enable the clock for ADC0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ADC0               0x00004000
/** Set to enable the clock for I2C0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_I2C0               0x00008000
# endif

# if defined(CONFIG_EFM32_ZERO_GECKO)
#define EFM32_CMU_HFPERCLKEN0_ADDR                   0x00000044
#define EFM32_CMU_HFPERCLKEN0_MASK                   0x00000ddf
/** Set to enable the clock for TIMER0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER0             0x00000001
/** Set to enable the clock for TIMER1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER1             0x00000002
/** Set to enable the clock for ACMP0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ACMP0              0x00000004
/** Set to enable the clock for USART1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_USART1             0x00000008
/** Set to enable the clock for PRS. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_PRS                0x00000010
/** Set to enable the clock for IDAC0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_IDAC0              0x00000040
/** Set to enable the clock for GPIO. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_GPIO               0x00000080
/** Set to enable the clock for VCMP. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_VCMP               0x00000100
/** Set to enable the clock for ADC0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ADC0               0x00000400
/** Set to enable the clock for I2C0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_I2C0               0x00000800
# endif

# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
#define EFM32_CMU_HFPERCLKEN0_ADDR                   0x00000044
#define EFM32_CMU_HFPERCLKEN0_MASK                   0x0003ffff
/** Set to enable the clock for USART0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_USART0             0x00000001
/** Set to enable the clock for USART1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_USART1             0x00000002
/** Set to enable the clock for USART2. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_USART2             0x00000004
/** Set to enable the clock for UART0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_UART0              0x00000008
/** Set to enable the clock for UART1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_UART1              0x00000010
/** Set to enable the clock for timer0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER0             0x00000020
/** Set to enable the clock for timer1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER1             0x00000040
/** Set to enable the clock for timer2. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER2             0x00000080
/** Set to enable the clock for timer3. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_TIMER3             0x00000100
/** Set to enable the clock for ACMP0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ACMP0              0x00000200
/** Set to enable the clock for ACMP0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ACMP1              0x00000400
/** Set to enable the clock for I2C0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_I2C0               0x00000800
/** Set to enable the clock for I2C1. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_I2C1               0x00001000
/** Set to enable the clock for GPIO. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_GPIO               0x00002000
/** Set to enable the clock for VCMP. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_VCMP               0x00004000
/** Set to enable the clock for PRS. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_PRS                0x00008000
/** Set to enable the clock for ADC0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_ADC0               0x00010000
/** Set to enable the clock for DAC0. @multiple */
  #define EFM32_CMU_HFPERCLKEN0_DAC0               0x00020000
# endif

#define EFM32_CMU_SYNCBUSY_ADDR                      0x00000050
#define EFM32_CMU_SYNCBUSY_MASK                      0x00000035
/** Used to check the synchronization status of CMU_LFACLKEN0. @multiple */
  #define EFM32_CMU_SYNCBUSY_LFACLKEN0(v)          ((EFM32_CMU_SYNCBUSY_LFACLKEN0_##v) << 0)
  #define EFM32_CMU_SYNCBUSY_LFACLKEN0_SET(x, v)   do { (x) = (((x) & ~0x1) | ((EFM32_CMU_SYNCBUSY_LFACLKEN0_##v) << 0)); } while(0)
  #define EFM32_CMU_SYNCBUSY_LFACLKEN0_GET(x)      (((x) >> 0) & 0x1)
    #define EFM32_CMU_SYNCBUSY_LFACLKEN0_READY       0x00000000
    #define EFM32_CMU_SYNCBUSY_LFACLKEN0_BUSY        0x00000001
/** Used to check the synchronization status of CMU_LFAPRESC0. @multiple */
  #define EFM32_CMU_SYNCBUSY_LFAPRESC0(v)          ((EFM32_CMU_SYNCBUSY_LFAPRESC0_##v) << 2)
  #define EFM32_CMU_SYNCBUSY_LFAPRESC0_SET(x, v)   do { (x) = (((x) & ~0x4) | ((EFM32_CMU_SYNCBUSY_LFAPRESC0_##v) << 2)); } while(0)
  #define EFM32_CMU_SYNCBUSY_LFAPRESC0_GET(x)      (((x) >> 2) & 0x1)
    #define EFM32_CMU_SYNCBUSY_LFAPRESC0_READY       0x00000000
    #define EFM32_CMU_SYNCBUSY_LFAPRESC0_BUSY        0x00000001
/** Used to check the synchronization status of CMU_LFBCLKEN0. @multiple */
  #define EFM32_CMU_SYNCBUSY_LFBCLKEN0(v)          ((EFM32_CMU_SYNCBUSY_LFBCLKEN0_##v) << 4)
  #define EFM32_CMU_SYNCBUSY_LFBCLKEN0_SET(x, v)   do { (x) = (((x) & ~0x10) | ((EFM32_CMU_SYNCBUSY_LFBCLKEN0_##v) << 4)); } while(0)
  #define EFM32_CMU_SYNCBUSY_LFBCLKEN0_GET(x)      (((x) >> 4) & 0x1)
    #define EFM32_CMU_SYNCBUSY_LFBCLKEN0_READY       0x00000000
    #define EFM32_CMU_SYNCBUSY_LFBCLKEN0_BUSY        0x00000001
/** Used to check the synchronization status of CMU_LFBPRESC0. @multiple */
  #define EFM32_CMU_SYNCBUSY_LFBPRESC0(v)          ((EFM32_CMU_SYNCBUSY_LFBPRESC0_##v) << 5)
  #define EFM32_CMU_SYNCBUSY_LFBPRESC0_SET(x, v)   do { (x) = (((x) & ~0x20) | ((EFM32_CMU_SYNCBUSY_LFBPRESC0_##v) << 5)); } while(0)
  #define EFM32_CMU_SYNCBUSY_LFBPRESC0_GET(x)      (((x) >> 5) & 0x1)
    #define EFM32_CMU_SYNCBUSY_LFBPRESC0_READY       0x00000000
    #define EFM32_CMU_SYNCBUSY_LFBPRESC0_BUSY        0x00000001

#define EFM32_CMU_FREEZE_ADDR                        0x00000054
#define EFM32_CMU_FREEZE_MASK                        0x00000001
/** When set, the update of the Low Frequency clock control registers is
   postponed until this bit is cleared. Use this bit to update several registers
   simultaneously. @multiple */
  #define EFM32_CMU_FREEZE_REGFREEZE(v)            ((EFM32_CMU_FREEZE_REGFREEZE_##v) << 0)
  #define EFM32_CMU_FREEZE_REGFREEZE_SET(x, v)     do { (x) = (((x) & ~0x1) | ((EFM32_CMU_FREEZE_REGFREEZE_##v) << 0)); } while(0)
  #define EFM32_CMU_FREEZE_REGFREEZE_GET(x)        (((x) >> 0) & 0x1)
    #define EFM32_CMU_FREEZE_REGFREEZE_UPDATE        0x00000000
    #define EFM32_CMU_FREEZE_REGFREEZE_FREEZE        0x00000001

# if defined(CONFIG_EFM32_GECKO)
#define EFM32_CMU_LFACLKEN0_ADDR                     0x00000058
#define EFM32_CMU_LFACLKEN0_MASK                     0x00000007
/** Set to enable the clock for RTC. @multiple */
  #define EFM32_CMU_LFACLKEN0_RTC                  0x00000001
/** Set to enable the clock for LETIMER0. @multiple */
  #define EFM32_CMU_LFACLKEN0_LETIMER0             0x00000002
/** Set to enable the clock for LCD. @multiple */
  #define EFM32_CMU_LFACLKEN0_LCD                  0x00000004
# endif

# if defined(CONFIG_EFM32_ZERO_GECKO)
#define EFM32_CMU_LFACLKEN0_ADDR                     0x00000058
#define EFM32_CMU_LFACLKEN0_MASK                     0x00000001
/** Set to enable the clock for RTC. @multiple */
  #define EFM32_CMU_LFACLKEN0_RTC                  0x00000001
# endif

# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
#define EFM32_CMU_LFACLKEN0_ADDR                     0x00000058
#define EFM32_CMU_LFACLKEN0_MASK                     0x0000000f
/** Set to enable the clock for LESENSE. @multiple */
  #define EFM32_CMU_LFACLKEN0_LESENSE              0x00000001
/** Set to enable the clock for RTC. @multiple */
  #define EFM32_CMU_LFACLKEN0_RTC                  0x00000002
/** Set to enable the clock for LETIMER0. @multiple */
  #define EFM32_CMU_LFACLKEN0_LETIMER0             0x00000004
/** Set to enable the clock for LCD. @multiple */
  #define EFM32_CMU_LFACLKEN0_LCD                  0x00000008
# endif

# if defined(CONFIG_EFM32_ZERO_GECKO)
#define EFM32_CMU_LFBCLKEN0_ADDR                     0x00000060
#define EFM32_CMU_LFBCLKEN0_MASK                     0x00000001
/** Set to enable the clock for LEUART0. @multiple */
  #define EFM32_CMU_LFBCLKEN0_LEUART0              0x00000001
# endif

# if defined(CONFIG_EFM32_GECKO) || defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
#define EFM32_CMU_LFBCLKEN0_ADDR                     0x00000060
#define EFM32_CMU_LFBCLKEN0_MASK                     0x00000003
/** Set to enable the clock for LEUART0. @multiple */
  #define EFM32_CMU_LFBCLKEN0_LEUART0              0x00000001
/** Set to enable the clock for LEUART1. @multiple */
  #define EFM32_CMU_LFBCLKEN0_LEUART1              0x00000002
# endif

# if defined(CONFIG_EFM32_GECKO)
#define EFM32_CMU_LFAPRESC0_ADDR                     0x00000068
#define EFM32_CMU_LFAPRESC0_MASK                     0x000003ff
/** Configure Real-Time Counter prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_RTC(v)               ((EFM32_CMU_LFAPRESC0_RTC_##v) << 0)
  #define EFM32_CMU_LFAPRESC0_RTC_SET(x, v)        do { (x) = (((x) & ~0xf) | ((EFM32_CMU_LFAPRESC0_RTC_##v) << 0)); } while(0)
  #define EFM32_CMU_LFAPRESC0_RTC_GET(x)           (((x) >> 0) & 0xf)
    #define EFM32_CMU_LFAPRESC0_RTC_DIV1             0x00000000
    #define EFM32_CMU_LFAPRESC0_RTC_DIV2             0x00000001
    #define EFM32_CMU_LFAPRESC0_RTC_DIV4             0x00000002
    #define EFM32_CMU_LFAPRESC0_RTC_DIV8             0x00000003
    #define EFM32_CMU_LFAPRESC0_RTC_DIV16            0x00000004
    #define EFM32_CMU_LFAPRESC0_RTC_DIV32            0x00000005
    #define EFM32_CMU_LFAPRESC0_RTC_DIV64            0x00000006
    #define EFM32_CMU_LFAPRESC0_RTC_DIV128           0x00000007
    #define EFM32_CMU_LFAPRESC0_RTC_DIV256           0x00000008
    #define EFM32_CMU_LFAPRESC0_RTC_DIV512           0x00000009
    #define EFM32_CMU_LFAPRESC0_RTC_DIV1024          0x0000000a
    #define EFM32_CMU_LFAPRESC0_RTC_DIV2048          0x0000000b
    #define EFM32_CMU_LFAPRESC0_RTC_DIV4096          0x0000000c
    #define EFM32_CMU_LFAPRESC0_RTC_DIV8192          0x0000000d
    #define EFM32_CMU_LFAPRESC0_RTC_DIV16384         0x0000000e
    #define EFM32_CMU_LFAPRESC0_RTC_DIV32768         0x0000000f
/** Configure Real-Time Counter prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_LETIMER0(v)          ((EFM32_CMU_LFAPRESC0_LETIMER0_##v) << 4)
  #define EFM32_CMU_LFAPRESC0_LETIMER0_SET(x, v)   do { (x) = (((x) & ~0xf0) | ((EFM32_CMU_LFAPRESC0_LETIMER0_##v) << 4)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LETIMER0_GET(x)      (((x) >> 4) & 0xf)
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV1        0x00000000
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV2        0x00000001
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV4        0x00000002
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV8        0x00000003
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV16       0x00000004
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV32       0x00000005
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV64       0x00000006
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV128      0x00000007
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV256      0x00000008
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV512      0x00000009
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV1024     0x0000000a
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV2048     0x0000000b
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV4096     0x0000000c
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV8192     0x0000000d
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV16384    0x0000000e
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV32768    0x0000000f
/** Configure LCD controller prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_LCD(v)               ((EFM32_CMU_LFAPRESC0_LCD_##v) << 8)
  #define EFM32_CMU_LFAPRESC0_LCD_SET(x, v)        do { (x) = (((x) & ~0x300) | ((EFM32_CMU_LFAPRESC0_LCD_##v) << 8)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LCD_GET(x)           (((x) >> 8) & 0x3)
    #define EFM32_CMU_LFAPRESC0_LCD_DIV16            0x00000000
    #define EFM32_CMU_LFAPRESC0_LCD_DIV32            0x00000001
    #define EFM32_CMU_LFAPRESC0_LCD_DIV64            0x00000002
    #define EFM32_CMU_LFAPRESC0_LCD_DIV128           0x00000003
# endif

# if defined(CONFIG_EFM32_ZERO_GECKO)
#define EFM32_CMU_LFAPRESC0_ADDR                     0x00000068
#define EFM32_CMU_LFAPRESC0_MASK                     0x0000000f
/** Configure Real-Time Counter prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_RTC(v)               ((EFM32_CMU_LFAPRESC0_RTC_##v) << 0)
  #define EFM32_CMU_LFAPRESC0_RTC_SET(x, v)        do { (x) = (((x) & ~0xf) | ((EFM32_CMU_LFAPRESC0_RTC_##v) << 0)); } while(0)
  #define EFM32_CMU_LFAPRESC0_RTC_GET(x)           (((x) >> 0) & 0xf)
    #define EFM32_CMU_LFAPRESC0_RTC_DIV1             0x00000000
    #define EFM32_CMU_LFAPRESC0_RTC_DIV2             0x00000001
    #define EFM32_CMU_LFAPRESC0_RTC_DIV4             0x00000002
    #define EFM32_CMU_LFAPRESC0_RTC_DIV8             0x00000003
    #define EFM32_CMU_LFAPRESC0_RTC_DIV16            0x00000004
    #define EFM32_CMU_LFAPRESC0_RTC_DIV32            0x00000005
    #define EFM32_CMU_LFAPRESC0_RTC_DIV64            0x00000006
    #define EFM32_CMU_LFAPRESC0_RTC_DIV128           0x00000007
    #define EFM32_CMU_LFAPRESC0_RTC_DIV256           0x00000008
    #define EFM32_CMU_LFAPRESC0_RTC_DIV512           0x00000009
    #define EFM32_CMU_LFAPRESC0_RTC_DIV1024          0x0000000a
    #define EFM32_CMU_LFAPRESC0_RTC_DIV2048          0x0000000b
    #define EFM32_CMU_LFAPRESC0_RTC_DIV4096          0x0000000c
    #define EFM32_CMU_LFAPRESC0_RTC_DIV8192          0x0000000d
    #define EFM32_CMU_LFAPRESC0_RTC_DIV16384         0x0000000e
    #define EFM32_CMU_LFAPRESC0_RTC_DIV32768         0x0000000f
# endif

# if defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
#define EFM32_CMU_LFAPRESC0_ADDR                     0x00000068
#define EFM32_CMU_LFAPRESC0_MASK                     0x00007ff3
/** Configure Low Energy Interface prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_LESENSE(v)           ((EFM32_CMU_LFAPRESC0_LESENSE_##v) << 0)
  #define EFM32_CMU_LFAPRESC0_LESENSE_SET(x, v)    do { (x) = (((x) & ~0x3) | ((EFM32_CMU_LFAPRESC0_LESENSE_##v) << 0)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LESENSE_GET(x)       (((x) >> 0) & 0x3)
    #define EFM32_CMU_LFAPRESC0_LESENSE_DIV1         0x00000000
    #define EFM32_CMU_LFAPRESC0_LESENSE_DIV2         0x00000001
    #define EFM32_CMU_LFAPRESC0_LESENSE_DIV4         0x00000002
    #define EFM32_CMU_LFAPRESC0_LESENSE_DIV8         0x00000003
/** Configure Real-Time Counter prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_RTC(v)               ((EFM32_CMU_LFAPRESC0_RTC_##v) << 4)
  #define EFM32_CMU_LFAPRESC0_RTC_SET(x, v)        do { (x) = (((x) & ~0xf0) | ((EFM32_CMU_LFAPRESC0_RTC_##v) << 4)); } while(0)
  #define EFM32_CMU_LFAPRESC0_RTC_GET(x)           (((x) >> 4) & 0xf)
    #define EFM32_CMU_LFAPRESC0_RTC_DIV1             0x00000000
    #define EFM32_CMU_LFAPRESC0_RTC_DIV2             0x00000001
    #define EFM32_CMU_LFAPRESC0_RTC_DIV4             0x00000002
    #define EFM32_CMU_LFAPRESC0_RTC_DIV8             0x00000003
    #define EFM32_CMU_LFAPRESC0_RTC_DIV16            0x00000004
    #define EFM32_CMU_LFAPRESC0_RTC_DIV32            0x00000005
    #define EFM32_CMU_LFAPRESC0_RTC_DIV64            0x00000006
    #define EFM32_CMU_LFAPRESC0_RTC_DIV128           0x00000007
    #define EFM32_CMU_LFAPRESC0_RTC_DIV256           0x00000008
    #define EFM32_CMU_LFAPRESC0_RTC_DIV512           0x00000009
    #define EFM32_CMU_LFAPRESC0_RTC_DIV1024          0x0000000a
    #define EFM32_CMU_LFAPRESC0_RTC_DIV2048          0x0000000b
    #define EFM32_CMU_LFAPRESC0_RTC_DIV4096          0x0000000c
    #define EFM32_CMU_LFAPRESC0_RTC_DIV8192          0x0000000d
    #define EFM32_CMU_LFAPRESC0_RTC_DIV16384         0x0000000e
    #define EFM32_CMU_LFAPRESC0_RTC_DIV32768         0x0000000f
/** Configure Real-Time Counter prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_LETIMER0(v)          ((EFM32_CMU_LFAPRESC0_LETIMER0_##v) << 8)
  #define EFM32_CMU_LFAPRESC0_LETIMER0_SET(x, v)   do { (x) = (((x) & ~0xf00) | ((EFM32_CMU_LFAPRESC0_LETIMER0_##v) << 8)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LETIMER0_GET(x)      (((x) >> 8) & 0xf)
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV1        0x00000000
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV2        0x00000001
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV4        0x00000002
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV8        0x00000003
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV16       0x00000004
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV32       0x00000005
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV64       0x00000006
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV128      0x00000007
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV256      0x00000008
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV512      0x00000009
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV1024     0x0000000a
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV2048     0x0000000b
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV4096     0x0000000c
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV8192     0x0000000d
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV16384    0x0000000e
    #define EFM32_CMU_LFAPRESC0_LETIMER0_DIV32768    0x0000000f
/** Configure LCD controller prescaler @multiple */
  #define EFM32_CMU_LFAPRESC0_LCD(v)               ((EFM32_CMU_LFAPRESC0_LCD_##v) << 12)
  #define EFM32_CMU_LFAPRESC0_LCD_SET(x, v)        do { (x) = (((x) & ~0x7000) | ((EFM32_CMU_LFAPRESC0_LCD_##v) << 12)); } while(0)
  #define EFM32_CMU_LFAPRESC0_LCD_GET(x)           (((x) >> 12) & 0x7)
    #define EFM32_CMU_LFAPRESC0_LCD_DIV16            0x00000000
    #define EFM32_CMU_LFAPRESC0_LCD_DIV32            0x00000001
    #define EFM32_CMU_LFAPRESC0_LCD_DIV64            0x00000002
    #define EFM32_CMU_LFAPRESC0_LCD_DIV128           0x00000003
# endif

# if defined(CONFIG_EFM32_ZERO_GECKO)
#define EFM32_CMU_LFBPRESC0_ADDR                     0x00000070
#define EFM32_CMU_LFBPRESC0_MASK                     0x00000003
/** Configure LEUART0 prescaler @multiple */
  #define EFM32_CMU_LFBPRESC0_LEUART0(v)           ((EFM32_CMU_LFBPRESC0_LEUART0_##v) << 0)
  #define EFM32_CMU_LFBPRESC0_LEUART0_SET(x, v)    do { (x) = (((x) & ~0x3) | ((EFM32_CMU_LFBPRESC0_LEUART0_##v) << 0)); } while(0)
  #define EFM32_CMU_LFBPRESC0_LEUART0_GET(x)       (((x) >> 0) & 0x3)
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV1         0x00000000
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV2         0x00000001
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV4         0x00000002
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV8         0x00000003
# endif

# if defined(CONFIG_EFM32_GECKO) || defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
#define EFM32_CMU_LFBPRESC0_ADDR                     0x00000070
#define EFM32_CMU_LFBPRESC0_MASK                     0x00000033
/** Configure LEUART0 prescaler @multiple */
  #define EFM32_CMU_LFBPRESC0_LEUART0(v)           ((EFM32_CMU_LFBPRESC0_LEUART0_##v) << 0)
  #define EFM32_CMU_LFBPRESC0_LEUART0_SET(x, v)    do { (x) = (((x) & ~0x3) | ((EFM32_CMU_LFBPRESC0_LEUART0_##v) << 0)); } while(0)
  #define EFM32_CMU_LFBPRESC0_LEUART0_GET(x)       (((x) >> 0) & 0x3)
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV1         0x00000000
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV2         0x00000001
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV4         0x00000002
    #define EFM32_CMU_LFBPRESC0_LEUART0_DIV8         0x00000003
/** Configure LEUART1 prescaler @multiple */
  #define EFM32_CMU_LFBPRESC0_LEUART1(v)           ((EFM32_CMU_LFBPRESC0_LEUART1_##v) << 4)
  #define EFM32_CMU_LFBPRESC0_LEUART1_SET(x, v)    do { (x) = (((x) & ~0x30) | ((EFM32_CMU_LFBPRESC0_LEUART1_##v) << 4)); } while(0)
  #define EFM32_CMU_LFBPRESC0_LEUART1_GET(x)       (((x) >> 4) & 0x3)
    #define EFM32_CMU_LFBPRESC0_LEUART1_DIV1         0x00000000
    #define EFM32_CMU_LFBPRESC0_LEUART1_DIV2         0x00000001
    #define EFM32_CMU_LFBPRESC0_LEUART1_DIV4         0x00000002
    #define EFM32_CMU_LFBPRESC0_LEUART1_DIV8         0x00000003
# endif

#define EFM32_CMU_PCNTCTRL_ADDR                      0x00000078
#define EFM32_CMU_PCNTCTRL_MASK                      0x00000003
/** This bit enables/disables the clock to the PCNT. @multiple */
  #define EFM32_CMU_PCNTCTRL_PCNT0CLKEN            0x00000001
/** This bit controls which clock that is used for the PCNT. @multiple */
  #define EFM32_CMU_PCNTCTRL_PCNT0CLKSEL(v)        ((EFM32_CMU_PCNTCTRL_PCNT0CLKSEL_##v) << 1)
  #define EFM32_CMU_PCNTCTRL_PCNT0CLKSEL_SET(x, v) do { (x) = (((x) & ~0x2) | ((EFM32_CMU_PCNTCTRL_PCNT0CLKSEL_##v) << 1)); } while(0)
  #define EFM32_CMU_PCNTCTRL_PCNT0CLKSEL_GET(x)    (((x) >> 1) & 0x1)
    #define EFM32_CMU_PCNTCTRL_PCNT0CLKSEL_LFACLK    0x00000000
    #define EFM32_CMU_PCNTCTRL_PCNT0CLKSEL_PCNT0S0   0x00000001
# if defined(CONFIG_EFM32_GECKO) || defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
/** This bit enables/disables the clock to the PCNT. @multiple */
  #define EFM32_CMU_PCNTCTRL_PCNT1CLKEN            0x00000004
/** This bit controls which clock that is used for the PCNT. @multiple */
  #define EFM32_CMU_PCNTCTRL_PCNT1CLKSEL(v)        ((EFM32_CMU_PCNTCTRL_PCNT1CLKSEL_##v) << 3)
  #define EFM32_CMU_PCNTCTRL_PCNT1CLKSEL_SET(x, v) do { (x) = (((x) & ~0x8) | ((EFM32_CMU_PCNTCTRL_PCNT1CLKSEL_##v) << 3)); } while(0)
  #define EFM32_CMU_PCNTCTRL_PCNT1CLKSEL_GET(x)    (((x) >> 3) & 0x1)
    #define EFM32_CMU_PCNTCTRL_PCNT1CLKSEL_LFACLK    0x00000000
    #define EFM32_CMU_PCNTCTRL_PCNT1CLKSEL_PCNT1S0   0x00000001
/** This bit enables/disables the clock to the PCNT. @multiple */
  #define EFM32_CMU_PCNTCTRL_PCNT2CLKEN            0x00000010
/** This bit controls which clock that is used for the PCNT. @multiple */
  #define EFM32_CMU_PCNTCTRL_PCNT2CLKSEL(v)        ((EFM32_CMU_PCNTCTRL_PCNT2CLKSEL_##v) << 5)
  #define EFM32_CMU_PCNTCTRL_PCNT2CLKSEL_SET(x, v) do { (x) = (((x) & ~0x20) | ((EFM32_CMU_PCNTCTRL_PCNT2CLKSEL_##v) << 5)); } while(0)
  #define EFM32_CMU_PCNTCTRL_PCNT2CLKSEL_GET(x)    (((x) >> 5) & 0x1)
    #define EFM32_CMU_PCNTCTRL_PCNT2CLKSEL_LFACLK    0x00000000
    #define EFM32_CMU_PCNTCTRL_PCNT2CLKSEL_PCNT2S0   0x00000001
# endif

# if defined(CONFIG_EFM32_GECKO) || defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
#define EFM32_CMU_LCDCTRL_ADDR                       0x0000007c
#define EFM32_CMU_LCDCTRL_MASK                       0x0000007f
/** These bits controls the framerate according to this formula: LFACLKLCD =
   LFACLKLCDpre / (1 + FDIV). Do not change this value while the LCD bit in
   LFACLKEN0 is set to 1. @multiple */
  #define EFM32_CMU_LCDCTRL_FDIV(v)                ((v) << 0)
  #define EFM32_CMU_LCDCTRL_FDIV_SET(x, v)         do { (x) = (((x) & ~0x7) | ((v) << 0)); } while(0)
  #define EFM32_CMU_LCDCTRL_FDIV_GET(x)            (((x) >> 0) & 0x7)
/** This bit enables/disables the VBOOST function. @multiple */
  #define EFM32_CMU_LCDCTRL_VBOOSTEN               0x00000008
/** These bits control the voltage boost update frequency division. Voltage Boost
   update Frequency = LFACLK / DIV. @multiple */
  #define EFM32_CMU_LCDCTRL_VBFDIV(v)              ((EFM32_CMU_LCDCTRL_VBFDIV_##v) << 4)
  #define EFM32_CMU_LCDCTRL_VBFDIV_SET(x, v)       do { (x) = (((x) & ~0x70) | ((EFM32_CMU_LCDCTRL_VBFDIV_##v) << 4)); } while(0)
  #define EFM32_CMU_LCDCTRL_VBFDIV_GET(x)          (((x) >> 4) & 0x7)
    #define EFM32_CMU_LCDCTRL_VBFDIV_DIV1            0x00000000
    #define EFM32_CMU_LCDCTRL_VBFDIV_DIV2            0x00000001
    #define EFM32_CMU_LCDCTRL_VBFDIV_DIV4            0x00000002
    #define EFM32_CMU_LCDCTRL_VBFDIV_DIV8            0x00000003
    #define EFM32_CMU_LCDCTRL_VBFDIV_DIV16           0x00000004
    #define EFM32_CMU_LCDCTRL_VBFDIV_DIV32           0x00000005
# endif

#define EFM32_CMU_ROUTE_ADDR                         0x00000080
#define EFM32_CMU_ROUTE_MASK                         0x00000003
/** When set, the CLKOUT0 pin is enabled. @multiple */
  #define EFM32_CMU_ROUTE_CLKOUT0PEN               0x00000001
/** When set, the CLKOUT1 pin is enabled. @multiple */
  #define EFM32_CMU_ROUTE_CLKOUT1PEN               0x00000002
# if defined(CONFIG_EFM32_GECKO)
/** Decides the location of the CMU I/O pins. @multiple */
  #define EFM32_CMU_ROUTE_LOCATION(v)              ((EFM32_CMU_ROUTE_LOCATION_##v) << 2)
  #define EFM32_CMU_ROUTE_LOCATION_SET(x, v)       do { (x) = (((x) & ~0x4) | ((EFM32_CMU_ROUTE_LOCATION_##v) << 2)); } while(0)
  #define EFM32_CMU_ROUTE_LOCATION_GET(x)          (((x) >> 2) & 0x1)
    #define EFM32_CMU_ROUTE_LOCATION_LOC0            0x00000000
# endif
# if defined(CONFIG_EFM32_ZERO_GECKO) || defined(CONFIG_EFM32_LEOPARD_GECKO) || defined(CONFIG_EFM32_WONDER_GECKO)
/** Decides the location of the CMU I/O pins. @multiple */
  #define EFM32_CMU_ROUTE_LOCATION(v)              ((EFM32_CMU_ROUTE_LOCATION_##v) << 2)
  #define EFM32_CMU_ROUTE_LOCATION_SET(x, v)       do { (x) = (((x) & ~0x1c) | ((EFM32_CMU_ROUTE_LOCATION_##v) << 2)); } while(0)
  #define EFM32_CMU_ROUTE_LOCATION_GET(x)          (((x) >> 2) & 0x7)
    #define EFM32_CMU_ROUTE_LOCATION_LOC0            0x00000000
    #define EFM32_CMU_ROUTE_LOCATION_LOC1            0x00000001
    #define EFM32_CMU_ROUTE_LOCATION_LOC2            0x00000002
# endif

#define EFM32_CMU_LOCK_ADDR                          0x00000084
#define EFM32_CMU_LOCK_MASK                          0x0000ffff
/** Write any other value than the unlock code to lock CMU_CTRL,
   CMU_HFCORECLKDIV, CMU_HFPERCLKDIV, CMU_HFRCOCTRL, CMU_LFRCOCTRL,
   CMU_AUXHFRCOCTRL, CMU_OSCENCMD, CMU_CMD, CMU_LFCLKSEL, CMU_HFCORECLKEN0,
   CMU_HFPERCLKEN0, CMU_LFACLKEN0, CMU_LFBCLKEN0, CMU_LFAPRESC0, CMU_LFBPRESC0,
   and CMU_PCNTCTRL from editing. Write the unlock code to unlock. When reading
   the register, bit 0 is set when the lock is enabled. @multiple */
  #define EFM32_CMU_LOCK_LOCKKEY(v)                ((EFM32_CMU_LOCK_LOCKKEY_##v) << 0)
  #define EFM32_CMU_LOCK_LOCKKEY_SET(x, v)         do { (x) = (((x) & ~0xffff) | ((EFM32_CMU_LOCK_LOCKKEY_##v) << 0)); } while(0)
  #define EFM32_CMU_LOCK_LOCKKEY_GET(x)            (((x) >> 0) & 0xffff)
    #define EFM32_CMU_LOCK_LOCKKEY_UNLOCKED          0x00000000
    #define EFM32_CMU_LOCK_LOCKKEY_LOCKED            0x00000001
    #define EFM32_CMU_LOCK_LOCKKEY_UNLOCK            0x0000580e

#endif

