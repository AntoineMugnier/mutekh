/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -o cdefs -O arch/efm32/include/arch/efm32/rtc.h cdefs_use_reg_mask=1  \
     cdefs_use_field_setval=1
*/

#ifndef _EFM32_RTC_BFGEN_DEFS_
#define _EFM32_RTC_BFGEN_DEFS_

#define EFM32_RTC_CTRL_ADDR                          0x00000000
#define EFM32_RTC_CTRL_MASK                          0x00000007
/** When this bit is set, the RTC is enabled and counts up. When cleared, the
   counter register CNT is reset. @multiple */
  #define EFM32_RTC_CTRL_EN(v)                       ((EFM32_RTC_CTRL_EN_##v) << 0)
  #define EFM32_RTC_CTRL_EN_SET(x, v)                do { (x) = (((x) & ~0x1) | ((EFM32_RTC_CTRL_EN_##v) << 0)); } while(0)
  #define EFM32_RTC_CTRL_EN_SETVAL(x, v)             do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define EFM32_RTC_CTRL_EN_GET(x)                   (((x) >> 0) & 0x1)
    #define EFM32_RTC_CTRL_EN_RESET                    0x00000000
    #define EFM32_RTC_CTRL_EN_COUNT                    0x00000001
/** Set this bit to enable the RTC to keep running in debug @multiple */
  #define EFM32_RTC_CTRL_DEBUGRUN(v)                 ((EFM32_RTC_CTRL_DEBUGRUN_##v) << 1)
  #define EFM32_RTC_CTRL_DEBUGRUN_SET(x, v)          do { (x) = (((x) & ~0x2) | ((EFM32_RTC_CTRL_DEBUGRUN_##v) << 1)); } while(0)
  #define EFM32_RTC_CTRL_DEBUGRUN_SETVAL(x, v)       do { (x) = (((x) & ~0x2) | ((v) << 1)); } while(0)
  #define EFM32_RTC_CTRL_DEBUGRUN_GET(x)             (((x) >> 1) & 0x1)
    #define EFM32_RTC_CTRL_DEBUGRUN_FROZEN             0x00000000
    #define EFM32_RTC_CTRL_DEBUGRUN_RUNNING            0x00000001
/** When set, the counter is cleared in the clock cycle after a compare match
   with compare channel 0 @multiple */
  #define EFM32_RTC_CTRL_COMP0TOP(v)                 ((EFM32_RTC_CTRL_COMP0TOP_##v) << 2)
  #define EFM32_RTC_CTRL_COMP0TOP_SET(x, v)          do { (x) = (((x) & ~0x4) | ((EFM32_RTC_CTRL_COMP0TOP_##v) << 2)); } while(0)
  #define EFM32_RTC_CTRL_COMP0TOP_SETVAL(x, v)       do { (x) = (((x) & ~0x4) | ((v) << 2)); } while(0)
  #define EFM32_RTC_CTRL_COMP0TOP_GET(x)             (((x) >> 2) & 0x1)
    #define EFM32_RTC_CTRL_COMP0TOP_TOPMAX             0x00000000
    #define EFM32_RTC_CTRL_COMP0TOP_TOPCOMP0           0x00000001

#define EFM32_RTC_CNT_ADDR                           0x00000004
#define EFM32_RTC_CNT_MASK                           0x00ffffff
/** Gives access to the counter value of the RTC. @multiple */
  #define EFM32_RTC_CNT_CNT(v)                       ((v) << 0)
  #define EFM32_RTC_CNT_CNT_SET(x, v)                do { (x) = (((x) & ~0xffffff) | ((v) << 0)); } while(0)
  #define EFM32_RTC_CNT_CNT_GET(x)                   (((x) >> 0) & 0xffffff)

#define EFM32_RTC_COMP0_ADDR                         0x00000008
#define EFM32_RTC_COMP0_MASK                         0x00ffffff
/** A compare match event occurs when CNT is equal to this value. This event sets
   the COMP0 interrupt flag, and can be used to start the LETIMER. It is also
   available as a PRS signal. @multiple */
  #define EFM32_RTC_COMP0_VAL(v)                     ((v) << 0)
  #define EFM32_RTC_COMP0_VAL_SET(x, v)              do { (x) = (((x) & ~0xffffff) | ((v) << 0)); } while(0)
  #define EFM32_RTC_COMP0_VAL_GET(x)                 (((x) >> 0) & 0xffffff)

#define EFM32_RTC_COMP1_ADDR                         0x0000000c
#define EFM32_RTC_COMP1_MASK                         0x00ffffff
/** A compare match event occurs when CNT is equal to this value. This event sets
   the COMP1 interrupt flag, and can be used to start the LETIMER. It is also
   available as a PRS signal. @multiple */
  #define EFM32_RTC_COMP1_VAL(v)                     ((v) << 0)
  #define EFM32_RTC_COMP1_VAL_SET(x, v)              do { (x) = (((x) & ~0xffffff) | ((v) << 0)); } while(0)
  #define EFM32_RTC_COMP1_VAL_GET(x)                 (((x) >> 0) & 0xffffff)

#define EFM32_RTC_IF_ADDR                            0x00000010
#define EFM32_RTC_IF_MASK                            0x00000007
/** Set on a CNT value overflow. @multiple */
  #define EFM32_RTC_IF_OF                            0x00000001
/** Set on a compare match between CNT and COMP0. @multiple */
  #define EFM32_RTC_IF_COMP0                         0x00000002
/** Set on a compare match between CNT and COMP1. @multiple */
  #define EFM32_RTC_IF_COMP1                         0x00000004

#define EFM32_RTC_IFS_ADDR                           0x00000014
#define EFM32_RTC_IFS_MASK                           0x00000007
/** Write to 1 to set the OF interrupt flag. @multiple */
  #define EFM32_RTC_IFS_OF                           0x00000001
/** Write to 1 to set the COMP0 interrupt flag. @multiple */
  #define EFM32_RTC_IFS_COMP0                        0x00000002
/** Write to 1 to set the COMP1 interrupt flag. @multiple */
  #define EFM32_RTC_IFS_COMP1                        0x00000004

#define EFM32_RTC_IFC_ADDR                           0x00000018
#define EFM32_RTC_IFC_MASK                           0x00000007
/** Write to 1 to clear the OF interrupt flag. @multiple */
  #define EFM32_RTC_IFC_OF                           0x00000001
/** Write to 1 to clear the COMP0 interrupt flag. @multiple */
  #define EFM32_RTC_IFC_COMP0                        0x00000002
/** Write to 1 to clear the COMP1 interrupt flag. @multiple */
  #define EFM32_RTC_IFC_COMP1                        0x00000004

#define EFM32_RTC_IEN_ADDR                           0x0000001c
#define EFM32_RTC_IEN_MASK                           0x00000007
/** Enable interrupt on overflow. @multiple */
  #define EFM32_RTC_IEN_OF                           0x00000001
/** Enable interrupt on compare match 0. @multiple */
  #define EFM32_RTC_IEN_COMP0                        0x00000002
/** Enable interrupt on compare match 1. @multiple */
  #define EFM32_RTC_IEN_COMP1                        0x00000004

#define EFM32_RTC_FREEZE_ADDR                        0x00000020
#define EFM32_RTC_FREEZE_MASK                        0x00000001
/** When set, the update of the RTC is postponed until this bit is cleared. Use
   this bit to update several registers simultaneously. @multiple */
  #define EFM32_RTC_FREEZE_REGFREEZE(v)              ((EFM32_RTC_FREEZE_REGFREEZE_##v) << 0)
  #define EFM32_RTC_FREEZE_REGFREEZE_SET(x, v)       do { (x) = (((x) & ~0x1) | ((EFM32_RTC_FREEZE_REGFREEZE_##v) << 0)); } while(0)
  #define EFM32_RTC_FREEZE_REGFREEZE_SETVAL(x, v)    do { (x) = (((x) & ~0x1) | ((v) << 0)); } while(0)
  #define EFM32_RTC_FREEZE_REGFREEZE_GET(x)          (((x) >> 0) & 0x1)
    #define EFM32_RTC_FREEZE_REGFREEZE_UPDATE          0x00000000
    #define EFM32_RTC_FREEZE_REGFREEZE_FREEZE          0x00000001

#define EFM32_RTC_SYNCBUSY_ADDR                      0x00000024
#define EFM32_RTC_SYNCBUSY_MASK                      0x00000007
/** Set when the value written to CTRL is being synchronized. @multiple */
  #define EFM32_RTC_SYNCBUSY_CTRL                    0x00000001
/** Set when the value written to COMP0 is being synchronized. @multiple */
  #define EFM32_RTC_SYNCBUSY_COMP0                   0x00000002
/** Set when the value written to COMP1 is being synchronized. @multiple */
  #define EFM32_RTC_SYNCBUSY_COMP1                   0x00000004

#endif

