/*
    This file is part of MutekH.

    MutekH is free software; you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation; version 2.1 of the
    License.

    MutekH is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with MutekH; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301 USA.

    Copyright Sebastien Cerdan <sebcerdan@gmail.com> (c) 2018

    API for Bitbanging.
*/

/**
   @file
   @module {Core::Devices support library}
   @short IO bitbang driver API
   @index {IO bitbang} {Device classes}
   @csee DRIVER_CLASS_BITBANG

   @section {Purpose}

   This class allows generation and sampling of a digital signal on an
   IO line. The waveform is defined by an array containing duration
   of high and low levels of the signal.

   Drivers which implement this class must check for a @ref
   DEV_RES_IOMUX resource named @tt {io}.

   @end section
*/

#ifndef __DEVICE_BITBANG_H__
#define __DEVICE_BITBANG_H__

#include <mutek/kroutine.h>
#include <hexo/types.h>
#include <hexo/error.h>

#include <device/driver.h>
#include <device/class/timer.h>
#include <device/request.h>

#include <hexo/enum.h>

struct device_bitbang_s;

typedef uint16_t dev_bitbang_sample_delay_t;

/***************************************** requests */

/** @This specifies the various bigbang operations. */
enum dev_bitbang_rq_rtype_e
{
  /** A waveform is generated by inverting the output @tt {count+1}
      times. When @tt{count>0}, the array of samples specifies the
      delays between the edges. */
  DEV_BITBANG_WRITE,
  /** This performs as @ref DEV_BITBANG_WRITE, forcing the output
      high at the end. */
  DEV_BITBANG_WRITE_RISE,
  /** This performs as @ref DEV_BITBANG_WRITE, forcing the output
      low at the end. */
  DEV_BITBANG_WRITE_FALL,
  /** A signal is recorded. The waveform of the signal is stored in
      the array of samples. The samples reflect the edges duration. */
  DEV_BITBANG_READ,
};

/** @This specifies the integer type used to store samples for a
    bitbang request. */
enum dev_bitbang_word_width_e
{
  /** Samples are stored as @tt uint8_t */
  DEV_BITBANG_8BITS,
  /** Samples are stored as @tt uint16_t */
  DEV_BITBANG_16BITS,
  /** Samples are stored as @tt uint32_t */
  DEV_BITBANG_32BITS,
};

struct dev_bitbang_rq_s
{
  union {
    struct dev_request_s base;
    FIELD_USING(struct dev_request_s, error);
    FIELD_USING(struct dev_request_s, pvdata);
  };

  /** @This specifies the operation to perform */
  enum dev_bitbang_rq_rtype_e        type;

  /** When different from @ref DEV_PIN_DISABLED, the driving mode of
      the pin is changed to the specified value before execution of
      the request. */
  enum dev_pin_driving_e             drive_start;

  /** When different from @ref DEV_PIN_DISABLED, the driving mode of
      the pin is changed to the specified value after execution of the
      request. */
  enum dev_pin_driving_e             drive_stop;

  /** This specifies the type of integer used in the array of samples. */
  enum dev_bitbang_word_width_e      width;

  /** Number of samples in the array. This must initialy be set to the
      size of the samples array. When the request type is @ref
      DEV_BITBANG_READ, this field is updated by the driver with the
      actual number of samples stored. When write requests are used,
      a zero count is allowed. */
  size_t                             count;

  /** The waveform of the signal is defined by the content of this
      array. Each value in this array specifies a delay between two
      edges. */
  void                               *samples;

  /** @ref DEV_BITBANG_READ requests are ended when no change is
      detected for the specified duration. No timeout is used when
      this field is 0. */
  uint32_t                           read_timeout;

  /** This defines the base time unit used for samples and timeout. */
  struct dev_freq_s                  unit;
};

DEV_REQUEST_INHERIT(bitbang);
DEV_REQUEST_QUEUE_OPS(bitbang);

/** @see dev_bitbang_request_t */
#define DEV_BITBANG_REQUEST(n)	void  (n) (const struct device_bitbang_s *accessor,\
                                           struct dev_bitbang_rq_s * rq)

typedef DEV_BITBANG_REQUEST(dev_bitbang_request_t);

/** @see dev_bitbang_cancel_t */
#define DEV_BITBANG_CANCEL(n)  error_t (n) (const struct device_bitbang_s *accessor,\
                                            struct dev_bitbang_rq_s * rq)

typedef DEV_BITBANG_CANCEL(dev_bitbang_cancel_t);

/******************************************/

DRIVER_CLASS_TYPES(DRIVER_CLASS_BITBANG, bitbang,
                   dev_bitbang_request_t *f_request;
                   dev_bitbang_cancel_t *f_cancel;
                  );

/** @see driver_bitbang_s */
#define DRIVER_BITBANG_METHODS(prefix)                               \
  ((const struct driver_class_s*)&(const struct driver_bitbang_s){   \
    .class_ = DRIVER_CLASS_BITBANG,                                  \
    .f_request = prefix ## _request,                                 \
    .f_cancel = prefix ## _cancel                                    \
  })

DEV_REQUEST_WAIT_FUNC(bitbang);

#endif
